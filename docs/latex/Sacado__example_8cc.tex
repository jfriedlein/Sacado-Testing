\hypertarget{Sacado__example_8cc}{}\section{Sacado\+\_\+example.\+cc File Reference}
\label{Sacado__example_8cc}\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
{\ttfamily \#include $<$deal.\+I\+I/base/symmetric\+\_\+tensor.\+h$>$}\\*
{\ttfamily \#include $<$iostream$>$}\\*
{\ttfamily \#include $<$fstream$>$}\\*
{\ttfamily \#include $<$cmath$>$}\\*
{\ttfamily \#include $<$Sacado.\+hpp$>$}\\*
{\ttfamily \#include \char`\"{}Sacado\+\_\+\+Wrapper.\+h\char`\"{}}\\*
Include dependency graph for Sacado\+\_\+example.\+cc\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{Sacado__example_8cc__incl}
\end{center}
\end{figure}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\+\_\+double} = Sacado\+::\+Fad\+::\+D\+Fad$<$ double $>$
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}{sacado\+\_\+test\+\_\+scalar} ()
\item 
void \hyperlink{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}{sacado\+\_\+test\+\_\+2} ()
\item 
void \hyperlink{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}{sacado\+\_\+test\+\_\+3} ()
\item 
void \hyperlink{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}{sacado\+\_\+test\+\_\+3B} ()
\item 
void \hyperlink{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}{sacado\+\_\+test\+\_\+4} ()
\item 
void \hyperlink{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}{sacado\+\_\+test\+\_\+5} ()
\item 
void \hyperlink{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}{sacado\+\_\+test\+\_\+6} ()
\item 
void \hyperlink{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}{sacado\+\_\+test\+\_\+7} ()
\item 
void \hyperlink{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}{sacado\+\_\+test\+\_\+8} ()
\item 
void \hyperlink{Sacado__example_8cc_ae176f83fe1943e102fe325d4a14f097e}{sacado\+\_\+test\+\_\+9} ()
\item 
int \hyperlink{Sacado__example_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main} ()
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!fad\+\_\+double@{fad\+\_\+double}}
\index{fad\+\_\+double@{fad\+\_\+double}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{fad\+\_\+double}{fad_double}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf fad\+\_\+double} =  Sacado\+::\+Fad\+::\+D\+Fad$<$double$>$}\hypertarget{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{}\label{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}


\subsection{Function Documentation}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!main@{main}}
\index{main@{main}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{main()}{main()}}]{\setlength{\rightskip}{0pt plus 5cm}int main (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{}\label{Sacado__example_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}


References sacado\+\_\+test\+\_\+2(), sacado\+\_\+test\+\_\+3(), sacado\+\_\+test\+\_\+3\+B(), sacado\+\_\+test\+\_\+4(), sacado\+\_\+test\+\_\+5(), sacado\+\_\+test\+\_\+6(), sacado\+\_\+test\+\_\+7(), sacado\+\_\+test\+\_\+8(), sacado\+\_\+test\+\_\+9(), and sacado\+\_\+test\+\_\+scalar().


\begin{DoxyCode}
976 \{
977     \hyperlink{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}{sacado\_test\_scalar} ();
978 
979     std::cout << std::endl;
980 
981     \hyperlink{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}{sacado\_test\_2} ();
982 
983     std::cout << std::endl;
984 
985     \hyperlink{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}{sacado\_test\_3} ();
986 
987     std::cout << std::endl;
988 
989     \hyperlink{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}{sacado\_test\_3B} ();
990 
991     std::cout << std::endl;
992 
993     \hyperlink{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}{sacado\_test\_4}();
994 
995     std::cout << std::endl;
996 
997     \hyperlink{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}{sacado\_test\_5}();
998 
999     std::cout << std::endl;
1000 
1001     \hyperlink{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}{sacado\_test\_6}();
1002 
1003     std::cout << std::endl;
1004 
1005     \hyperlink{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}{sacado\_test\_7}();
1006 
1007     std::cout << std::endl;
1008 
1009     \hyperlink{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}{sacado\_test\_8}();
1010 
1011     std::cout << std::endl;
1012 
1013     \hyperlink{Sacado__example_8cc_ae176f83fe1943e102fe325d4a14f097e}{sacado\_test\_9}();
1014 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+2@{sacado\+\_\+test\+\_\+2}}
\index{sacado\+\_\+test\+\_\+2@{sacado\+\_\+test\+\_\+2}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+2()}{sacado_test_2()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+2 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}{}\label{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}


Referenced by main().


\begin{DoxyCode}
67 \{
68     std::cout << \textcolor{stringliteral}{"Test 2:"} << std::endl;
69 
70     \textcolor{comment}{// First we set the dimension \(\backslash\)a dim: 2D->dim=2; 3D->dim=3 \(\backslash\)n This defines the "size" of the tensors
       and the number of dofs. Ex2 only works in 3D, whereas the following Ex3 is set up dimension-independent.}
71     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim = 3;
72 
73     \textcolor{comment}{// Declare our input, auxiliary and output variables as SymmetricTensors consisting of fad\_doubles
       (instead of the standard SymmetricTensor out of doubles)}
74     SymmetricTensor<2,dim, fad\_double> sigma, eps;
75 
76     \textcolor{comment}{// Init the strain tensor (the point at which the derivative shall be computed)}
77     eps[0][0] = 1;
78     eps[1][1] = 2;
79     eps[2][2] = 3;
80     eps[0][1] = 4;
81     eps[0][2] = 5;
82     eps[1][2] = 6;
83 
84     \textcolor{comment}{// Now we declare the dofs. The derivative to a tensor requires all components, therefore we set the
       components of the strain tensor here one by one as the dofs.}
85     \textcolor{comment}{// Because our tensors are symmetric, we only need 6 components in 3D instead of 9 for a full second
       order tensor}
86     eps[0][0].diff(0,6);
87     eps[1][1].diff(1,6);
88     eps[2][2].diff(2,6);
89     eps[0][1].diff(3,6);
90     eps[0][2].diff(4,6);
91     eps[1][2].diff(5,6);
92 
93     \textcolor{comment}{// The equation describing the stresses (here just a simple test case)}
94     sigma = eps;
95 
96     \textcolor{comment}{// Let's output the computed stress tensor.}
97     std::cout << sigma << std::endl;
98     \textcolor{comment}{// The resulting values of \(\backslash\)a sigma are fairly boring, due to our simple equation. It is the additional
       output generated by}
99     \textcolor{comment}{// this, that is interesting here: \(\backslash\)n}
100     \textcolor{comment}{// output: \(\backslash\)n}
101     \textcolor{comment}{// 1 [ 1 0 0 0 0 0 ] 4 [ 0 0 0 1 0 0 ] 5 [ 0 0 0 0 1 0 ] 4 [ 0 0 0 1 0 0 ] 2 [ 0 1 0 0 0 0 ] 6 [ 0 0 0
       0 0 1 ] 5 [ 0 0 0 0 1 0 ] 6 [ 0 0 0 0 0 1 ] 3 [ 0 0 1 0 0 0 ] \(\backslash\)n}
102     \textcolor{comment}{// The numbers 1, 4, 5, 4, ... are the entries in the stress tensor \(\backslash\)a sigma. In square brackets we see
       the derivatives of sigma with respect to all the dofs set previously}
103     \textcolor{comment}{// given in the order we defined them above. Meaning: The first entry in the square brackets
       corresponds to the 0-th dof set by}
104     \textcolor{comment}{// @code eps[0][0].diff(0,6); @endcode referring to the component (0,0) in the strain tensor \(\backslash\)a eps.}
105 
106     \textcolor{comment}{// Computing the derivatives for certain components of the resulting tangent modulus: \(\backslash\)n}
107     \textcolor{comment}{// We now access these lists of derivatives (output above in square brackets) for one component of the
       stress tensor \(\backslash\)a sigma at a time.}
108     \{
109         \textcolor{comment}{// Access the derivatives corresponding to the component (0,0) of the stress tensor \(\backslash\)a sigma}
110         \textcolor{keywordtype}{double} *derivs = &sigma[0][0].fastAccessDx(0);
111         \textcolor{comment}{// The following output will show us the same derivatives that we already saw above, just formatted
       differently \(\backslash\)n}
112         \textcolor{comment}{// output: d\_sigma[0][0]/d\_eps = 1 , 0 , 0 , 0 , 0 , 0 ,}
113         std::cout << \textcolor{stringliteral}{"d\_sigma[0][0]/d\_eps = "};
114         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<6; ++i)
115             std::cout << derivs[i] << \textcolor{stringliteral}{" , "};
116         std::cout << std::endl;
117     \}
118     \{
119         \textcolor{comment}{// Access the derivatives corresponding to the component (1,2) of the stress tensor \(\backslash\)a sigma}
120         \textcolor{keywordtype}{double} *derivs = &sigma[1][2].fastAccessDx(0);
121         \textcolor{comment}{// output: d\_sigma[1][2]/d\_eps = 0 , 0 , 0 , 0 , 0 , 1 ,}
122         std::cout << \textcolor{stringliteral}{"d\_sigma[1][2]/d\_eps = "};
123         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<6; ++i)
124             std::cout << derivs[i] << \textcolor{stringliteral}{" , "};
125         std::cout << std::endl;
126     \}
127 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+3@{sacado\+\_\+test\+\_\+3}}
\index{sacado\+\_\+test\+\_\+3@{sacado\+\_\+test\+\_\+3}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+3()}{sacado_test_3()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+3 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}{}\label{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}


Referenced by main().


\begin{DoxyCode}
132 \{
133     std::cout << \textcolor{stringliteral}{"Test 3:"} << std::endl;
134 
135     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim = 3;
136 
137     \textcolor{comment}{// Here we also define some constant, for instance the bulk modulus \(\backslash\)a kappa and the second Lamè
       parameter \(\backslash\)a mu.}
138     \textcolor{comment}{// We now also define one of our constants as fad\_double. By doing this we can use the normal
       multiplication (see below).}
139     \textcolor{keywordtype}{double} kappa\_param = 5;
140     \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} kappa (kappa\_param);
141     \textcolor{comment}{// The second constant remains as a double just to show the difference.}
142     \textcolor{keywordtype}{double} mu = 2;
143 
144     SymmetricTensor<2,dim, fad\_double> sigma, eps;
145 
146     \textcolor{comment}{// To simplify the access to the dofs we define a map that relate the components of our strain tensor
       to the dof-nbr}
147     std::map<unsigned int,std::pair<unsigned int,unsigned int>> std\_map\_indicies;
148 
149     \textcolor{comment}{// The point at which the derivative shall be computed: \(\backslash\)n}
150     \textcolor{comment}{// As mentioned previously, we will implement this example for 2D and 3D, hence we once have to set up
       a strain tensor}
151     \textcolor{comment}{// and the derivatives for 3D with 6 independent components ...}
152     \textcolor{keywordflow}{if}(dim==3)
153     \{
154         eps[0][0] = 1;
155         eps[1][1] = 2;
156         eps[2][2] = 3;
157         
158         eps[0][1] = 4;
159         eps[0][2] = 5;
160         eps[1][2] = 6;
161         
162         
163         eps[0][0].diff(0,6);
164         eps[0][1].diff(1,6);
165         eps[0][2].diff(2,6);
166         eps[1][1].diff(3,6);
167         eps[1][2].diff(4,6);
168         eps[2][2].diff(5,6);
169         
170         \textcolor{comment}{// By using the map and the following pairs, we have to set up the relation between strain
       components and dofs only once}
171         \textcolor{comment}{// and can use the map to access the entries of the list later, without possibly mixing up indices
       and creating errors.}
172         \textcolor{comment}{// Please don't be confused, but the dofs in the Wrapper are set up}
173         \textcolor{comment}{// in a different order that we showed earlier. Earlier: (0,0)-(1,1)-(2,2)-...; Now:
       (0,0)-(0,1)-(0,2)-...}
174         std::pair<unsigned int, unsigned int> tmp\_pair;
175         tmp\_pair.first=0; tmp\_pair.second=0;
176         std\_map\_indicies[0] = tmp\_pair;
177 
178         tmp\_pair.first=0; tmp\_pair.second=1;
179         std\_map\_indicies[1] = tmp\_pair;
180 
181         tmp\_pair.first=0; tmp\_pair.second=2;
182         std\_map\_indicies[2] = tmp\_pair;
183 
184         tmp\_pair.first=1; tmp\_pair.second=1;
185         std\_map\_indicies[3] = tmp\_pair;
186 
187         tmp\_pair.first=1; tmp\_pair.second=2;
188         std\_map\_indicies[4] = tmp\_pair;
189 
190         tmp\_pair.first=2; tmp\_pair.second=2;
191         std\_map\_indicies[5] = tmp\_pair;
192     \}
193     \textcolor{comment}{// ... and once for 2D with just 3 independent components.}
194     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(dim==2)
195     \{
196         eps[0][0] = 1;
197         eps[1][1] = 2;
198         
199         eps[0][1] = 4;
200 
201                 
202         eps[0][0].diff(0,3);
203         eps[0][1].diff(1,3);
204         eps[1][1].diff(2,3);
205         
206         std::pair<unsigned int, unsigned int> tmp\_pair;
207         tmp\_pair.first=0; tmp\_pair.second=0;
208         std\_map\_indicies[0] = tmp\_pair;
209         
210         tmp\_pair.first=0; tmp\_pair.second=1;
211         std\_map\_indicies[1] = tmp\_pair;
212         
213         tmp\_pair.first=1; tmp\_pair.second=1;
214         std\_map\_indicies[2] = tmp\_pair;        
215     \}
216     \textcolor{keywordflow}{else}
217     \{
218         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"only dim==2 or dim==3 allowed"});
219     \}
220 
221     \textcolor{comment}{// Instead of calling the *.diff(*) on the components one-by-one we could also use the following
       for-loop, so}
222     \textcolor{comment}{// we also use the map to set the dofs (as we will do in the Wrapper later).}
223     \textcolor{comment}{// @code}
224     \textcolor{comment}{// for ( unsigned int x=0; x<((dim==2)?3:6); ++x )}
225     \textcolor{comment}{// \{}
226     \textcolor{comment}{//  unsigned int i=std\_map\_indicies[x].first;}
227     \textcolor{comment}{//  unsigned int j=std\_map\_indicies[x].second;}
228     \textcolor{comment}{//  eps[i][j].diff(x,((dim==2)?3:6));}
229     \textcolor{comment}{// \}}
230     \textcolor{comment}{// @endcode}
231 
232     \textcolor{comment}{// For our slightly more complicated stress equation we need the unit and deviatoric tensors.}
233     \textcolor{comment}{// We can simply define them by writing the values of the already existing deal.ii functions into newly}
234     \textcolor{comment}{// defined SymmetricTensors build from fad\_doubles.}
235     SymmetricTensor<2,dim, fad\_double> stdTensor\_I (( unit\_symmetric\_tensor<dim,fad\_double>()) );
236     SymmetricTensor<4,dim, fad\_double> stdTensor\_Idev ( (deviator\_tensor<dim,fad\_double>()) );
237     
238     \textcolor{comment}{// With everything set and defined, we can compute our stress \(\backslash\)a sigma according to:}
239     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)sigma = \(\backslash\)kappa \(\backslash\)cdot trace(\(\backslash\)varepsilon) \(\backslash\)cdot \(\backslash\)boldsymbol\{I\} + 2 \(\backslash\)cdot \(\backslash\)mu \(\backslash\)cdot
       \(\backslash\)varepsilon^\{dev\} \(\backslash\)f]}
240     \textcolor{comment}{// Here you can see that we can directly multiply the constant and the tensors when kappa is also
       declared as fad\_double}
241     sigma = kappa * (trace(eps) *  stdTensor\_I);
242     \textcolor{comment}{// We didn't do the same for mu to once again emphasize the difference between constants as double and
       as fad\_double. \(\backslash\)n}
243     \textcolor{comment}{// The remaining code uses a normal double constant.}
244     SymmetricTensor<2,dim,fad\_double> tmp = deviator<dim,fad\_double>(symmetrize<dim,fad\_double>(eps)); tmp*
      =(mu*2);
245     sigma +=  tmp;
246     \textcolor{comment}{// The fairly cumbersome computation is caused by the way the operators are set up for tensors out of
       fad\_doubles.}
247     
248     std::cout << \textcolor{stringliteral}{"sigma="} << sigma << std::endl;
249 
250     \textcolor{comment}{// Now we want to actually build our tangent modulus called \(\backslash\)a C\_Sacado that contains all the
       derivatives and relates}
251     \textcolor{comment}{// the stress tensor with the strain tensor. \(\backslash\)n}
252     \textcolor{comment}{// The fourth-order tensor \(\backslash\)a C\_Sacado is our final goal, we don't have to compute anything that is
       related to Sacado with}
253     \textcolor{comment}{// this tensor, so we can finally return to our standard SymmetricTensor out of doubles. The latter is
       necessary to use}
254     \textcolor{comment}{// the tangent in the actual FE code.}
255     SymmetricTensor<4,dim> C\_Sacado;
256 
257     \textcolor{comment}{// As in Ex2 we access the components of the stress tensor one by one. In order to capture all of them
       we sum over the}
258     \textcolor{comment}{// components i and j of the stress tensor.}
259     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
260         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
261         \{
262             \textcolor{keywordtype}{double} *derivs = &sigma[i][j].fastAccessDx(0); \textcolor{comment}{// Access the derivatives of the (i,j)-th
       component of \(\backslash\)a sigma}
263 
264             \textcolor{comment}{// To visually ensure that every stress component has in fact all 6 derivatives for 3D or 3 for
       2D, we output the size:}
265             std::cout<<\textcolor{stringliteral}{"size: "}<<sigma[i][j].size()<<std::endl;
266 
267             \textcolor{comment}{// We loop over all the dofs. To be able to use this independent of the chosen dimension \(\backslash\)a
       dim, we use a ternary operator}
268             \textcolor{comment}{// to decide whether we have to loop over 6 derivatives or just 3.}
269             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0;x<((dim==2)?3:6);++x)
270             \{
271                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=std\_map\_indicies[x].first;
272                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=std\_map\_indicies[x].second;
273 
274                 \textcolor{keywordflow}{if}(k!=l)\textcolor{comment}{/*Compare to Voigt notation since only SymmetricTensor instead of Tensor*/}
275                 \{
276                     C\_Sacado[i][j][k][l] = 0.5*derivs[x];
277                     C\_Sacado[i][j][l][k] = 0.5*derivs[x];
278                 \}
279                 \textcolor{keywordflow}{else}
280                     C\_Sacado[i][j][k][l] = derivs[x];
281             \}            
282             
283         \}
284 
285     \textcolor{comment}{// After resembling the fourth-order tensor, we now have got our tangent saved in \(\backslash\)a C\_Sacado ready to
       be used}
286 
287     \textcolor{comment}{// To ensure that Sacado works properly, we can compute the analytical tangent for comparison}
288     \textcolor{keywordtype}{double} kappa\_d = 5;
289     \textcolor{keywordtype}{double} mu\_d = 2;
290     \textcolor{comment}{// Our stress equation in this example is still simple enough to derive the tangent analytically by
       hand:}
291     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)overset\{4\}\{C\_\{analy\}\} = \(\backslash\)kappa \(\backslash\)cdot \(\backslash\)boldsymbol\{I\} \(\backslash\)otimes \(\backslash\)boldsymbol\{I\} + 2 \(\backslash\)cdot \(\backslash\)mu \(\backslash\)cdot
       \(\backslash\)overset\{4\}\{I^\{dev\}\} \(\backslash\)f]}
292     SymmetricTensor<4,dim> C\_analy = kappa\_d * outer\_product(unit\_symmetric\_tensor<dim>(), 
      unit\_symmetric\_tensor<dim>()) + 2* mu\_d * deviator\_tensor<dim>();
293 
294 
295     \textcolor{comment}{// We again define our strain tensor \(\backslash\)a eps\_d (*\_d for standard double in contrast to fad\_double)}
296     SymmetricTensor<2,dim> eps\_d;
297     
298     \textcolor{keywordflow}{if}(dim==3)
299     \{
300         eps\_d[0][0] = 1;
301         eps\_d[1][1] = 2;
302         eps\_d[2][2] = 3;
303         
304         eps\_d[0][1] = 4;
305         eps\_d[0][2] = 5;
306         eps\_d[2][1] = 6;
307 
308     \}
309     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(dim==2)
310     \{
311         eps\_d[0][0] = 1;
312         eps\_d[1][1] = 2;
313         
314         eps\_d[1][0] = 4;
315         
316     \}
317     \textcolor{keywordflow}{else}
318     \{
319         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"only dim==2 or dim==3 allowed"});
320     \}
321     \textcolor{comment}{// @todo use boldsymbol for tensors}
322     \textcolor{comment}{//}
323     \textcolor{comment}{// To output the stress tensor we first have to compute it. We do this here via}
324     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)sigma = \(\backslash\)overset\{4\}\{C\_\{analy\}\} : \(\backslash\)varepsilon \(\backslash\)f]}
325     \textcolor{comment}{// The output exactly matched the result obtained with Sacado.}
326     \textcolor{comment}{// @note Checking the Sacado stress tensor against an analytically computed or otherwise determined
       stress tensor is absolutely no way to check whether}
327     \textcolor{comment}{// the tangent computed via Sacado is correct. When we compute the stress tensor with Sacado and for
       example mix up a + and - sign, this might not matter}
328     \textcolor{comment}{// at all if the number that is added or subtracted is small. However, for the tangent this nasty sign
       can be very critical. Just keep in mind: the}
329     \textcolor{comment}{// tangent has 81 components and the stress tensor just 9, so how does one want to verify 81 variables
       by comparing 9?}
330     \textcolor{comment}{//}
331     std::cout << \textcolor{stringliteral}{"sigma\_analy: "} << (C\_analy*eps\_d) << std::endl;
332     
333     \textcolor{comment}{// That's the reason we compare all the entries in the Sacado and the analytical tensor one by one}
334     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
335         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
336             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
337                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
338                     std::cout << \textcolor{stringliteral}{"C\_analy["}<<i<<\textcolor{stringliteral}{"]["}<<j<<\textcolor{stringliteral}{"]["}<<k<<\textcolor{stringliteral}{"]["}<<l<<\textcolor{stringliteral}{"] = "} << C\_analy[i][j][k][l] <<
       \textcolor{stringliteral}{" vs C\_Sacado: "} << C\_Sacado[i][j][k][l] << std::endl;
339 
340 
341     \textcolor{comment}{// To simplify the comparison we compute a scalar error as the sum of the absolute differences of each
       component}
342     \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
343     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
344         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
345             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
346                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
347                     error\_Sacado\_vs\_analy += std::fabs(C\_Sacado[i][j][k][l] - C\_analy[i][j][k][l]);
348                     
349 
350     \textcolor{comment}{// As desired: The numerical error is zero (0 in double precision) and the tensor components are equal}
351     std::cout << \textcolor{stringliteral}{"numerical error: "} << error\_Sacado\_vs\_analy << std::endl;
352 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+3B@{sacado\+\_\+test\+\_\+3B}}
\index{sacado\+\_\+test\+\_\+3B@{sacado\+\_\+test\+\_\+3B}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+3\+B()}{sacado_test_3B()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+3B (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}{}\label{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}


References Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::get\+\_\+tangent(), Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::init(), and Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::set\+\_\+dofs().



Referenced by main().


\begin{DoxyCode}
357 \{
358     std::cout << \textcolor{stringliteral}{"Test 3B:"} << std::endl;
359     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
360 
361     \textcolor{comment}{// The following declarations are usually input arguments. So you receive the strain tensor and the
       constants out of doubles.}
362     SymmetricTensor<2,dim> eps\_d;
363     eps\_d[0][0] = 1;
364     eps\_d[1][1] = 2;
365     eps\_d[2][2] = 3;
366 
367     eps\_d[0][1] = 4;
368     eps\_d[0][2] = 5;
369     eps\_d[1][2] = 6;
370 
371     \textcolor{keywordtype}{double} kappa = 5;
372     \textcolor{keywordtype}{double} mu = 2;
373 
374     \textcolor{comment}{// Now we start working with Sacado: \(\backslash\)n}
375     \textcolor{comment}{// When we use the index notation to compute e.g. our stress we do not need to declare our constants
       (here kappa, mu) as}
376     \textcolor{comment}{// fad\_double.}
377 
378     \textcolor{comment}{// We declare our strain tensor as the special data type Sacado\_Wrapper::SymTensor from the file
       "Sacado\_Wrapper.h"}
379     \textcolor{comment}{// where this data type was derived from the SymmetricTensor<2,dim,fad\_double>.}
380      \hyperlink{classSacado__Wrapper_1_1SymTensor}{Sacado\_Wrapper::SymTensor<dim>} eps;
381 
382     \textcolor{comment}{// Next we initialize our Sacado strain tensor with the values of the inputed double strain tensor:}
383      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_acbad579d5ead9e96ff46aa15d9b5aef4}{init}(eps\_d);
384 
385     \textcolor{comment}{// We define all the entries in the symmetric tensor \(\backslash\)a eps as the dofs. So we can later derive any
       variable}
386     \textcolor{comment}{// with respect to the strain tensor \(\backslash\)a eps.}
387      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_aa9e0fcc9d4e0a4120bedb8ef9b8d7ecb}{set\_dofs}();
388 
389     \textcolor{comment}{// Now we declare our output and auxiliary variables as Sacado-Tensors.}
390      SymmetricTensor<2,dim,fad\_double> sigma;
391 
392      SymmetricTensor<2,dim, fad\_double> stdTensor\_I (( unit\_symmetric\_tensor<dim,fad\_double>()) );
393 
394      \textcolor{comment}{// Our stress equation is now computed in index notation to simplify the use of the constants and}
395      \textcolor{comment}{// especially the use of the \(\backslash\)a deviator.}
396       \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
397         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
398             sigma[i][j] = kappa * trace(eps) *  stdTensor\_I[i][j] + 2. * mu * deviator(eps)[i][j];
399 
400     \textcolor{comment}{// Finally we declare our desired tangent as the fourth order tensor \(\backslash\)a C\_Sacado and compute the
       tangent via}
401     \textcolor{comment}{// the command \(\backslash\)a get\_tangent.}
402      SymmetricTensor<4,dim> C\_Sacado;
403      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ab97427c3b5cab279e58607cf431ab262}{get\_tangent}(C\_Sacado, sigma);
404 
405     \textcolor{comment}{// We could again compare the herein computed tangent with the analytical tangent from Ex2, but as
       before}
406     \textcolor{comment}{// the results are fairly boring, because Sacado hits the analytical tangent exactly --- no surprise
       for such}
407     \textcolor{comment}{// simple equations.}
408 
409     \textcolor{comment}{// And that's it. By using the Sacado\_wrapper we can achieve everything from Ex2 (besides the
       equations)}
410     \textcolor{comment}{// with just four lines of code namely:}
411     \textcolor{comment}{// - eps.init(eps\_d);    // To initialize the Sacado strain tensor}
412     \textcolor{comment}{// - eps.set\_dofs();     // To declare the components of eps as the dofs}
413     \textcolor{comment}{// - eps.get\_tangent(*); // To get the tangent}
414 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+4@{sacado\+\_\+test\+\_\+4}}
\index{sacado\+\_\+test\+\_\+4@{sacado\+\_\+test\+\_\+4}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+4()}{sacado_test_4()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+4 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}{}\label{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}


References Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::get\+\_\+tangent(), Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double$<$ dim $>$\+::get\+\_\+tangent(), Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::init(), Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double$<$ dim $>$\+::init(), and Sacado\+\_\+\+Wrapper\+::\+Do\+Fs\+\_\+summary$<$ dim $>$\+::set\+\_\+dofs().



Referenced by main().


\begin{DoxyCode}
419 \{
420     std::cout << \textcolor{stringliteral}{"Test 4:"} << std::endl;
421     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
422 
423     \textcolor{comment}{// The following declarations are usually input arguments. So you receive the strain tensor \(\backslash\)q eps\_d,}
424     \textcolor{comment}{// the damage variable \(\backslash\)a phi and the constants \(\backslash\)a kappa and \(\backslash\)a mu out of doubles.}
425     SymmetricTensor<2,dim> eps\_d;
426     eps\_d[0][0] = 1;
427     eps\_d[1][1] = 2;
428     eps\_d[2][2] = 3;
429 
430     eps\_d[0][1] = 4;
431     eps\_d[0][2] = 5;
432     eps\_d[1][2] = 6;
433 
434     \textcolor{keywordtype}{double} phi\_d = 0.3;
435 
436     \textcolor{comment}{// We don't need these constants in the current example.}
437     \textcolor{comment}{// double kappa = 5;}
438     \textcolor{comment}{// double mu = 2;}
439 
440 
441     \textcolor{comment}{// We set up our strain tensor as in Ex3B.}
442      \hyperlink{classSacado__Wrapper_1_1SymTensor}{Sacado\_Wrapper::SymTensor<dim>} eps;
443      \hyperlink{classSacado__Wrapper_1_1SW__double}{Sacado\_Wrapper::SW\_double<dim>} phi;
444 
445     \textcolor{comment}{// Initialize the strain tensor and the damage variable}
446      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_acbad579d5ead9e96ff46aa15d9b5aef4}{init}(eps\_d);
447      phi.\hyperlink{classSacado__Wrapper_1_1SW__double_adca799dd92dadebda9aebc91c797682a}{init}(phi\_d);
448 
449      \textcolor{comment}{// Set the dofs, where the argument sets the total nbr of dofs (3 or 6 for the sym. tensor and 1 for
       the double)}
450 \textcolor{comment}{//    eps.set\_dofs(eps.n\_independent\_components+1/*an additional dof for phi*/);}
451 \textcolor{comment}{//}
452      \textcolor{comment}{// In order to also compute derivatives with respect to the scalar \(\backslash\)a phi, we add this scalar to our
       list}
453      \textcolor{comment}{// of derivatives. Because we have already defined 3 or 6 dofs our additional dof will be placed at
       the end}
454      \textcolor{comment}{// of this list. We set this up with the member variable start\_index ...}
455 \textcolor{comment}{//    phi.start\_index=eps.n\_independent\_components;}
456      \textcolor{comment}{// and again using the input argument representing the total number of dofs}
457 \textcolor{comment}{//    phi.set\_dofs(eps.n\_independent\_components+1);}
458 
459     \textcolor{comment}{// All of the above 3 lines of code are automatically done by the DoFs\_summary class. So, to}
460     \textcolor{comment}{// set our dofs we just create an instance and call set\_dofs with our variables containing the desired
       dofs.}
461      \hyperlink{classSacado__Wrapper_1_1DoFs__summary}{Sacado\_Wrapper::DoFs\_summary<dim>} DoFs\_summary;
462      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_a556293f6e683cb30151d9faadc2cc90d}{set\_dofs}(eps, phi);
463 
464 
465     \textcolor{comment}{// Compute the stress tensor and damage variable \(\backslash\)a d (here we just use some arbitrary equations for
       testing): \(\backslash\)n}
466      \textcolor{comment}{// Let us first declare our output (and auxiliary) variables as Sacado data types.}
467       SymmetricTensor<2,dim,fad\_double> sigma;
468       \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} d;
469      \textcolor{comment}{// @todo It would be nice to use the data types from the Sacado\_Wrapper for all the Sacado variables.
       But}
470      \textcolor{comment}{// somehow the operators (multiply*, ...) seem to cause conflicts again.}
471 
472      \textcolor{comment}{// The actual computation in the following scope uses the exact same equation as your normal
       computation e. g. via the data type double.}
473      \textcolor{comment}{// Hence, you could either directly compute your stress, etc. via the Sacado variables or you define}
474      \textcolor{comment}{// template functions that contain your equations and are either called templated with double or
       fad\_double.}
475      \textcolor{comment}{// When using the first option, please consider the computation time that is generally higher for a
       computation}
476      \textcolor{comment}{// with fad\_double than with normal doubles (own experience in a special case: slower by factor 30).}
477      \textcolor{comment}{// The second option with templates does not suffer these issues.}
478       \{
479       \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
480         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
481             sigma[i][j] = phi * eps[i][j];
482              \textcolor{comment}{// ToDo: strangely when phi is a fad\_double then the multiplication phi * eps works directly
       without}
483              \textcolor{comment}{// having to use the index notation}
484       std::cout << \textcolor{stringliteral}{"sigma="} << sigma << std::endl;
485 
486       d = phi*phi + 25 + trace(eps);
487       std::cout << \textcolor{stringliteral}{"d="} << d << std::endl;
488       \}
489 
490 
491     \textcolor{comment}{// Get the tangents}
492      \textcolor{comment}{// d\_sigma / d\_eps: SymmetricTensor with respect to SymmetricTensor}
493       SymmetricTensor<4,dim> C\_Sacado;
494       eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ab97427c3b5cab279e58607cf431ab262}{get\_tangent}(C\_Sacado, sigma);
495       std::cout << \textcolor{stringliteral}{"C\_Sacado="} << C\_Sacado << std::endl;
496 
497      \textcolor{comment}{// Compute the analytical tangent:}
498       SymmetricTensor<4,dim> C\_analy;
499       C\_analy = phi\_d * identity\_tensor<dim>();
500       std::cout << \textcolor{stringliteral}{"C\_analy ="} << C\_analy << std::endl;
501 
502      \textcolor{comment}{// d\_d / d\_eps: double with respect to SymmetricTensor}
503       SymmetricTensor<2,dim> d\_d\_d\_eps;
504       eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ab97427c3b5cab279e58607cf431ab262}{get\_tangent}(d\_d\_d\_eps, d);
505       std::cout << \textcolor{stringliteral}{"d\_d\_d\_eps="} << d\_d\_d\_eps << std::endl;
506 
507      \textcolor{comment}{// d\_sigma / d\_phi: SymmetricTensor with respect to double}
508       SymmetricTensor<2,dim> d\_sigma\_d\_phi;
509       phi.\hyperlink{classSacado__Wrapper_1_1SW__double_a2e6eca4457eb22b06172bb5749038f1e}{get\_tangent}(d\_sigma\_d\_phi, sigma);
510       std::cout << \textcolor{stringliteral}{"d\_sigma\_d\_phi="} << d\_sigma\_d\_phi << std::endl;
511       std::cout << \textcolor{stringliteral}{"sigma = d\_sigma\_d\_phi * phi = "} << d\_sigma\_d\_phi * phi\_d << std::endl;
512 
513      \textcolor{comment}{// d\_d / d\_phi: double with respect to double}
514       \textcolor{keywordtype}{double} d\_d\_d\_phi;
515       phi.\hyperlink{classSacado__Wrapper_1_1SW__double_a2e6eca4457eb22b06172bb5749038f1e}{get\_tangent}(d\_d\_d\_phi, d);
516       std::cout << \textcolor{stringliteral}{"d\_d\_d\_phi="} << d\_d\_d\_phi << std::endl;
517 
518     \textcolor{comment}{// And that's it. By using the Sacado\_wrapper we can compute derivatives with respect to}
519     \textcolor{comment}{// a tensor and a scalar at the same time (besides the equations)}
520     \textcolor{comment}{// in essence with just the following lines of code namely:}
521     \textcolor{comment}{// - eps.init(eps\_d); phi.init(phi\_d);   // To initialize the Sacado strain tensor and scalar damage
       variable}
522     \textcolor{comment}{// - DoFs\_summary.set\_dofs(eps, phi);    // To declare the components of eps and phi as the dofs}
523     \textcolor{comment}{// - eps.get\_tangent(*); // To get tangents with respect to eps}
524     \textcolor{comment}{// - phi.get\_tangent(*); // To get tangents with respect to phi}
525 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+5@{sacado\+\_\+test\+\_\+5}}
\index{sacado\+\_\+test\+\_\+5@{sacado\+\_\+test\+\_\+5}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+5()}{sacado_test_5()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+5 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}{}\label{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}


Referenced by main().


\begin{DoxyCode}
531 \{
532     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
533     std::cout << \textcolor{stringliteral}{"Test 5:"} << std::endl;
534     Tensor<1,dim,fad\_double> c;
535     \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} a,b;
536     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n\_dofs=2;
537     a = 1; b = 2;   \textcolor{comment}{// at the point (a,b) = (1,2)}
538     a.diff(0,2);  \textcolor{comment}{// Set a to be dof 0, in a 2-dof system.}
539     b.diff(1,2);  \textcolor{comment}{// Set b to be dof 1, in a 2-dof system.}
540     \textcolor{comment}{// c is now a vector with three components}
541     c[0] = 2*a+3*b;
542     c[1] = 4*a+5*b;
543     c[2] = 6*a+7*b;
544     
545     \textcolor{comment}{// Access to the derivatives works as before.}
546     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<dim;++i)
547     \{
548         \textcolor{keyword}{const} \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} &derivs = c[i]; \textcolor{comment}{// Access derivatives}
549         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0;j<n\_dofs;++j)
550         \{
551             std::cout << \textcolor{stringliteral}{"Derivatives at the point ("} << a << \textcolor{stringliteral}{","} << b << \textcolor{stringliteral}{") for "}
552             <<i<<\textcolor{stringliteral}{"th component wrt "}<<j<<\textcolor{stringliteral}{"th direction "}<< std::endl;
553             std::cout << \textcolor{stringliteral}{"dc\_i/dxj = "} << derivs.fastAccessDx(j) << std::endl;            
554         \}
555     \}
556 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+6@{sacado\+\_\+test\+\_\+6}}
\index{sacado\+\_\+test\+\_\+6@{sacado\+\_\+test\+\_\+6}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+6()}{sacado_test_6()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+6 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}{}\label{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}


Referenced by main().


\begin{DoxyCode}
564 \{
565     std::cout << \textcolor{stringliteral}{"Test 6:"} << std::endl;
566     \textcolor{comment}{// define the variables used in the computation (inputs: a, b; output: c; auxiliaries: *) as the
       Sacado-data type}
567      \textcolor{keywordtype}{double} a=1;
568      \textcolor{keywordtype}{double} b=2;
569 
570     \textcolor{comment}{// Number of independent variables}
571      \textcolor{keywordtype}{int} num\_dofs = 2;
572 
573     \textcolor{keyword}{typedef} Sacado::Fad::DFad<double> \hyperlink{Sacado__Wrapper_8h_a7e0893207b87dad05c66a34baac8ed2e}{DFadType};
574     Sacado::Fad::DFad<DFadType> afad(num\_dofs, 0, a);
575     Sacado::Fad::DFad<DFadType> bfad(num\_dofs, 1, b);
576     Sacado::Fad::DFad<DFadType> cfad;
577 
578     std::cout << \textcolor{stringliteral}{"afad="} << afad << std::endl;
579     std::cout << \textcolor{stringliteral}{"bfad="} << bfad << std::endl;
580     std::cout << \textcolor{stringliteral}{"cfad="} << cfad << std::endl;
581 
582     afad.val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(num\_dofs, 0, a); \textcolor{comment}{// set afad.val() as the first dof and init it with
       the double a}
583     bfad.val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(num\_dofs, 1, b);
584 
585     \textcolor{comment}{// Compute function and derivative with AD}
586      cfad = 2*afad + std::cos(afad*bfad);
587 
588         std::cout << \textcolor{stringliteral}{"afad="} << afad << std::endl;
589         std::cout << \textcolor{stringliteral}{"bfad="} << bfad << std::endl;
590         std::cout << \textcolor{stringliteral}{"cfad="} << cfad << std::endl;
591 
592     \textcolor{comment}{// Extract value and derivatives}
593     \textcolor{keywordtype}{double} c\_ad = cfad.val().val();       \textcolor{comment}{// r}
594     \textcolor{keywordtype}{double} dcda\_ad = cfad.dx(0).val();    \textcolor{comment}{// dr/da}
595     \textcolor{keywordtype}{double} dcdb\_ad = cfad.dx(1).val();    \textcolor{comment}{// dr/db}
596     \textcolor{keywordtype}{double} d2cda2\_ad = cfad.dx(0).dx(0);  \textcolor{comment}{// d^2r/da^2}
597     \textcolor{keywordtype}{double} d2cdadb\_ad = cfad.dx(0).dx(1); \textcolor{comment}{// d^2r/dadb}
598     \textcolor{keywordtype}{double} d2cdbda\_ad = cfad.dx(1).dx(0); \textcolor{comment}{// d^2r/dbda}
599     \textcolor{keywordtype}{double} d2cdb2\_ad = cfad.dx(1).dx(1);  \textcolor{comment}{// d^2/db^2}
600 
601 
602     std::cout << \textcolor{stringliteral}{"cfad="} << cfad << std::endl;
603     std::cout << \textcolor{stringliteral}{"c\_ad="} << c\_ad << std::endl;
604 
605     std::cout << \textcolor{stringliteral}{"Derivatives at the point ("} << a << \textcolor{stringliteral}{","} << b << \textcolor{stringliteral}{")"} << std::endl;
606     std::cout << \textcolor{stringliteral}{"dc/da = "} << dcda\_ad << \textcolor{stringliteral}{", dc/db="} << dcdb\_ad << std::endl;
607     std::cout << \textcolor{stringliteral}{"d²c/da² = "} << d2cda2\_ad << \textcolor{stringliteral}{", d²c/db²="} << d2cdb2\_ad << std::endl;
608     std::cout << \textcolor{stringliteral}{"d²c/dadb = "} << d2cdadb\_ad << \textcolor{stringliteral}{", d²c/dbda="} << d2cdbda\_ad << std::endl;
609 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+7@{sacado\+\_\+test\+\_\+7}}
\index{sacado\+\_\+test\+\_\+7@{sacado\+\_\+test\+\_\+7}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+7()}{sacado_test_7()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+7 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}{}\label{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}


Referenced by main().


\begin{DoxyCode}
616 \{
617     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
618 
619     std::cout << \textcolor{stringliteral}{"Test 7:"} << std::endl;
620 
621      SymmetricTensor<2,dim, double> eps;
622 
623      eps[0][0] = 1.;
624      eps[1][1] = 2.;
625      eps[2][2] = 3.;
626 
627      eps[0][1] = 4.;
628      eps[0][2] = 5.;
629      eps[1][2] = 6.;
630 
631 
632 
633     \textcolor{comment}{// Number of independent variables}
634      \textcolor{keywordtype}{int} nbr\_dofs = 6;
635 
636     \textcolor{keyword}{typedef} Sacado::Fad::DFad<double> \hyperlink{Sacado__Wrapper_8h_a7e0893207b87dad05c66a34baac8ed2e}{DFadType};
637      SymmetricTensor<2,dim, Sacado::Fad::DFad<DFadType> > eps\_fad;
638 
639 
640     (eps\_fad[0][0]).diff( 0, nbr\_dofs); \textcolor{comment}{// set up the "inner" derivatives}
641     (eps\_fad[0][0]).val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, 0, eps[0][0]); \textcolor{comment}{// set up the "outer" derivatives}
642 
643     (eps\_fad[1][1]).diff( 1, nbr\_dofs);
644     (eps\_fad[1][1]).val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, 1, eps[1][1]); \textcolor{comment}{// set up the "outer" derivatives}
645 
646     (eps\_fad[2][2]).diff( 2, nbr\_dofs);
647     (eps\_fad[2][2]).val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, 2, eps[2][2]); \textcolor{comment}{// set up the "outer" derivatives}
648 
649     (eps\_fad[0][1]).diff( 3, nbr\_dofs);
650     (eps\_fad[0][1]).val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, 3, eps[0][1]); \textcolor{comment}{// set up the "outer" derivatives}
651 
652     (eps\_fad[0][2]).diff( 4, nbr\_dofs);
653     (eps\_fad[0][2]).val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, 4, eps[0][2]); \textcolor{comment}{// set up the "outer" derivatives}
654 
655     (eps\_fad[1][2]).diff( 5, nbr\_dofs);
656     (eps\_fad[1][2]).val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, 5, eps[1][2]); \textcolor{comment}{// set up the "outer" derivatives}
657 
658     std::cout << eps\_fad << std::endl;
659 
660      SymmetricTensor<2,dim, Sacado::Fad::DFad<DFadType> > sigma;
661 
662 
663     \textcolor{comment}{// Compute function and derivative with AD}
664     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
665         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
666             sigma[i][j] = 25 * trace(eps\_fad)*trace(eps\_fad) + eps\_fad[i][j];
667 
668     std::cout << \textcolor{stringliteral}{"sigma="} << sigma << std::endl;
669 
670     \textcolor{keywordtype}{double} d\_sigma00\_d\_eps00 = sigma[0][0].dx(0).val();
671     \textcolor{keywordtype}{double} d2\_sigma00\_d\_eps00\_2 = sigma[0][0].dx(0).dx(0);
672     \textcolor{comment}{//double d2\_sigma00\_d\_eps11\_2 = sigma[0][0].dx(0).dx(1);}
673 
674     std::cout << \textcolor{stringliteral}{"d\_sigma00\_d\_eps00 = "} << d\_sigma00\_d\_eps00 << \textcolor{stringliteral}{", d2\_sigma00\_d\_eps00\_2 = "} << 
      d2\_sigma00\_d\_eps00\_2 << std::endl;
675 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+8@{sacado\+\_\+test\+\_\+8}}
\index{sacado\+\_\+test\+\_\+8@{sacado\+\_\+test\+\_\+8}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+8()}{sacado_test_8()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+8 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}{}\label{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}


Referenced by main().


\begin{DoxyCode}
681 \{
682     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
683 
684     std::cout << \textcolor{stringliteral}{"Test 8:"} << std::endl;
685 
686     \textcolor{comment}{// Defining the inputs (material parameters, strain tensor)}
687      \textcolor{keywordtype}{double} lambda=1;
688      \textcolor{keywordtype}{double} mu=2;
689      SymmetricTensor<2,dim, double> eps;
690      \textcolor{keywordtype}{double} phi=0.3;
691 
692      eps[0][0] = 1.;
693      eps[1][1] = 2.;
694      eps[2][2] = 3.;
695 
696      eps[0][1] = 4.;
697      eps[0][2] = 5.;
698      eps[1][2] = 6.;
699 
700     \textcolor{comment}{// Setup of the map relating the indices}
701      std::map<unsigned int,std::pair<unsigned int,unsigned int>> std\_map\_indicies;
702 
703      std::pair<unsigned int, unsigned int> tmp\_pair;
704      tmp\_pair.first=0; tmp\_pair.second=0;
705      std\_map\_indicies[0] = tmp\_pair;
706 
707      tmp\_pair.first=0; tmp\_pair.second=1;
708      std\_map\_indicies[1] = tmp\_pair;
709 
710      tmp\_pair.first=0; tmp\_pair.second=2;
711      std\_map\_indicies[2] = tmp\_pair;
712 
713      tmp\_pair.first=1; tmp\_pair.second=1;
714      std\_map\_indicies[3] = tmp\_pair;
715 
716      tmp\_pair.first=1; tmp\_pair.second=2;
717      std\_map\_indicies[4] = tmp\_pair;
718 
719      tmp\_pair.first=2; tmp\_pair.second=2;
720      std\_map\_indicies[5] = tmp\_pair;
721 
722     \textcolor{comment}{// Number of independent variables}
723      \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nbr\_dofs = 6+1;
724 
725     \textcolor{comment}{// Declaring the special data types containing all derivatives}
726      \textcolor{keyword}{typedef} Sacado::Fad::DFad<double> \hyperlink{Sacado__Wrapper_8h_a7e0893207b87dad05c66a34baac8ed2e}{DFadType};
727      SymmetricTensor<2,dim, Sacado::Fad::DFad<DFadType> > eps\_fad, eps\_fad\_squared;
728      Sacado::Fad::DFad<DFadType> phi\_fad;
729 
730 
731     \textcolor{comment}{// Setting the dofs}
732      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0; x<6; ++x )
733      \{
734         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=std\_map\_indicies[x].first;
735         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=std\_map\_indicies[x].second;
736         (eps\_fad[i][j]).diff( x, nbr\_dofs); \textcolor{comment}{// set up the "inner" derivatives}
737         (eps\_fad[i][j]).val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, x, eps[i][j]); \textcolor{comment}{// set up the "outer"
       derivatives}
738      \}
739 
740      phi\_fad.diff( 6, nbr\_dofs );
741      phi\_fad.val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, 6, phi); \textcolor{comment}{// set up the "outer" derivatives}
742 
743      std::cout << \textcolor{stringliteral}{"eps\_fad="} << eps\_fad << std::endl;
744      std::cout << \textcolor{stringliteral}{"phi\_fad="} << phi\_fad << std::endl;
745 
746     \textcolor{comment}{// Compute eps² = eps\_ij * eps\_jk in index notation}
747      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
748         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k )
749             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
750                 \textcolor{keywordflow}{if} ( i>=k )
751                     eps\_fad\_squared[i][k] += eps\_fad[i][j] * eps\_fad[j][k];
752 
753     \textcolor{comment}{// Compute the strain energy density}
754      Sacado::Fad::DFad<DFadType> energy;
755      energy = lambda/2. * trace(eps\_fad)*trace(eps\_fad) + mu * trace(eps\_fad\_squared) + 25 * phi\_fad * 
      trace(eps\_fad);
756 
757     \textcolor{comment}{// Give some insight into the storage of the values and derivatives}
758      std::cout << \textcolor{stringliteral}{"energy="} << energy << std::endl;
759 
760     \textcolor{comment}{// Compute sigma as \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\} \(\backslash\)f]}
761      SymmetricTensor<2,dim> sigma\_Sac;
762      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0; x<6; ++x )
763      \{
764         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=std\_map\_indicies[x].first;
765         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=std\_map\_indicies[x].second;
766         \textcolor{keywordflow}{if} ( i!=j )
767             sigma\_Sac[i][j] = 0.5 * energy.dx(x).val();
768         \textcolor{keywordflow}{else}
769             sigma\_Sac[i][j] = energy.dx(x).val();
770      \}
771      std::cout << \textcolor{stringliteral}{"sigma\_Sacado="} << sigma\_Sac << std::endl;
772 
773      \textcolor{keywordtype}{double} d\_energy\_d\_phi = energy.dx(6).val();
774      std::cout << \textcolor{stringliteral}{"d\_energy\_d\_phi="} << d\_energy\_d\_phi << std::endl;
775 
776     \textcolor{comment}{// Analytical stress tensor:}
777      SymmetricTensor<2,dim> sigma;
778      sigma = lambda*trace(eps)*unit\_symmetric\_tensor<dim>() + 2. * mu * eps;
779      std::cout << \textcolor{stringliteral}{"analy. sigma="} << sigma << std::endl;
780 
781 
782     \textcolor{comment}{// Sacado-Tangent}
783      SymmetricTensor<4,dim> C\_Sac;
784      \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0;x<6;++x)
785         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} y=0;y<6;++y)
786         \{
787             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=std\_map\_indicies[y].first;
788             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=std\_map\_indicies[y].second;
789             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=std\_map\_indicies[x].first;
790             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=std\_map\_indicies[x].second;
791 
792             \textcolor{keywordtype}{double} deriv = energy.dx(x).dx(y); \textcolor{comment}{// Access the derivatives of the (i,j)-th component of \(\backslash\)a
       sigma}
793 
794             \textcolor{keywordflow}{if} ( k!=l && i!=j )
795                 C\_Sac[i][j][k][l] = 0.25* deriv;
796             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(k!=l)\textcolor{comment}{/*Compare to Voigt notation since only SymmetricTensor instead of Tensor*/}
797             \{
798                 C\_Sac[i][j][k][l] = 0.5*deriv;
799                 C\_Sac[i][j][l][k] = 0.5*deriv;
800             \}
801             \textcolor{keywordflow}{else}
802                 C\_Sac[i][j][k][l] = deriv;
803         \}
804 
805      \textcolor{keywordtype}{double} d2\_energy\_d\_phi\_2 = energy.dx(6).dx(6);
806      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_phi\_2="} << d2\_energy\_d\_phi\_2 << std::endl;
807 
808      SymmetricTensor<2,dim> d2\_energy\_d\_eps\_d\_phi;
809 
810      SymmetricTensor<2,dim, Sacado::Fad::DFad<DFadType> > sigma\_Sac\_full;
811      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0; x<6; ++x )
812      \{
813         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=std\_map\_indicies[x].first;
814         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=std\_map\_indicies[x].second;
815         \textcolor{keywordflow}{if} ( i!=j )
816             sigma\_Sac\_full[i][j] = 0.5 * energy.dx(x);
817         \textcolor{keywordflow}{else}
818             sigma\_Sac\_full[i][j] = energy.dx(x);
819      \}
820 
821      std::cout << \textcolor{stringliteral}{"sigma\_Sac\_full="} << sigma\_Sac\_full << std::endl;
822      d2\_energy\_d\_eps\_d\_phi[0][0] = sigma\_Sac\_full[0][0].val().dx(6);
823      d2\_energy\_d\_eps\_d\_phi[1][1] = sigma\_Sac\_full[1][1].val().dx(6);
824      d2\_energy\_d\_eps\_d\_phi[2][2] = sigma\_Sac\_full[2][2].val().dx(6);
825      d2\_energy\_d\_eps\_d\_phi[0][1] = sigma\_Sac\_full[0][1].val().dx(6);
826      d2\_energy\_d\_eps\_d\_phi[0][2] = sigma\_Sac\_full[0][2].val().dx(6);
827      d2\_energy\_d\_eps\_d\_phi[1][2] = sigma\_Sac\_full[1][2].val().dx(6);
828 
829      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_eps\_d\_phi="} << d2\_energy\_d\_eps\_d\_phi << std::endl;
830 
831      SymmetricTensor<2,dim> d2\_energy\_d\_phi\_d\_eps;
832      d2\_energy\_d\_phi\_d\_eps[0][0] = energy.dx(6).dx(0);
833      d2\_energy\_d\_phi\_d\_eps[0][1] = energy.dx(6).dx(1);
834      d2\_energy\_d\_phi\_d\_eps[0][2] = energy.dx(6).dx(2);
835      d2\_energy\_d\_phi\_d\_eps[1][1] = energy.dx(6).dx(3);
836      d2\_energy\_d\_phi\_d\_eps[1][2] = energy.dx(6).dx(4);
837      d2\_energy\_d\_phi\_d\_eps[2][2] = energy.dx(6).dx(5);
838      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_phi\_d\_eps="} << d2\_energy\_d\_phi\_d\_eps << std::endl;
839 
840 
841     \textcolor{comment}{// Analytical tangent}
842      SymmetricTensor<4,dim> C\_analy;
843      C\_analy = lambda * outer\_product(unit\_symmetric\_tensor<dim>(), unit\_symmetric\_tensor<dim>()) + 2. * mu
       * identity\_tensor<dim>();
844 
845     \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
846     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
847         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
848             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
849                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
850                     error\_Sacado\_vs\_analy += std::fabs(C\_Sac[i][j][k][l] - C\_analy[i][j][k][l]);
851 
852     std::cout << \textcolor{stringliteral}{"Numerical error="} << error\_Sacado\_vs\_analy << std::endl;
853 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+9@{sacado\+\_\+test\+\_\+9}}
\index{sacado\+\_\+test\+\_\+9@{sacado\+\_\+test\+\_\+9}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+9()}{sacado_test_9()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+9 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_ae176f83fe1943e102fe325d4a14f097e}{}\label{Sacado__example_8cc_ae176f83fe1943e102fe325d4a14f097e}


References Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double2$<$ dim $>$\+::get\+\_\+curvature(), Sacado\+\_\+\+Wrapper\+::\+Do\+Fs\+\_\+summary$<$ dim $>$\+::get\+\_\+curvature(), Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double2$<$ dim $>$\+::get\+\_\+tangent(), and Sacado\+\_\+\+Wrapper\+::\+Do\+Fs\+\_\+summary$<$ dim $>$\+::init\+\_\+set\+\_\+dofs().



Referenced by main().


\begin{DoxyCode}
860 \{
861     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
862 
863     std::cout << \textcolor{stringliteral}{"Test 9:"} << std::endl;
864 
865     \textcolor{comment}{// Defining the inputs (material parameters, strain tensor)}
866      \textcolor{keywordtype}{double} lambda=1;
867      \textcolor{keywordtype}{double} mu=2;
868      SymmetricTensor<2,dim, double> eps;
869      \textcolor{keywordtype}{double} phi = 0.3;
870 
871      eps[0][0] = 1.;
872      eps[1][1] = 2.;
873      eps[2][2] = 3.;
874 
875      eps[0][1] = 4.;
876      eps[0][2] = 5.;
877      eps[1][2] = 6.;
878 
879     \textcolor{comment}{// Declaring the special data types containing all derivatives}
880      \textcolor{keyword}{typedef} Sacado::Fad::DFad<double> \hyperlink{Sacado__Wrapper_8h_a7e0893207b87dad05c66a34baac8ed2e}{DFadType};
881 
882     \textcolor{comment}{// Declare the variables \(\backslash\)a eps\_fad and \(\backslash\)a phi\_fad as the special Wrapper data types}
883      \hyperlink{classSacado__Wrapper_1_1SymTensor2}{Sacado\_Wrapper::SymTensor2<dim>} eps\_fad;
884      \hyperlink{classSacado__Wrapper_1_1SW__double2}{Sacado\_Wrapper::SW\_double2<dim>} phi\_fad;
885 
886     \textcolor{comment}{// Declare the summary data type relating all the dofs and initialising them too}
887      \hyperlink{classSacado__Wrapper_1_1DoFs__summary}{Sacado\_Wrapper::DoFs\_summary<dim>} DoFs\_summary;
888      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_ae273d0fa3197118a11d7005523e27d8a}{init\_set\_dofs}(eps\_fad, eps, phi\_fad, phi);
889 
890     \textcolor{comment}{// The variables are outputted to give some insight into the storage of the values (derivatives still
       trivial).}
891      std::cout << \textcolor{stringliteral}{"eps\_fad="} << eps\_fad << std::endl;
892      std::cout << \textcolor{stringliteral}{"phi\_fad="} << phi\_fad << std::endl;
893 
894     \textcolor{comment}{// Compute eps² = eps\_ij * eps\_jk in index notation}
895      SymmetricTensor<2,dim, Sacado::Fad::DFad<DFadType> > eps\_fad\_squared;
896      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
897         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k )
898             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
899                 \textcolor{keywordflow}{if} ( i>=k )
900                     eps\_fad\_squared[i][k] += eps\_fad[i][j] * eps\_fad[j][k];
901 
902     \textcolor{comment}{// Compute the strain energy density}
903      Sacado::Fad::DFad<DFadType> energy;
904      energy = lambda/2. * trace(eps\_fad)*trace(eps\_fad) + mu * trace(eps\_fad\_squared) + 25 * phi\_fad * 
      trace(eps\_fad);
905 
906     \textcolor{comment}{// The energy is outputted (formatted by hand) to give some insight into the storage of the values and
       derivatives. \(\backslash\)n}
907     \textcolor{comment}{// energy=399 [ 17.5 32 40 21.5 48 25.5 150 ] \(\backslash\)n}
908     \textcolor{comment}{//              [ 17.5 [ 5 0 0 1 0 1 25 ] 32 [ 0 8 0 0 0 0 0 ] 40 [ 0 0 8 0 0 0 0 ] \(\backslash\)n}
909     \textcolor{comment}{//              21.5 [ 1 0 0 5 0 1 25 ] 48 [ 0 0 0 0 8 0 0 ] 25.5 [ 1 0 0 1 0 5 25 ] \(\backslash\)n}
910     \textcolor{comment}{//              150 [ 25 0 0 25 0 25 0 ] ]}
911 
912      std::cout << \textcolor{stringliteral}{"energy="} << energy << std::endl;
913 
914     \textcolor{comment}{// Compute sigma as \(\backslash\)f[ \(\backslash\)boldsymbol\{\(\backslash\)sigma\} = \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\}
       \(\backslash\)f]}
915      SymmetricTensor<2,dim> sigma\_Sac;
916      eps\_fad.get\_tangent(sigma\_Sac, energy);
917      std::cout << \textcolor{stringliteral}{"sigma\_Sacado="} << sigma\_Sac << std::endl;
918 
919      \textcolor{keywordtype}{double} d\_energy\_d\_phi;
920      phi\_fad.\hyperlink{classSacado__Wrapper_1_1SW__double2_ad51ba1e79171d60861b28098dfef903d}{get\_tangent}(d\_energy\_d\_phi, energy);
921      std::cout << \textcolor{stringliteral}{"d\_energy\_d\_phi="} << d\_energy\_d\_phi << std::endl;
922 
923 
924     \textcolor{comment}{// Analytical stress tensor:}
925      SymmetricTensor<2,dim> sigma;
926      sigma = lambda*trace(eps)*unit\_symmetric\_tensor<dim>() + 2. * mu * eps;
927      std::cout << \textcolor{stringliteral}{"analy. sigma="} << sigma << std::endl;
928 
929 
930     \textcolor{comment}{// Sacado stress tangent (or eps curvature) as \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial
       \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}^2\} \(\backslash\)f]}
931      SymmetricTensor<4,dim> C\_Sac;
932      eps\_fad.get\_curvature(C\_Sac, energy);
933 
934     \textcolor{comment}{// Sacado phi curvature as \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)varphi^2\} \(\backslash\)f]}
935      \textcolor{keywordtype}{double} d2\_energy\_d\_phi\_2;
936      phi\_fad.\hyperlink{classSacado__Wrapper_1_1SW__double2_a7d3f3a21cd842645af9861bf50308825}{get\_curvature}(d2\_energy\_d\_phi\_2, energy);
937      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_phi\_2="} << d2\_energy\_d\_phi\_2 << std::endl;
938 
939     \textcolor{comment}{// Sacado derivatives \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\} \(\backslash\)partial \(\backslash\)varphi\}
       \(\backslash\)f]}
940      SymmetricTensor<2,dim> d2\_energy\_d\_eps\_d\_phi;
941      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_adf29bfda10814ecee9572a4751d34db0}{get\_curvature}(d2\_energy\_d\_eps\_d\_phi, energy, eps\_fad, phi\_fad);
942      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_eps\_d\_phi="} << d2\_energy\_d\_eps\_d\_phi << std::endl;
943 
944     \textcolor{comment}{// Sacado derivatives \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)varphi \(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\}
       \(\backslash\)f]}
945      SymmetricTensor<2,dim> d2\_energy\_d\_phi\_d\_eps;
946      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_adf29bfda10814ecee9572a4751d34db0}{get\_curvature}(d2\_energy\_d\_phi\_d\_eps, energy, phi\_fad, eps\_fad);
947      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_phi\_d\_eps="} << d2\_energy\_d\_phi\_d\_eps << std::endl;
948 
949     \textcolor{comment}{// When you consider the output: \(\backslash\)n}
950     \textcolor{comment}{// d2\_energy\_d\_eps\_d\_phi=25 0 0 0 25 0 0 0 25 \(\backslash\)n}
951     \textcolor{comment}{// d2\_energy\_d\_phi\_d\_eps=25 0 0 0 25 0 0 0 25 \(\backslash\)n}
952     \textcolor{comment}{// in detail you will notice that both second derivatives are identical. This compplies with the
       Schwarz integrability condition (Symmetry of second derivatives)}
953     \textcolor{comment}{// (ignoring all limitation and requirements), it holds}
954     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\} \(\backslash\)partial \(\backslash\)varphi\} = \(\backslash\)frac\{\(\backslash\)partial^2
       \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)varphi \(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\}  \(\backslash\)f]}
955 
956     \textcolor{comment}{// Analytical stress tangent}
957      SymmetricTensor<4,dim> C\_analy;
958      C\_analy = lambda * outer\_product(unit\_symmetric\_tensor<dim>(), unit\_symmetric\_tensor<dim>()) + 2. * mu
       * identity\_tensor<dim>();
959 
960     \textcolor{comment}{// Compute the error for the stress tangent}
961      \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
962      \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
963         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
964             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
965                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
966                     error\_Sacado\_vs\_analy += std::fabs(C\_Sac[i][j][k][l] - C\_analy[i][j][k][l]);
967      std::cout << \textcolor{stringliteral}{"Numerical error="} << error\_Sacado\_vs\_analy << std::endl;
968 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+scalar@{sacado\+\_\+test\+\_\+scalar}}
\index{sacado\+\_\+test\+\_\+scalar@{sacado\+\_\+test\+\_\+scalar}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+scalar()}{sacado_test_scalar()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+scalar (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}{}\label{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}


Referenced by main().


\begin{DoxyCode}
39 \{
40     std::cout << \textcolor{stringliteral}{"Scalar Test:"} << std::endl;
41     \textcolor{comment}{// define the variables used in the computation (inputs: a, b; output: c; auxiliaries: *) as the
       Sacado-data type}
42      \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} a,b,c;
43     \textcolor{comment}{// initialize the input variables a and b; This (a,b) = (1,2) will be the point where the derivatives
       are computed.}
44     \textcolor{comment}{// Compare: y=x² -> (dy/dx)(\(\backslash\)@x=1) = 2. We can only compute the derivative numerically at a certain
       point.}
45      a = 1;
46      b = 2;
47 
48     a.diff(0,2);  \textcolor{comment}{// Set a to be dof 0, in a 2-dof system.}
49     b.diff(1,2);  \textcolor{comment}{// Set b to be dof 1, in a 2-dof system.}
50     \textcolor{comment}{// Our equation here is very simply. But you can use nested equations and many standard mathematical
       operations, such as sqrt, pow, sin, ...}
51     c = 2*a + std::cos(a*b);
52     \textcolor{keywordtype}{double} *derivs = &c.fastAccessDx(0); \textcolor{comment}{// Access the derivatives of}
53     \textcolor{comment}{// Output the derivatives of c with respect to the two above defined degrees of freedom (dof)}
54     std::cout << \textcolor{stringliteral}{"Derivatives at the point ("} << a << \textcolor{stringliteral}{","} << b << \textcolor{stringliteral}{")"} << std::endl;
55     std::cout << \textcolor{stringliteral}{"dc/da = "} << derivs[0] << \textcolor{stringliteral}{", dc/db="} << derivs[1] << std::endl;
56 \}
\end{DoxyCode}
