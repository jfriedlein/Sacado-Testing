\hypertarget{Sacado__example_8cc}{}\section{Sacado\+\_\+example.\+cc File Reference}
\label{Sacado__example_8cc}\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
{\ttfamily \#include $<$deal.\+I\+I/base/symmetric\+\_\+tensor.\+h$>$}\newline
{\ttfamily \#include $<$iostream$>$}\newline
{\ttfamily \#include $<$fstream$>$}\newline
{\ttfamily \#include $<$cmath$>$}\newline
{\ttfamily \#include $<$deal.\+I\+I/base/timer.\+h$>$}\newline
{\ttfamily \#include $<$Sacado.\+hpp$>$}\newline
{\ttfamily \#include \char`\"{}Sacado\+\_\+\+Wrapper.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}Sacado-\/auxiliary\+\_\+functions.\+h\char`\"{}}\newline
Include dependency graph for Sacado\+\_\+example.\+cc\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{Sacado__example_8cc__incl}
\end{center}
\end{figure}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\+\_\+double} = Sacado\+::\+Fad\+::\+D\+Fad$<$ double $>$
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}{sacado\+\_\+test\+\_\+scalar} ()
\item 
void \hyperlink{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}{sacado\+\_\+test\+\_\+2} ()
\item 
void \hyperlink{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}{sacado\+\_\+test\+\_\+3} ()
\item 
void \hyperlink{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}{sacado\+\_\+test\+\_\+3B} ()
\item 
void \hyperlink{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}{sacado\+\_\+test\+\_\+4} ()
\item 
void \hyperlink{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}{sacado\+\_\+test\+\_\+5} ()
\item 
void \hyperlink{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}{sacado\+\_\+test\+\_\+6} ()
\item 
void \hyperlink{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}{sacado\+\_\+test\+\_\+7} ()
\item 
void \hyperlink{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}{sacado\+\_\+test\+\_\+8} ()
\item 
void \hyperlink{Sacado__example_8cc_ae176f83fe1943e102fe325d4a14f097e}{sacado\+\_\+test\+\_\+9} ()
\item 
{\footnotesize template$<$int dim, typename Number $>$ }\\Symmetric\+Tensor$<$ 2, dim, Number $>$ \hyperlink{Sacado__example_8cc_ae6e87a9cc06bd452cb5a1bfec2245569}{stress\+\_\+strain\+\_\+relation} (const Symmetric\+Tensor$<$ 2, dim, Number $>$ \&eps, const double \&kappa, const double \&mu)
\item 
void \hyperlink{Sacado__example_8cc_a70dbdff0078e09883ba02d2724a432b2}{sacado\+\_\+test\+\_\+10} ()
\item 
int \hyperlink{Sacado__example_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main} ()
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\mbox{\Hypertarget{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}\label{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!fad\+\_\+double@{fad\+\_\+double}}
\index{fad\+\_\+double@{fad\+\_\+double}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{fad\+\_\+double}{fad\_double}}
{\footnotesize\ttfamily using \hyperlink{Sacado-auxiliary__functions_8h_a868b94676739e612d9c95940e70892a9}{fad\+\_\+double} =  Sacado\+::\+Fad\+::\+D\+Fad$<$double$>$}



\subsection{Function Documentation}
\mbox{\Hypertarget{Sacado__example_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}\label{Sacado__example_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!main@{main}}
\index{main@{main}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{main()}{main()}}
{\footnotesize\ttfamily int main (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



References sacado\+\_\+test\+\_\+10(), sacado\+\_\+test\+\_\+2(), sacado\+\_\+test\+\_\+3(), sacado\+\_\+test\+\_\+3\+B(), sacado\+\_\+test\+\_\+4(), sacado\+\_\+test\+\_\+5(), sacado\+\_\+test\+\_\+6(), sacado\+\_\+test\+\_\+7(), sacado\+\_\+test\+\_\+8(), sacado\+\_\+test\+\_\+9(), and sacado\+\_\+test\+\_\+scalar().


\begin{DoxyCode}
1147 \{
1148     \hyperlink{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}{sacado\_test\_scalar} ();
1149 
1150     std::cout << std::endl;
1151 
1152     \hyperlink{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}{sacado\_test\_2} ();
1153 
1154     std::cout << std::endl;
1155 
1156     \hyperlink{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}{sacado\_test\_3} ();
1157 
1158     std::cout << std::endl;
1159 
1160     \hyperlink{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}{sacado\_test\_3B} ();
1161 
1162     std::cout << std::endl;
1163 
1164     \hyperlink{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}{sacado\_test\_4}();
1165 
1166     std::cout << std::endl;
1167 
1168     \hyperlink{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}{sacado\_test\_5}();
1169 
1170     std::cout << std::endl;
1171 
1172     \hyperlink{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}{sacado\_test\_6}();
1173 
1174     std::cout << std::endl;
1175 
1176     \hyperlink{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}{sacado\_test\_7}();
1177 
1178     std::cout << std::endl;
1179 
1180     \hyperlink{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}{sacado\_test\_8}();
1181 
1182     std::cout << std::endl;
1183 
1184     \hyperlink{Sacado__example_8cc_ae176f83fe1943e102fe325d4a14f097e}{sacado\_test\_9}();
1185 
1186     std::cout << std::endl;
1187 
1188     \hyperlink{Sacado__example_8cc_a70dbdff0078e09883ba02d2724a432b2}{sacado\_test\_10}();
1189 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_a70dbdff0078e09883ba02d2724a432b2}\label{Sacado__example_8cc_a70dbdff0078e09883ba02d2724a432b2}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+10@{sacado\+\_\+test\+\_\+10}}
\index{sacado\+\_\+test\+\_\+10@{sacado\+\_\+test\+\_\+10}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+10()}{sacado\_test\_10()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+10 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



References Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::get\+\_\+tangent(), Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::init(), Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::set\+\_\+dofs(), and stress\+\_\+strain\+\_\+relation().



Referenced by main().


\begin{DoxyCode}
1074 \{
1075     std::cout << \textcolor{stringliteral}{"Test 10:"} << std::endl;
1076     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
1077     \textcolor{comment}{// To measure the computation time of certain sections (see below)}
1078     TimerOutput timer (std::cout, TimerOutput::summary, TimerOutput::cpu\_times);
1079 
1080     \textcolor{comment}{// The following declarations are usually input arguments. So you receive the strain tensor and the
       constants out of doubles.}
1081     SymmetricTensor<2,dim> eps\_d;
1082     eps\_d[0][0] = 1;
1083     eps\_d[1][1] = 2;
1084     eps\_d[2][2] = 3;
1085 
1086     eps\_d[0][1] = 4;
1087     eps\_d[0][2] = 5;
1088     eps\_d[1][2] = 6;
1089 
1090     \textcolor{keywordtype}{double} kappa = 5;
1091     \textcolor{keywordtype}{double} mu = 2;
1092 
1093     \textcolor{comment}{// Now we start working with Sacado: \(\backslash\)n}
1094     \textcolor{comment}{// When we use the index notation to compute e.g. our stress we do not need to declare our constants
       (here kappa, mu) as}
1095     \textcolor{comment}{// fad\_double.}
1096 
1097     \textcolor{comment}{// We declare our strain tensor as the special data type Sacado\_Wrapper::SymTensor from the file
       "Sacado\_Wrapper.h"}
1098     \textcolor{comment}{// where this data type was derived from the SymmetricTensor<2,dim,fad\_double>.}
1099      \hyperlink{classSacado__Wrapper_1_1SymTensor}{Sacado\_Wrapper::SymTensor<dim>} eps;
1100 
1101     \textcolor{comment}{// Next we initialize our Sacado strain tensor with the values of the inputed double strain tensor:}
1102      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_acbad579d5ead9e96ff46aa15d9b5aef4}{init}(eps\_d);
1103 
1104     \textcolor{comment}{// We define all the entries in the symmetric tensor \(\backslash\)a eps as the dofs. So we can later derive any
       variable}
1105     \textcolor{comment}{// with respect to the strain tensor \(\backslash\)a eps.}
1106     \textcolor{comment}{// @note Keep the order first declare \(\backslash\)a eps, then initialise it and afterwards set it as dofs}
1107 
1108      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_aa9e0fcc9d4e0a4120bedb8ef9b8d7ecb}{set\_dofs}();
1109 
1110     \textcolor{comment}{// Now we call the templated function via the Sacado data types to get the resulting stress tensor \(\backslash\)a
       sigma. \(\backslash\)n}
1111     \textcolor{comment}{// To give you an impression of how much longer computations with the Sacado data type take,}
1112     \textcolor{comment}{// we also measure the time needed for the computation}
1113      timer.enter\_subsection(\textcolor{stringliteral}{"Stress via fad\_double"});
1114        SymmetricTensor<2,dim,fad\_double> sigma = \hyperlink{Sacado__example_8cc_ae6e87a9cc06bd452cb5a1bfec2245569}{stress\_strain\_relation} ( eps, kappa,
       mu );
1115      timer.leave\_subsection();
1116      std::cout << \textcolor{stringliteral}{"Stress via fad\_double:"} << extract\_value\_from\_Sacado<dim> (sigma) << std::endl;
1117 
1118     \textcolor{comment}{// Finally we declare our desired tangent as the fourth order tensor \(\backslash\)a C\_Sacado and compute the
       tangent via}
1119     \textcolor{comment}{// the command \(\backslash\)a get\_tangent.}
1120      SymmetricTensor<4,dim> C\_Sacado;
1121      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ab97427c3b5cab279e58607cf431ab262}{get\_tangent}(C\_Sacado, sigma);
1122 
1123     \textcolor{comment}{// For comparsion we can also compute the pure values of the stress tensor by calling}
1124     \textcolor{comment}{// the templated function with the normal data type \(\backslash\)a double.}
1125      timer.enter\_subsection(\textcolor{stringliteral}{"Stress via double"});
1126        SymmetricTensor<2,dim,double> sigma\_d = \hyperlink{Sacado__example_8cc_ae6e87a9cc06bd452cb5a1bfec2245569}{stress\_strain\_relation} ( eps\_d, kappa,
       mu );
1127      timer.leave\_subsection();
1128      std::cout << \textcolor{stringliteral}{"Stress via double:    "} << sigma\_d << std::endl;
1129 
1130     \textcolor{comment}{// As you can see from the times shown in the command window after you ran the code.}
1131     \textcolor{comment}{// The computation via the Sacado data types takes here around 4...6 times longer than}
1132     \textcolor{comment}{// using the standard type \(\backslash\)a double. However, you have to keep in mind that Sacado}
1133     \textcolor{comment}{// computes the tangent whilst computing the stress. Depending on how complicated and computationally
       demanding the}
1134     \textcolor{comment}{// analytical tangent is, Sacado can possibly compete.}
1135 
1136     \textcolor{comment}{// @note}
1137     \textcolor{comment}{// This also means that you should only use the Sacado data types when you are actually}
1138     \textcolor{comment}{// interested in the derivatives. Else the computation is just too expensive.}
1139 
1140 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}\label{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+2@{sacado\+\_\+test\+\_\+2}}
\index{sacado\+\_\+test\+\_\+2@{sacado\+\_\+test\+\_\+2}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+2()}{sacado\_test\_2()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+2 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Referenced by main().


\begin{DoxyCode}
73 \{
74     std::cout << \textcolor{stringliteral}{"Test 2:"} << std::endl;
75 
76     \textcolor{comment}{// First we set the dimension \(\backslash\)a dim: 2D->dim=2; 3D->dim=3 \(\backslash\)n This defines the "size" of the tensors
       and the number of dofs. \(\backslash\)ref Ex2 "Example 2" only works in 3D, whereas the following Ex3 is set up
       dimension-independent.}
77     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim = 3;
78 
79     \textcolor{comment}{// Declare our input, auxiliary and output variables as SymmetricTensors consisting of fad\_doubles
       (instead of the standard SymmetricTensor out of doubles)}
80     SymmetricTensor<2,dim, fad\_double> sigma, eps;
81 
82     \textcolor{comment}{// Init the strain tensor (the point at which the derivative shall be computed)}
83     eps[0][0] = 1;
84     eps[1][1] = 2;
85     eps[2][2] = 3;
86     eps[0][1] = 4;
87     eps[0][2] = 5;
88     eps[1][2] = 6;
89 
90     \textcolor{comment}{// Now we declare the dofs. The derivative to a tensor requires all components, therefore we set the
       components of the strain tensor here one by one as the dofs.}
91     \textcolor{comment}{// Because our tensors are symmetric, we only need 6 components in 3D instead of 9 for a full second
       order tensor}
92     eps[0][0].diff(0,6);
93     eps[1][1].diff(1,6);
94     eps[2][2].diff(2,6);
95     eps[0][1].diff(3,6);
96     eps[0][2].diff(4,6);
97     eps[1][2].diff(5,6);
98 
99     \textcolor{comment}{// The equation describing the stresses (here just a simple test case)}
100     sigma = eps;
101 
102     \textcolor{comment}{// Let's output the computed stress tensor.}
103     std::cout << sigma << std::endl;
104     \textcolor{comment}{// The resulting values of \(\backslash\)a sigma are fairly boring, due to our simple equation. It is the additional
       output generated by}
105     \textcolor{comment}{// this, that is interesting here: \(\backslash\)n}
106     \textcolor{comment}{// output: \(\backslash\)n}
107     \textcolor{comment}{// 1 [ 1 0 0 0 0 0 ] 4 [ 0 0 0 1 0 0 ] 5 [ 0 0 0 0 1 0 ] 4 [ 0 0 0 1 0 0 ] 2 [ 0 1 0 0 0 0 ] 6 [ 0 0 0
       0 0 1 ] 5 [ 0 0 0 0 1 0 ] 6 [ 0 0 0 0 0 1 ] 3 [ 0 0 1 0 0 0 ] \(\backslash\)n}
108     \textcolor{comment}{// The numbers 1, 4, 5, 4, ... are the entries in the stress tensor \(\backslash\)a sigma. In square brackets we see
       the derivatives of sigma with respect to all the dofs set previously}
109     \textcolor{comment}{// given in the order we defined them above. Meaning: The first entry in the square brackets
       corresponds to the 0-th dof set by}
110     \textcolor{comment}{// @code eps[0][0].diff(0,6); @endcode referring to the component (0,0) in the strain tensor \(\backslash\)a eps.}
111 
112     \textcolor{comment}{// Computing the derivatives for certain components of the resulting tangent modulus: \(\backslash\)n}
113     \textcolor{comment}{// We now access these lists of derivatives (output above in square brackets) for one component of the
       stress tensor \(\backslash\)a sigma at a time.}
114     \{
115         \textcolor{comment}{// Access the derivatives corresponding to the component (0,0) of the stress tensor \(\backslash\)a sigma}
116         \textcolor{keywordtype}{double} *derivs = &sigma[0][0].fastAccessDx(0);
117         \textcolor{comment}{// The following output will show us the same derivatives that we already saw above, just formatted
       differently \(\backslash\)n}
118         \textcolor{comment}{// output: d\_sigma[0][0]/d\_eps = 1 , 0 , 0 , 0 , 0 , 0 ,}
119         std::cout << \textcolor{stringliteral}{"d\_sigma[0][0]/d\_eps = "};
120         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<6; ++i)
121             std::cout << derivs[i] << \textcolor{stringliteral}{" , "};
122         std::cout << std::endl;
123     \}
124     \{
125         \textcolor{comment}{// Access the derivatives corresponding to the component (1,2) of the stress tensor \(\backslash\)a sigma}
126         \textcolor{keywordtype}{double} *derivs = &sigma[1][2].fastAccessDx(0);
127         \textcolor{comment}{// output: d\_sigma[1][2]/d\_eps = 0 , 0 , 0 , 0 , 0 , 1 ,}
128         std::cout << \textcolor{stringliteral}{"d\_sigma[1][2]/d\_eps = "};
129         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<6; ++i)
130             std::cout << derivs[i] << \textcolor{stringliteral}{" , "};
131         std::cout << std::endl;
132     \}
133 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}\label{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+3@{sacado\+\_\+test\+\_\+3}}
\index{sacado\+\_\+test\+\_\+3@{sacado\+\_\+test\+\_\+3}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+3()}{sacado\_test\_3()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+3 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Referenced by main().


\begin{DoxyCode}
138 \{
139     std::cout << \textcolor{stringliteral}{"Test 3:"} << std::endl;
140 
141     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim = 3;
142 
143     \textcolor{comment}{// Here we also define some constant, for instance the bulk modulus \(\backslash\)a kappa and the second Lamè
       parameter \(\backslash\)a mu.}
144     \textcolor{comment}{// We now also define one of our constants as fad\_double. By doing this we can use the normal
       multiplication (see below).}
145     \textcolor{keywordtype}{double} kappa\_param = 5;
146     \hyperlink{Sacado-auxiliary__functions_8h_a868b94676739e612d9c95940e70892a9}{fad\_double} kappa (kappa\_param);
147     \textcolor{comment}{// The second constant remains as a double just to show the difference.}
148     \textcolor{keywordtype}{double} mu = 2;
149 
150     SymmetricTensor<2,dim, fad\_double> sigma, eps;
151 
152     \textcolor{comment}{// To simplify the access to the dofs we define a map that relate the components of our strain tensor
       to the dof-nbr}
153     std::map<unsigned int,std::pair<unsigned int,unsigned int>> std\_map\_indicies;
154 
155     \textcolor{comment}{// The point at which the derivative shall be computed: \(\backslash\)n}
156     \textcolor{comment}{// As mentioned previously, we will implement this example for 2D and 3D, hence we once have to set up
       a strain tensor}
157     \textcolor{comment}{// and the derivatives for 3D with 6 independent components ...}
158     \textcolor{keywordflow}{if}(dim==3)
159     \{
160         eps[0][0] = 1;
161         eps[1][1] = 2;
162         eps[2][2] = 3;
163         
164         eps[0][1] = 4;
165         eps[0][2] = 5;
166         eps[1][2] = 6;
167         
168         
169         eps[0][0].diff(0,6);
170         eps[0][1].diff(1,6);
171         eps[0][2].diff(2,6);
172         eps[1][1].diff(3,6);
173         eps[1][2].diff(4,6);
174         eps[2][2].diff(5,6);
175         
176         \textcolor{comment}{// By using the map and the following pairs, we have to set up the relation between strain
       components and dofs only once}
177         \textcolor{comment}{// and can use the map to access the entries of the list later, without possibly mixing up indices
       and creating errors.}
178         \textcolor{comment}{// Please don't be confused, but the dofs in the Wrapper are set up}
179         \textcolor{comment}{// in a different order that we showed earlier. Earlier: (0,0)-(1,1)-(2,2)-...; Now:
       (0,0)-(0,1)-(0,2)-...}
180         std::pair<unsigned int, unsigned int> tmp\_pair;
181         tmp\_pair.first=0; tmp\_pair.second=0;
182         std\_map\_indicies[0] = tmp\_pair;
183 
184         tmp\_pair.first=0; tmp\_pair.second=1;
185         std\_map\_indicies[1] = tmp\_pair;
186 
187         tmp\_pair.first=0; tmp\_pair.second=2;
188         std\_map\_indicies[2] = tmp\_pair;
189 
190         tmp\_pair.first=1; tmp\_pair.second=1;
191         std\_map\_indicies[3] = tmp\_pair;
192 
193         tmp\_pair.first=1; tmp\_pair.second=2;
194         std\_map\_indicies[4] = tmp\_pair;
195 
196         tmp\_pair.first=2; tmp\_pair.second=2;
197         std\_map\_indicies[5] = tmp\_pair;
198     \}
199     \textcolor{comment}{// ... and once for 2D with just 3 independent components.}
200     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(dim==2)
201     \{
202         eps[0][0] = 1;
203         eps[1][1] = 2;
204         
205         eps[0][1] = 4;
206 
207                 
208         eps[0][0].diff(0,3);
209         eps[0][1].diff(1,3);
210         eps[1][1].diff(2,3);
211         
212         std::pair<unsigned int, unsigned int> tmp\_pair;
213         tmp\_pair.first=0; tmp\_pair.second=0;
214         std\_map\_indicies[0] = tmp\_pair;
215         
216         tmp\_pair.first=0; tmp\_pair.second=1;
217         std\_map\_indicies[1] = tmp\_pair;
218         
219         tmp\_pair.first=1; tmp\_pair.second=1;
220         std\_map\_indicies[2] = tmp\_pair;        
221     \}
222     \textcolor{keywordflow}{else}
223     \{
224         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"only dim==2 or dim==3 allowed"});
225     \}
226 
227     \textcolor{comment}{// Instead of calling the *.diff(*) on the components one-by-one we could also use the following
       for-loop, so}
228     \textcolor{comment}{// we also use the map to set the dofs (as we will do in the Wrapper later).}
229     \textcolor{comment}{// @code}
230     \textcolor{comment}{// for ( unsigned int x=0; x<((dim==2)?3:6); ++x )}
231     \textcolor{comment}{// \{}
232     \textcolor{comment}{//  unsigned int i=std\_map\_indicies[x].first;}
233     \textcolor{comment}{//  unsigned int j=std\_map\_indicies[x].second;}
234     \textcolor{comment}{//  eps[i][j].diff(x,((dim==2)?3:6));}
235     \textcolor{comment}{// \}}
236     \textcolor{comment}{// @endcode}
237 
238     \textcolor{comment}{// For our slightly more complicated stress equation we need the unit and deviatoric tensors.}
239     \textcolor{comment}{// We can simply define them by writing the values of the already existing deal.ii functions into newly}
240     \textcolor{comment}{// defined SymmetricTensors build from fad\_doubles.}
241     SymmetricTensor<2,dim, fad\_double> stdTensor\_I (( unit\_symmetric\_tensor<dim,fad\_double>()) );
242     SymmetricTensor<4,dim, fad\_double> stdTensor\_Idev ( (deviator\_tensor<dim,fad\_double>()) );
243     
244     \textcolor{comment}{// With everything set and defined, we can compute our stress \(\backslash\)a sigma according to:}
245     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)sigma = \(\backslash\)kappa \(\backslash\)cdot trace(\(\backslash\)varepsilon) \(\backslash\)cdot \(\backslash\)boldsymbol\{I\} + 2 \(\backslash\)cdot \(\backslash\)mu \(\backslash\)cdot
       \(\backslash\)varepsilon^\{dev\} \(\backslash\)f]}
246     \textcolor{comment}{// Here you can see that we can directly multiply the constant and the tensors when kappa is also
       declared as fad\_double}
247     sigma = kappa * (trace(eps) *  stdTensor\_I);
248     \textcolor{comment}{// We didn't do the same for mu to once again emphasize the difference between constants as double and
       as fad\_double. \(\backslash\)n}
249     \textcolor{comment}{// The remaining code uses a normal double constant.}
250     SymmetricTensor<2,dim,fad\_double> tmp = deviator<dim,fad\_double>(symmetrize<dim,fad\_double>(eps)); tmp*
      =(mu*2);
251     sigma +=  tmp;
252     \textcolor{comment}{// The fairly cumbersome computation is caused by the way the operators are set up for tensors out of
       fad\_doubles.}
253     
254     std::cout << \textcolor{stringliteral}{"sigma="} << sigma << std::endl;
255 
256     \textcolor{comment}{// Now we want to actually build our tangent modulus called \(\backslash\)a C\_Sacado that contains all the
       derivatives and relates}
257     \textcolor{comment}{// the stress tensor with the strain tensor. \(\backslash\)n}
258     \textcolor{comment}{// The fourth-order tensor \(\backslash\)a C\_Sacado is our final goal, we don't have to compute anything that is
       related to Sacado with}
259     \textcolor{comment}{// this tensor, so we can finally return to our standard SymmetricTensor out of doubles. The latter is
       necessary to use}
260     \textcolor{comment}{// the tangent in the actual FE code.}
261     SymmetricTensor<4,dim> C\_Sacado;
262 
263     \textcolor{comment}{// As in \(\backslash\)ref Ex2 "example 2" we access the components of the stress tensor one by one. In order to
       capture all of them we loop over the}
264     \textcolor{comment}{// components i and j of the stress tensor.}
265     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
266         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
267         \{
268             \textcolor{keywordtype}{double} *derivs = &sigma[i][j].fastAccessDx(0); \textcolor{comment}{// Access the derivatives of the (i,j)-th
       component of \(\backslash\)a sigma}
269 
270             \textcolor{comment}{// To visually ensure that every stress component has in fact all 6 derivatives for 3D or 3 for
       2D, we output the size:}
271             std::cout<<\textcolor{stringliteral}{"size: "}<<sigma[i][j].size()<<std::endl;
272 
273             \textcolor{comment}{// We loop over all the dofs. To be able to use this independent of the chosen dimension \(\backslash\)a
       dim, we use a ternary operator}
274             \textcolor{comment}{// to decide whether we have to loop over 6 derivatives or just 3.}
275             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0;x<((dim==2)?3:6);++x)
276             \{
277                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=std\_map\_indicies[x].first;
278                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=std\_map\_indicies[x].second;
279 
280                 \textcolor{keywordflow}{if}(k!=l)\textcolor{comment}{/*Compare to Voigt notation since only SymmetricTensor instead of Tensor*/}
281                 \{
282                     C\_Sacado[i][j][k][l] = 0.5*derivs[x];
283                     C\_Sacado[i][j][l][k] = 0.5*derivs[x];
284                 \}
285                 \textcolor{keywordflow}{else}
286                     C\_Sacado[i][j][k][l] = derivs[x];
287             \}            
288             
289         \}
290 
291     \textcolor{comment}{// After resembling the fourth-order tensor, we now have got our tangent saved in \(\backslash\)a C\_Sacado ready to
       be used}
292 
293     \textcolor{comment}{// To ensure that Sacado works properly, we can compute the analytical tangent for comparison}
294     \textcolor{keywordtype}{double} kappa\_d = 5;
295     \textcolor{keywordtype}{double} mu\_d = 2;
296     \textcolor{comment}{// Our stress equation in this example is still simple enough to derive the tangent analytically by
       hand:}
297     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)overset\{4\}\{C\_\{analy\}\} = \(\backslash\)kappa \(\backslash\)cdot \(\backslash\)boldsymbol\{I\} \(\backslash\)otimes \(\backslash\)boldsymbol\{I\} + 2 \(\backslash\)cdot \(\backslash\)mu \(\backslash\)cdot
       \(\backslash\)overset\{4\}\{I^\{dev\}\} \(\backslash\)f]}
298     SymmetricTensor<4,dim> C\_analy = kappa\_d * outer\_product(unit\_symmetric\_tensor<dim>(), 
      unit\_symmetric\_tensor<dim>()) + 2* mu\_d * deviator\_tensor<dim>();
299 
300 
301     \textcolor{comment}{// We again define our strain tensor \(\backslash\)a eps\_d (*\_d for standard double in contrast to fad\_double)}
302     SymmetricTensor<2,dim> eps\_d;
303     
304     \textcolor{keywordflow}{if}(dim==3)
305     \{
306         eps\_d[0][0] = 1;
307         eps\_d[1][1] = 2;
308         eps\_d[2][2] = 3;
309         
310         eps\_d[0][1] = 4;
311         eps\_d[0][2] = 5;
312         eps\_d[2][1] = 6;
313 
314     \}
315     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(dim==2)
316     \{
317         eps\_d[0][0] = 1;
318         eps\_d[1][1] = 2;
319         
320         eps\_d[1][0] = 4;
321         
322     \}
323     \textcolor{keywordflow}{else}
324     \{
325         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"only dim==2 or dim==3 allowed"});
326     \}
327     \textcolor{comment}{// @todo use boldsymbol for tensors}
328 
329     \textcolor{comment}{// To output the stress tensor we first have to compute it. We do this here via}
330     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)sigma = \(\backslash\)overset\{4\}\{C\_\{analy\}\} : \(\backslash\)varepsilon \(\backslash\)f]}
331     \textcolor{comment}{// The output exactly matched the result obtained with Sacado.}
332     \textcolor{comment}{// @note Checking the Sacado stress tensor against an analytically computed or otherwise determined
       stress tensor is absolutely no way to check whether}
333     \textcolor{comment}{// the tangent computed via Sacado is correct. When we compute the stress tensor with Sacado and for
       example mix up a + and - sign, this might not matter}
334     \textcolor{comment}{// at all if the number that is added or subtracted is small. However, for the tangent this nasty sign
       can be very critical. Just keep in mind: the}
335     \textcolor{comment}{// tangent has 81 components and the stress tensor just 9, so how does one want to verify 81 variables
       by comparing 9?}
336 
337     std::cout << \textcolor{stringliteral}{"sigma\_analy: "} << (C\_analy*eps\_d) << std::endl;
338     
339     \textcolor{comment}{// That's the reason we compare all the entries in the Sacado and the analytical tensor one by one}
340     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
341         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
342             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
343                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
344                     std::cout << \textcolor{stringliteral}{"C\_analy["}<<i<<\textcolor{stringliteral}{"]["}<<j<<\textcolor{stringliteral}{"]["}<<k<<\textcolor{stringliteral}{"]["}<<l<<\textcolor{stringliteral}{"] = "} << C\_analy[i][j][k][l] <<
       \textcolor{stringliteral}{" vs C\_Sacado: "} << C\_Sacado[i][j][k][l] << std::endl;
345 
346 
347     \textcolor{comment}{// To simplify the comparison we compute a scalar error as the sum of the absolute differences of each
       component}
348     \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
349     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
350         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
351             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
352                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
353                     error\_Sacado\_vs\_analy += std::fabs(C\_Sacado[i][j][k][l] - C\_analy[i][j][k][l]);
354                     
355 
356     \textcolor{comment}{// As desired: The numerical error is zero (0 in double precision) and the tensor components are equal}
357     std::cout << \textcolor{stringliteral}{"numerical error: "} << error\_Sacado\_vs\_analy << std::endl;
358 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}\label{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+3B@{sacado\+\_\+test\+\_\+3B}}
\index{sacado\+\_\+test\+\_\+3B@{sacado\+\_\+test\+\_\+3B}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+3\+B()}{sacado\_test\_3B()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+3B (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



References Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::get\+\_\+tangent(), Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::init(), and Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::set\+\_\+dofs().



Referenced by main().


\begin{DoxyCode}
363 \{
364     std::cout << \textcolor{stringliteral}{"Test 3B:"} << std::endl;
365     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
366 
367     \textcolor{comment}{// The following declarations are usually input arguments. So you receive the strain tensor and the
       constants out of doubles.}
368     SymmetricTensor<2,dim> eps\_d;
369     eps\_d[0][0] = 1;
370     eps\_d[1][1] = 2;
371     eps\_d[2][2] = 3;
372 
373     eps\_d[0][1] = 4;
374     eps\_d[0][2] = 5;
375     eps\_d[1][2] = 6;
376 
377     \textcolor{keywordtype}{double} kappa = 5;
378     \textcolor{keywordtype}{double} mu = 2;
379 
380     \textcolor{comment}{// Now we start working with Sacado: \(\backslash\)n}
381     \textcolor{comment}{// When we use the index notation to compute e.g. our stress we do not need to declare our constants
       (here kappa, mu) as}
382     \textcolor{comment}{// fad\_double.}
383 
384     \textcolor{comment}{// We declare our strain tensor as the special data type Sacado\_Wrapper::SymTensor from the file
       "Sacado\_Wrapper.h"}
385     \textcolor{comment}{// where this data type was derived from the SymmetricTensor<2,dim,fad\_double>.}
386      \hyperlink{classSacado__Wrapper_1_1SymTensor}{Sacado\_Wrapper::SymTensor<dim>} eps;
387 
388     \textcolor{comment}{// Next we initialize our Sacado strain tensor with the values of the inputed double strain tensor:}
389      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_acbad579d5ead9e96ff46aa15d9b5aef4}{init}(eps\_d);
390 
391     \textcolor{comment}{// We define all the entries in the symmetric tensor \(\backslash\)a eps as the dofs. So we can later derive any
       variable}
392     \textcolor{comment}{// with respect to the strain tensor \(\backslash\)a eps.}
393     \textcolor{comment}{// @note Keep the order first declare \(\backslash\)a eps, then initialise it and afterwards set it as dofs}
394 
395      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_aa9e0fcc9d4e0a4120bedb8ef9b8d7ecb}{set\_dofs}();
396 
397     \textcolor{comment}{// Now we declare our output and auxiliary variables as Sacado-Tensors.}
398      SymmetricTensor<2,dim,fad\_double> sigma;
399 
400      SymmetricTensor<2,dim, fad\_double> stdTensor\_I (( unit\_symmetric\_tensor<dim,fad\_double>()) );
401 
402      \textcolor{comment}{// Our stress equation is now computed in index notation to simplify the use of the constants and}
403      \textcolor{comment}{// especially the use of the \(\backslash\)a deviator.}
404       \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
405         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
406             sigma[i][j] = kappa * trace(eps) *  stdTensor\_I[i][j] + 2. * mu * deviator(eps)[i][j];
407 
408     \textcolor{comment}{// Finally we declare our desired tangent as the fourth order tensor \(\backslash\)a C\_Sacado and compute the
       tangent via}
409     \textcolor{comment}{// the command \(\backslash\)a get\_tangent.}
410      SymmetricTensor<4,dim> C\_Sacado;
411      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ab97427c3b5cab279e58607cf431ab262}{get\_tangent}(C\_Sacado, sigma);
412 
413     \textcolor{comment}{// We could again compare the herein computed tangent with the analytical tangent from Ex2, but as
       before}
414     \textcolor{comment}{// the results are fairly boring, because Sacado hits the analytical tangent exactly --- no surprise
       for such}
415     \textcolor{comment}{// simple equations.}
416 
417     \textcolor{comment}{// And that's it. By using the Sacado\_wrapper we can achieve everything from Ex2 (besides the
       equations)}
418     \textcolor{comment}{// with just four lines of code namely:}
419     \textcolor{comment}{// - eps.init(eps\_d);    // To initialize the Sacado strain tensor}
420     \textcolor{comment}{// - eps.set\_dofs();     // To declare the components of eps as the dofs}
421     \textcolor{comment}{// - eps.get\_tangent(*); // To get the tangent}
422 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}\label{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+4@{sacado\+\_\+test\+\_\+4}}
\index{sacado\+\_\+test\+\_\+4@{sacado\+\_\+test\+\_\+4}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+4()}{sacado\_test\_4()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+4 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



References Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::get\+\_\+tangent(), Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double$<$ dim $>$\+::get\+\_\+tangent(), Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::init(), Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double$<$ dim $>$\+::init(), and Sacado\+\_\+\+Wrapper\+::\+Do\+Fs\+\_\+summary$<$ dim $>$\+::set\+\_\+dofs().



Referenced by main().


\begin{DoxyCode}
427 \{
428     std::cout << \textcolor{stringliteral}{"Test 4:"} << std::endl;
429     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
430 
431     \textcolor{comment}{// The following declarations are usually input arguments. So you receive the strain tensor \(\backslash\)q eps\_d,}
432     \textcolor{comment}{// the damage variable \(\backslash\)a phi and the constants \(\backslash\)a kappa and \(\backslash\)a mu out of doubles.}
433     SymmetricTensor<2,dim> eps\_d;
434     eps\_d[0][0] = 1;
435     eps\_d[1][1] = 2;
436     eps\_d[2][2] = 3;
437 
438     eps\_d[0][1] = 4;
439     eps\_d[0][2] = 5;
440     eps\_d[1][2] = 6;
441 
442     \textcolor{keywordtype}{double} phi\_d = 0.3;
443 
444     \textcolor{comment}{// We don't need these constants in the current example.}
445     \textcolor{comment}{// double kappa = 5;}
446     \textcolor{comment}{// double mu = 2;}
447 
448 
449     \textcolor{comment}{// We set up our strain tensor as in Ex3B.}
450      \hyperlink{classSacado__Wrapper_1_1SymTensor}{Sacado\_Wrapper::SymTensor<dim>} eps;
451      \hyperlink{classSacado__Wrapper_1_1SW__double}{Sacado\_Wrapper::SW\_double<dim>} phi;
452 
453     \textcolor{comment}{// Initialize the strain tensor and the damage variable}
454      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_acbad579d5ead9e96ff46aa15d9b5aef4}{init}(eps\_d);
455      phi.\hyperlink{classSacado__Wrapper_1_1SW__double_adca799dd92dadebda9aebc91c797682a}{init}(phi\_d);
456 
457      \textcolor{comment}{// Set the dofs, where the argument sets the total nbr of dofs (3 or 6 for the sym. tensor and 1 for
       the double)}
458 \textcolor{comment}{//    eps.set\_dofs(eps.n\_independent\_components+1/*an additional dof for phi*/);}
459 \textcolor{comment}{//}
460      \textcolor{comment}{// In order to also compute derivatives with respect to the scalar \(\backslash\)a phi, we add this scalar to our
       list}
461      \textcolor{comment}{// of derivatives. Because we have already defined 3 or 6 dofs our additional dof will be placed at
       the end}
462      \textcolor{comment}{// of this list. We set this up with the member variable start\_index ...}
463 \textcolor{comment}{//    phi.start\_index=eps.n\_independent\_components;}
464      \textcolor{comment}{// and again using the input argument representing the total number of dofs}
465 \textcolor{comment}{//    phi.set\_dofs(eps.n\_independent\_components+1);}
466 
467     \textcolor{comment}{// All of the above 3 lines of code are automatically done by the DoFs\_summary class. So, to}
468     \textcolor{comment}{// set our dofs we just create an instance and call set\_dofs with our variables containing the desired
       dofs.}
469      \hyperlink{classSacado__Wrapper_1_1DoFs__summary}{Sacado\_Wrapper::DoFs\_summary<dim>} DoFs\_summary;
470      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_a556293f6e683cb30151d9faadc2cc90d}{set\_dofs}(eps, phi);
471 
472 
473     \textcolor{comment}{// Compute the stress tensor and damage variable \(\backslash\)a d (here we just use some arbitrary equations for
       testing): \(\backslash\)n}
474      \textcolor{comment}{// Let us first declare our output (and auxiliary) variables as Sacado data types.}
475       SymmetricTensor<2,dim,fad\_double> sigma;
476       \hyperlink{Sacado-auxiliary__functions_8h_a868b94676739e612d9c95940e70892a9}{fad\_double} d;
477      \textcolor{comment}{// @todo It would be nice to use the data types from the Sacado\_Wrapper for all the Sacado variables.
       But}
478      \textcolor{comment}{// somehow the operators (multiply*, ...) seem to cause conflicts again.}
479 
480      \textcolor{comment}{// The actual computation in the following scope uses the exact same equation as your normal
       computation e. g. via the data type double.}
481      \textcolor{comment}{// Hence, you could either directly compute your stress, etc. via the Sacado variables or you define}
482      \textcolor{comment}{// template functions that contain your equations and are either called templated with double or
       fad\_double.}
483      \textcolor{comment}{// When using the first option, please consider the computation time that is generally higher for a
       computation}
484      \textcolor{comment}{// with fad\_double than with normal doubles (own experience in a special case: slower by factor 30).}
485      \textcolor{comment}{// The second option with templates does not suffer these issues.}
486       \{
487       d = phi*phi + 25 + trace(eps) + eps.norm();
488       std::cout << \textcolor{stringliteral}{"d="} << d << std::endl;
489 
490       \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
491         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
492             sigma[i][j] = phi * d * eps[i][j];
493              \textcolor{comment}{// ToDo: strangely when phi is a fad\_double then the multiplication phi * eps works directly
       without}
494              \textcolor{comment}{// having to use the index notation}
495       std::cout << \textcolor{stringliteral}{"sigma="} << sigma << std::endl << std::endl;
496       \}
497 
498 
499     \textcolor{comment}{// Get the tangents}
500      \textcolor{comment}{// d\_sigma / d\_eps: SymmetricTensor with respect to SymmetricTensor}
501       SymmetricTensor<4,dim> C\_Sacado;
502       eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ab97427c3b5cab279e58607cf431ab262}{get\_tangent}(C\_Sacado, sigma);
503       std::cout << \textcolor{stringliteral}{"C\_Sacado="} << C\_Sacado << std::endl;
504 
505      \textcolor{comment}{// Compute the analytical tangent:}
506       SymmetricTensor<4,dim> C\_analy;
507       C\_analy = ( std::pow(phi\_d, 3) + 25*phi\_d + phi\_d*trace(eps\_d) + phi\_d*eps\_d.norm() ) * 
      identity\_tensor<dim>()
508                 + phi\_d * outer\_product( eps\_d, unit\_symmetric\_tensor<dim>())
509                 + phi\_d * outer\_product( eps\_d, eps\_d ) * 1./eps\_d.norm();
510       \textcolor{comment}{// @note Be aware of the difference between \(\backslash\)f[ eps\_d \(\backslash\)otimes \(\backslash\)boldsymbol\{1\} \(\backslash\)text\{ and \}
       \(\backslash\)boldsymbol\{1\} \(\backslash\)otimes eps\_d \(\backslash\)f]}
511 
512       std::cout << \textcolor{stringliteral}{"C\_analy ="} << C\_analy << std::endl;
513 
514       \textcolor{comment}{// To simplify the comparison we compute a scalar error as the sum of the absolute differences of
       each component}
515        \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
516        \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
517             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
518                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
519                     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
520                         error\_Sacado\_vs\_analy += std::fabs(C\_Sacado[i][j][k][l] - C\_analy[i][j][k][l]);
521        std::cout << \textcolor{stringliteral}{"numerical error: "} << error\_Sacado\_vs\_analy << std::endl << std::endl;
522 
523      \textcolor{comment}{// d\_d / d\_eps: double with respect to SymmetricTensor}
524       SymmetricTensor<2,dim> d\_d\_d\_eps;
525       eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ab97427c3b5cab279e58607cf431ab262}{get\_tangent}(d\_d\_d\_eps, d);
526       std::cout << \textcolor{stringliteral}{"d\_d\_d\_eps      ="} << d\_d\_d\_eps << std::endl;
527       SymmetricTensor<2,dim> d\_d\_d\_eps\_analy;
528       d\_d\_d\_eps\_analy = unit\_symmetric\_tensor<dim>() + eps\_d / eps\_d.norm();
529       std::cout << \textcolor{stringliteral}{"d\_d\_d\_eps\_analy="} << d\_d\_d\_eps\_analy << std::endl << std::endl;
530 
531      \textcolor{comment}{// d\_sigma / d\_phi: SymmetricTensor with respect to double}
532       SymmetricTensor<2,dim> d\_sigma\_d\_phi;
533       phi.\hyperlink{classSacado__Wrapper_1_1SW__double_a2e6eca4457eb22b06172bb5749038f1e}{get\_tangent}(d\_sigma\_d\_phi, sigma);
534       std::cout << \textcolor{stringliteral}{"d\_sigma\_d\_phi      ="} << d\_sigma\_d\_phi << std::endl;
535       SymmetricTensor<2,dim> d\_sigma\_d\_phi\_analy;
536       d\_sigma\_d\_phi\_analy = ( phi\_d*phi\_d + 25 + trace(eps\_d) + eps\_d.norm() + 2 * phi\_d*phi\_d ) * eps\_d;
537       std::cout << \textcolor{stringliteral}{"d\_sigma\_d\_phi\_analy="} << d\_sigma\_d\_phi\_analy << std::endl << std::endl;
538 
539      \textcolor{comment}{// Retrieve the values stored in \(\backslash\)a sigma:}
540       SymmetricTensor<2,dim> sigma\_d;
541       \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
542             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
543                 sigma\_d[i][j] = sigma[i][j].val();
544       std::cout << \textcolor{stringliteral}{"sigma\_d = "} << sigma\_d << std::endl;
545 
546      \textcolor{comment}{// d\_d / d\_phi: double with respect to double}
547       \textcolor{keywordtype}{double} d\_d\_d\_phi;
548       phi.\hyperlink{classSacado__Wrapper_1_1SW__double_a2e6eca4457eb22b06172bb5749038f1e}{get\_tangent}(d\_d\_d\_phi, d);
549       std::cout << \textcolor{stringliteral}{"d\_d\_d\_phi="} << d\_d\_d\_phi << std::endl;
550 
551      \textcolor{comment}{// Retrieve the value stored in d}
552       \textcolor{keywordtype}{double} d\_double = d.val();
553 
554      \textcolor{comment}{// Taylor-series for point x}
555      \textcolor{comment}{// @todo Maybe add some more text on the linearization}
556       \textcolor{keywordtype}{double} x = phi\_d + 0.05;
557       std::cout << \textcolor{stringliteral}{"d\_lin = d\_d\_d\_phi * (phi\_d - x) + d@(phi\_d) = "} << d\_d\_d\_phi * (x-phi\_d) + d\_double << 
      std::endl;
558       std::cout << \textcolor{stringliteral}{"d@x = "} << x*x + 25 + trace(eps\_d) + eps\_d.norm() << std::endl;
559 
560     \textcolor{comment}{// And that's it. By using the Sacado\_wrapper we can compute derivatives with respect to}
561     \textcolor{comment}{// a tensor and a scalar at the same time (besides the equations)}
562     \textcolor{comment}{// in essence with just the following lines of code namely:}
563     \textcolor{comment}{// - eps.init(eps\_d); phi.init(phi\_d);   // To initialize the Sacado strain tensor and scalar damage
       variable}
564     \textcolor{comment}{// - DoFs\_summary.set\_dofs(eps, phi);    // To declare the components of eps and phi as the dofs}
565     \textcolor{comment}{// - eps.get\_tangent(*); // To get tangents with respect to eps}
566     \textcolor{comment}{// - phi.get\_tangent(*); // To get tangents with respect to phi}
567 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}\label{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+5@{sacado\+\_\+test\+\_\+5}}
\index{sacado\+\_\+test\+\_\+5@{sacado\+\_\+test\+\_\+5}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+5()}{sacado\_test\_5()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+5 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Referenced by main().


\begin{DoxyCode}
573 \{
574     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
575     std::cout << \textcolor{stringliteral}{"Test 5:"} << std::endl;
576     Tensor<1,dim,fad\_double> c;
577     \hyperlink{Sacado-auxiliary__functions_8h_a868b94676739e612d9c95940e70892a9}{fad\_double} a,b;
578     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n\_dofs=2;
579     a = 1; b = 2;   \textcolor{comment}{// at the point (a,b) = (1,2)}
580     a.diff(0,2);  \textcolor{comment}{// Set a to be dof 0, in a 2-dof system.}
581     b.diff(1,2);  \textcolor{comment}{// Set b to be dof 1, in a 2-dof system.}
582     \textcolor{comment}{// c is now a vector with three components}
583     c[0] = 2*a+3*b;
584     c[1] = 4*a+5*b;
585     c[2] = 6*a+7*b;
586     
587     \textcolor{comment}{// Access to the derivatives works as before.}
588     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<dim;++i)
589     \{
590         \textcolor{keyword}{const} \hyperlink{Sacado-auxiliary__functions_8h_a868b94676739e612d9c95940e70892a9}{fad\_double} &derivs = c[i]; \textcolor{comment}{// Access derivatives}
591         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0;j<n\_dofs;++j)
592         \{
593             std::cout << \textcolor{stringliteral}{"Derivatives at the point ("} << a << \textcolor{stringliteral}{","} << b << \textcolor{stringliteral}{") for "}
594             <<i<<\textcolor{stringliteral}{"th component wrt "}<<j<<\textcolor{stringliteral}{"th direction "}<< std::endl;
595             std::cout << \textcolor{stringliteral}{"dc\_i/dxj = "} << derivs.fastAccessDx(j) << std::endl;            
596         \}
597     \}
598 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}\label{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+6@{sacado\+\_\+test\+\_\+6}}
\index{sacado\+\_\+test\+\_\+6@{sacado\+\_\+test\+\_\+6}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+6()}{sacado\_test\_6()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+6 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Referenced by main().


\begin{DoxyCode}
606 \{
607     std::cout << \textcolor{stringliteral}{"Test 6:"} << std::endl;
608     \textcolor{comment}{// Define the variables used in the computation (inputs: a, b; output: c; auxiliaries: *) as doubles}
609      \textcolor{keywordtype}{double} a=1;
610      \textcolor{keywordtype}{double} b=2;
611 
612     \textcolor{comment}{// Number of independent variables (scalar a and b)}
613      \textcolor{keywordtype}{int} num\_dofs = 2;
614 
615     \textcolor{comment}{// Define another data type containing even more Sacado data types}
616     \textcolor{comment}{// @todo try to merge the fad\_double data type with this templated data type}
617      \textcolor{keyword}{typedef} Sacado::Fad::DFad<double> \hyperlink{Sacado__Wrapper_8h_a7e0893207b87dad05c66a34baac8ed2e}{DFadType};
618      Sacado::Fad::DFad<DFadType> afad(num\_dofs, 0, a);
619      Sacado::Fad::DFad<DFadType> bfad(num\_dofs, 1, b);
620      Sacado::Fad::DFad<DFadType> cfad;
621 
622     \textcolor{comment}{// Output the variables: We se that the values of \(\backslash\)a a and \(\backslash\)a b are set but the derivatives have not
       yet been fully declared}
623      std::cout << \textcolor{stringliteral}{"afad="} << afad << std::endl;
624      std::cout << \textcolor{stringliteral}{"bfad="} << bfad << std::endl;
625      std::cout << \textcolor{stringliteral}{"cfad="} << cfad << std::endl;
626 
627     \textcolor{comment}{// Now we set the "inner" derivatives.}
628     afad.val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(num\_dofs, 0, a); \textcolor{comment}{// set afad.val() as the first dof and init it with
       the double a}
629     bfad.val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(num\_dofs, 1, b);
630 
631     \textcolor{comment}{// Compute function and derivative with AD}
632      cfad = 2*afad + std::cos(afad*bfad);
633 
634     \textcolor{comment}{// After this, we output the variables again and see that some additional derivatives have been
       declared. Furthermore,}
635     \textcolor{comment}{// \(\backslash\)a cfad is filled with the values and derivatives}
636      std::cout << \textcolor{stringliteral}{"afad="} << afad << std::endl;
637      std::cout << \textcolor{stringliteral}{"bfad="} << bfad << std::endl;
638      std::cout << \textcolor{stringliteral}{"cfad="} << cfad << std::endl;
639 
640     \textcolor{comment}{// Extract value and derivatives}
641      \textcolor{keywordtype}{double} c\_ad = cfad.val().val();       \textcolor{comment}{// r}
642      \textcolor{keywordtype}{double} dcda\_ad = cfad.dx(0).val();    \textcolor{comment}{// dr/da}
643      \textcolor{keywordtype}{double} dcdb\_ad = cfad.dx(1).val();    \textcolor{comment}{// dr/db}
644      \textcolor{keywordtype}{double} d2cda2\_ad = cfad.dx(0).dx(0);  \textcolor{comment}{// d^2r/da^2}
645      \textcolor{keywordtype}{double} d2cdadb\_ad = cfad.dx(0).dx(1); \textcolor{comment}{// d^2r/dadb}
646      \textcolor{keywordtype}{double} d2cdbda\_ad = cfad.dx(1).dx(0); \textcolor{comment}{// d^2r/dbda}
647      \textcolor{keywordtype}{double} d2cdb2\_ad = cfad.dx(1).dx(1);  \textcolor{comment}{// d^2/db^2}
648 
649     \textcolor{comment}{// Now we can print the actual double value of c and some of the derivatives:}
650      std::cout << \textcolor{stringliteral}{"c\_ad="} << c\_ad << std::endl;
651      std::cout << \textcolor{stringliteral}{"Derivatives at the point ("} << a << \textcolor{stringliteral}{","} << b << \textcolor{stringliteral}{")"} << std::endl;
652      std::cout << \textcolor{stringliteral}{"dc/da = "} << dcda\_ad << \textcolor{stringliteral}{", dc/db="} << dcdb\_ad << std::endl;
653      std::cout << \textcolor{stringliteral}{"d²c/da² = "} << d2cda2\_ad << \textcolor{stringliteral}{", d²c/db²="} << d2cdb2\_ad << std::endl;
654      std::cout << \textcolor{stringliteral}{"d²c/dadb = "} << d2cdadb\_ad << \textcolor{stringliteral}{", d²c/dbda="} << d2cdbda\_ad << std::endl;
655 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}\label{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+7@{sacado\+\_\+test\+\_\+7}}
\index{sacado\+\_\+test\+\_\+7@{sacado\+\_\+test\+\_\+7}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+7()}{sacado\_test\_7()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+7 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Referenced by main().


\begin{DoxyCode}
660 \{
661     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
662 
663     std::cout << \textcolor{stringliteral}{"Test 7:"} << std::endl;
664 
665     \textcolor{comment}{// Defining the inputs (material parameters, strain tensor)}
666      \textcolor{keywordtype}{double} lambda=1;
667      \textcolor{keywordtype}{double} mu=2;
668      SymmetricTensor<2,dim, double> eps;
669 
670      eps[0][0] = 1.;
671      eps[1][1] = 2.;
672      eps[2][2] = 3.;
673 
674      eps[0][1] = 4.;
675      eps[0][2] = 5.;
676      eps[1][2] = 6.;
677 
678     \textcolor{comment}{// Here we skip the one-field example and right away show the equations for a two-field problem}
679     \textcolor{comment}{// with \(\backslash\)a eps and \(\backslash\)a phi.}
680      \textcolor{keywordtype}{double} phi=0.3;
681 
682     \textcolor{comment}{// Setup of the map relating the indices (as before)}
683      std::map<unsigned int,std::pair<unsigned int,unsigned int>> std\_map\_indicies;
684 
685      std::pair<unsigned int, unsigned int> tmp\_pair;
686      tmp\_pair.first=0; tmp\_pair.second=0;
687      std\_map\_indicies[0] = tmp\_pair;
688 
689      tmp\_pair.first=0; tmp\_pair.second=1;
690      std\_map\_indicies[1] = tmp\_pair;
691 
692      tmp\_pair.first=0; tmp\_pair.second=2;
693      std\_map\_indicies[2] = tmp\_pair;
694 
695      tmp\_pair.first=1; tmp\_pair.second=1;
696      std\_map\_indicies[3] = tmp\_pair;
697 
698      tmp\_pair.first=1; tmp\_pair.second=2;
699      std\_map\_indicies[4] = tmp\_pair;
700 
701      tmp\_pair.first=2; tmp\_pair.second=2;
702      std\_map\_indicies[5] = tmp\_pair;
703 
704     \textcolor{comment}{// Number of independent variables (6 for the tensor and 1 for the scalar phi)}
705      \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nbr\_dofs = 6+1;
706 
707     \textcolor{comment}{// Declaring the special data types containing all derivatives}
708      \textcolor{keyword}{typedef} Sacado::Fad::DFad<double> \hyperlink{Sacado__Wrapper_8h_a7e0893207b87dad05c66a34baac8ed2e}{DFadType};
709      SymmetricTensor<2,dim, Sacado::Fad::DFad<DFadType> > eps\_fad, eps\_fad\_squared;
710      Sacado::Fad::DFad<DFadType> phi\_fad;
711 
712 
713     \textcolor{comment}{// Setting the dofs}
714      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0; x<6; ++x )
715      \{
716         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=std\_map\_indicies[x].first;
717         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=std\_map\_indicies[x].second;
718         (eps\_fad[i][j]).diff( x, nbr\_dofs); \textcolor{comment}{// set up the "inner" derivatives}
719         (eps\_fad[i][j]).val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, x, eps[i][j]); \textcolor{comment}{// set up the "outer"
       derivatives}
720      \}
721 
722      phi\_fad.diff( 6, nbr\_dofs );
723      phi\_fad.val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, 6, phi); \textcolor{comment}{// set up the "outer" derivatives}
724 
725      std::cout << \textcolor{stringliteral}{"eps\_fad="} << eps\_fad << std::endl;
726      std::cout << \textcolor{stringliteral}{"phi\_fad="} << phi\_fad << std::endl;
727 
728     \textcolor{comment}{// Compute eps² = eps\_ij * eps\_jk in index notation}
729      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
730         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k )
731             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
732                 \textcolor{keywordflow}{if} ( i>=k )
733                     eps\_fad\_squared[i][k] += eps\_fad[i][j] * eps\_fad[j][k];
734 
735     \textcolor{comment}{// Compute the strain energy density}
736      Sacado::Fad::DFad<DFadType> energy;
737      energy = lambda/2. * trace(eps\_fad)*trace(eps\_fad) + mu * trace(eps\_fad\_squared) + 25 * phi\_fad * 
      trace(eps\_fad);
738 
739     \textcolor{comment}{// Give some insight into the storage of the values and derivatives}
740      std::cout << \textcolor{stringliteral}{"energy="} << energy << std::endl;
741 
742     \textcolor{comment}{// Compute sigma as \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\} \(\backslash\)f]}
743      SymmetricTensor<2,dim> sigma\_Sac;
744      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0; x<6; ++x )
745      \{
746         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=std\_map\_indicies[x].first;
747         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=std\_map\_indicies[x].second;
748         \textcolor{keywordflow}{if} ( i!=j )
749             sigma\_Sac[i][j] = 0.5 * energy.dx(x).val();
750         \textcolor{keywordflow}{else}
751             sigma\_Sac[i][j] = energy.dx(x).val();
752      \}
753      std::cout << \textcolor{stringliteral}{"sigma\_Sacado="} << sigma\_Sac << std::endl;
754 
755      \textcolor{keywordtype}{double} d\_energy\_d\_phi = energy.dx(6).val();
756      std::cout << \textcolor{stringliteral}{"d\_energy\_d\_phi="} << d\_energy\_d\_phi << std::endl;
757 
758      \textcolor{keywordtype}{double} d2\_energy\_d\_phi\_2 = energy.dx(6).dx(6);
759      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_phi\_2="} << d2\_energy\_d\_phi\_2 << std::endl;
760 
761     \textcolor{comment}{// Analytical stress tensor:}
762      SymmetricTensor<2,dim> sigma;
763      sigma = lambda*trace(eps)*unit\_symmetric\_tensor<dim>() + 2. * mu * eps + 25 * phi * 
      unit\_symmetric\_tensor<dim>();
764      std::cout << \textcolor{stringliteral}{"analy. sigma="} << sigma << std::endl;
765 
766 
767     \textcolor{comment}{// Sacado-Tangent}
768      SymmetricTensor<4,dim> C\_Sac;
769      \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0;x<6;++x)
770         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} y=0;y<6;++y)
771         \{
772             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=std\_map\_indicies[y].first;
773             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=std\_map\_indicies[y].second;
774             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=std\_map\_indicies[x].first;
775             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=std\_map\_indicies[x].second;
776 
777             \textcolor{keywordtype}{double} deriv = energy.dx(x).dx(y); \textcolor{comment}{// Access the derivatives of the (i,j)-th component of \(\backslash\)a
       sigma}
778 
779             \textcolor{keywordflow}{if} ( k!=l && i!=j )
780                 C\_Sac[i][j][k][l] = 0.25* deriv;
781             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(k!=l)\textcolor{comment}{/*Compare to Voigt notation since only SymmetricTensor instead of Tensor*/}
782             \{
783                 C\_Sac[i][j][k][l] = 0.5*deriv;
784                 C\_Sac[i][j][l][k] = 0.5*deriv;
785             \}
786             \textcolor{keywordflow}{else}
787                 C\_Sac[i][j][k][l] = deriv;
788         \}
789 
790     \textcolor{comment}{// Analytical tangent}
791      SymmetricTensor<4,dim> C\_analy;
792      C\_analy = lambda * outer\_product(unit\_symmetric\_tensor<dim>(), unit\_symmetric\_tensor<dim>()) + 2. * mu
       * identity\_tensor<dim>();
793 
794     \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
795     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
796         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
797             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
798                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
799                     error\_Sacado\_vs\_analy += std::fabs(C\_Sac[i][j][k][l] - C\_analy[i][j][k][l]);
800 
801     std::cout << \textcolor{stringliteral}{"Numerical error="} << error\_Sacado\_vs\_analy << std::endl;
802 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}\label{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+8@{sacado\+\_\+test\+\_\+8}}
\index{sacado\+\_\+test\+\_\+8@{sacado\+\_\+test\+\_\+8}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+8()}{sacado\_test\_8()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+8 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



References Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double2$<$ dim $>$\+::get\+\_\+curvature(), Sacado\+\_\+\+Wrapper\+::\+Do\+Fs\+\_\+summary$<$ dim $>$\+::get\+\_\+curvature(), Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double2$<$ dim $>$\+::get\+\_\+tangent(), and Sacado\+\_\+\+Wrapper\+::\+Do\+Fs\+\_\+summary$<$ dim $>$\+::init\+\_\+set\+\_\+dofs().



Referenced by main().


\begin{DoxyCode}
809 \{
810     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
811 
812     std::cout << \textcolor{stringliteral}{"Test 8:"} << std::endl;
813 
814     \textcolor{comment}{// Defining the inputs (material parameters, strain tensor)}
815      \textcolor{keywordtype}{double} lambda=1;
816      \textcolor{keywordtype}{double} mu=2;
817      SymmetricTensor<2,dim, double> eps;
818      \textcolor{keywordtype}{double} phi = 0.3;
819 
820      eps[0][0] = 1.;
821      eps[1][1] = 2.;
822      eps[2][2] = 3.;
823 
824      eps[0][1] = 4.;
825      eps[0][2] = 5.;
826      eps[1][2] = 6.;
827 
828     \textcolor{comment}{// Declaring the special data types containing all derivatives}
829      \textcolor{keyword}{typedef} Sacado::Fad::DFad<double> \hyperlink{Sacado__Wrapper_8h_a7e0893207b87dad05c66a34baac8ed2e}{DFadType};
830 
831     \textcolor{comment}{// Declare the variables \(\backslash\)a eps\_fad and \(\backslash\)a phi\_fad as the special Wrapper data types}
832      \hyperlink{classSacado__Wrapper_1_1SymTensor2}{Sacado\_Wrapper::SymTensor2<dim>} eps\_fad;
833      \hyperlink{classSacado__Wrapper_1_1SW__double2}{Sacado\_Wrapper::SW\_double2<dim>} phi\_fad;
834 
835     \textcolor{comment}{// Declare the summary data type relating all the dofs and initialising them too}
836      \hyperlink{classSacado__Wrapper_1_1DoFs__summary}{Sacado\_Wrapper::DoFs\_summary<dim>} DoFs\_summary;
837      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_ae273d0fa3197118a11d7005523e27d8a}{init\_set\_dofs}(eps\_fad, eps, phi\_fad, phi);
838 
839     \textcolor{comment}{// The variables are outputted to give some insight into the storage of the values (derivatives still
       trivial).}
840      std::cout << \textcolor{stringliteral}{"eps\_fad="} << eps\_fad << std::endl;
841      std::cout << \textcolor{stringliteral}{"phi\_fad="} << phi\_fad << std::endl;
842 
843     \textcolor{comment}{// Compute eps² = eps\_ij * eps\_jk in index notation}
844      SymmetricTensor<2,dim, Sacado::Fad::DFad<DFadType> > eps\_fad\_squared;
845      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
846         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k )
847             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
848                 \textcolor{keywordflow}{if} ( i>=k )
849                     eps\_fad\_squared[i][k] += eps\_fad[i][j] * eps\_fad[j][k];
850 
851     \textcolor{comment}{// Compute the strain energy density}
852      Sacado::Fad::DFad<DFadType> energy;
853      energy = lambda/2. * trace(eps\_fad)*trace(eps\_fad) + mu * trace(eps\_fad\_squared) + 25 * phi\_fad * 
      trace(eps\_fad);
854 
855     \textcolor{comment}{// The energy is outputted (formatted by hand) to give some insight into the storage of the values and
       derivatives. \(\backslash\)n}
856     \textcolor{comment}{// energy=399 [ 17.5 32 40 21.5 48 25.5 150 ] \(\backslash\)n}
857     \textcolor{comment}{// [ 17.5 [ 5 0 0 1 0 1 25 ] 32 [ 0 8 0 0 0 0 0 ] 40 [ 0 0 8 0 0 0 0 ] \(\backslash\)n}
858     \textcolor{comment}{// 21.5 [ 1 0 0 5 0 1 25 ] 48 [ 0 0 0 0 8 0 0 ] 25.5 [ 1 0 0 1 0 5 25 ] \(\backslash\)n}
859     \textcolor{comment}{// 150 [ 25 0 0 25 0 25 0 ] ]}
860 
861      std::cout << \textcolor{stringliteral}{"energy="} << energy << std::endl;
862 
863     \textcolor{comment}{// Compute sigma as \(\backslash\)f[ \(\backslash\)boldsymbol\{\(\backslash\)sigma\} = \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\}
       \(\backslash\)f]}
864      SymmetricTensor<2,dim> sigma\_Sac;
865      eps\_fad.get\_tangent(sigma\_Sac, energy);
866      std::cout << \textcolor{stringliteral}{"sigma\_Sacado="} << sigma\_Sac << std::endl;
867 
868      \textcolor{keywordtype}{double} d\_energy\_d\_phi;
869      phi\_fad.\hyperlink{classSacado__Wrapper_1_1SW__double2_ad51ba1e79171d60861b28098dfef903d}{get\_tangent}(d\_energy\_d\_phi, energy);
870      std::cout << \textcolor{stringliteral}{"d\_energy\_d\_phi="} << d\_energy\_d\_phi << std::endl;
871 
872 
873     \textcolor{comment}{// Analytical stress tensor:}
874      SymmetricTensor<2,dim> sigma;
875      sigma = lambda*trace(eps)*unit\_symmetric\_tensor<dim>() + 2. * mu * eps + 25 * phi * 
      unit\_symmetric\_tensor<dim>();
876      std::cout << \textcolor{stringliteral}{"analy. sigma="} << sigma << std::endl;
877 
878 
879     \textcolor{comment}{// Sacado stress tangent (or eps curvature) as \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial
       \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}^2\} \(\backslash\)f]}
880      SymmetricTensor<4,dim> C\_Sac;
881      eps\_fad.get\_curvature(C\_Sac, energy);
882 
883     \textcolor{comment}{// Sacado phi curvature as \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)varphi^2\} \(\backslash\)f]}
884      \textcolor{keywordtype}{double} d2\_energy\_d\_phi\_2;
885      phi\_fad.\hyperlink{classSacado__Wrapper_1_1SW__double2_a7d3f3a21cd842645af9861bf50308825}{get\_curvature}(d2\_energy\_d\_phi\_2, energy);
886      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_phi\_2="} << d2\_energy\_d\_phi\_2 << std::endl;
887 
888     \textcolor{comment}{// Sacado derivatives \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\} \(\backslash\)partial \(\backslash\)varphi\}
       \(\backslash\)f]}
889      SymmetricTensor<2,dim> d2\_energy\_d\_eps\_d\_phi;
890      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_adf29bfda10814ecee9572a4751d34db0}{get\_curvature}(d2\_energy\_d\_eps\_d\_phi, energy, eps\_fad, phi\_fad);
891      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_eps\_d\_phi="} << d2\_energy\_d\_eps\_d\_phi << std::endl;
892 
893     \textcolor{comment}{// Sacado derivatives \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)varphi \(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\}
       \(\backslash\)f]}
894      SymmetricTensor<2,dim> d2\_energy\_d\_phi\_d\_eps;
895      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_adf29bfda10814ecee9572a4751d34db0}{get\_curvature}(d2\_energy\_d\_phi\_d\_eps, energy, phi\_fad, eps\_fad);
896      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_phi\_d\_eps="} << d2\_energy\_d\_phi\_d\_eps << std::endl;
897 
898     \textcolor{comment}{// When you consider the output: \(\backslash\)n}
899     \textcolor{comment}{// d2\_energy\_d\_eps\_d\_phi=25 0 0 0 25 0 0 0 25 \(\backslash\)n}
900     \textcolor{comment}{// d2\_energy\_d\_phi\_d\_eps=25 0 0 0 25 0 0 0 25 \(\backslash\)n}
901     \textcolor{comment}{// in detail you will notice that both second derivatives are identical. This compplies with the
       Schwarz integrability condition (Symmetry of second derivatives)}
902     \textcolor{comment}{// (ignoring all limitation and requirements), it holds}
903     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\} \(\backslash\)partial \(\backslash\)varphi\} = \(\backslash\)frac\{\(\backslash\)partial^2
       \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)varphi \(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\}  \(\backslash\)f]}
904 
905     \textcolor{comment}{// Analytical stress tangent}
906      SymmetricTensor<4,dim> C\_analy;
907      C\_analy = lambda * outer\_product(unit\_symmetric\_tensor<dim>(), unit\_symmetric\_tensor<dim>()) + 2. * mu
       * identity\_tensor<dim>();
908 
909     \textcolor{comment}{// Compute the error for the stress tangent}
910      \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
911      \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
912         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
913             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
914                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
915                     error\_Sacado\_vs\_analy += std::fabs(C\_Sac[i][j][k][l] - C\_analy[i][j][k][l]);
916      std::cout << \textcolor{stringliteral}{"Numerical error="} << error\_Sacado\_vs\_analy << std::endl;
917 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_ae176f83fe1943e102fe325d4a14f097e}\label{Sacado__example_8cc_ae176f83fe1943e102fe325d4a14f097e}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+9@{sacado\+\_\+test\+\_\+9}}
\index{sacado\+\_\+test\+\_\+9@{sacado\+\_\+test\+\_\+9}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+9()}{sacado\_test\_9()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+9 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Referenced by main().


\begin{DoxyCode}
923 \{
924     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
925 
926     std::cout << \textcolor{stringliteral}{"Test 9:"} << std::endl;
927 
928     \textcolor{keywordtype}{double} kappa\_param = 5;
929     \hyperlink{Sacado-auxiliary__functions_8h_a868b94676739e612d9c95940e70892a9}{fad\_double} kappa (kappa\_param);
930     \textcolor{keywordtype}{double} mu = 2;
931 
932     SymmetricTensor<2,dim, fad\_double> sigma, eps;
933 
934     std::map<unsigned int,std::pair<unsigned int,unsigned int>> std\_map\_indicies;
935 
936         eps[0][0] = 1;
937         eps[1][1] = 2;
938         eps[2][2] = 3;
939 
940         eps[0][1] = 4;
941         eps[0][2] = 5;
942         eps[1][2] = 6;
943 
944 
945         eps[0][0].diff(0,6);
946         eps[0][1].diff(1,6);
947         eps[0][2].diff(2,6);
948         eps[1][1].diff(3,6);
949         eps[1][2].diff(4,6);
950         eps[2][2].diff(5,6);
951 
952         std::pair<unsigned int, unsigned int> tmp\_pair;
953         tmp\_pair.first=0; tmp\_pair.second=0;
954         std\_map\_indicies[0] = tmp\_pair;
955 
956         tmp\_pair.first=0; tmp\_pair.second=1;
957         std\_map\_indicies[1] = tmp\_pair;
958 
959         tmp\_pair.first=0; tmp\_pair.second=2;
960         std\_map\_indicies[2] = tmp\_pair;
961 
962         tmp\_pair.first=1; tmp\_pair.second=1;
963         std\_map\_indicies[3] = tmp\_pair;
964 
965         tmp\_pair.first=1; tmp\_pair.second=2;
966         std\_map\_indicies[4] = tmp\_pair;
967 
968         tmp\_pair.first=2; tmp\_pair.second=2;
969         std\_map\_indicies[5] = tmp\_pair;
970 
971     SymmetricTensor<2,dim, fad\_double> stdTensor\_I (( unit\_symmetric\_tensor<dim,fad\_double>()) );
972 
973     sigma = kappa * (trace(eps) *  stdTensor\_I);
974     SymmetricTensor<2,dim,fad\_double> tmp = deviator<dim,fad\_double>(symmetrize<dim,fad\_double>(eps)); tmp*
      =(mu*2);
975     sigma +=  tmp;
976 
977     std::cout << \textcolor{stringliteral}{"sigma="} << sigma << std::endl;
978 
979      \textcolor{comment}{// Retrieve the values stored in \(\backslash\)a sigma:}
980       SymmetricTensor<2,dim> sigma\_d;
981       \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
982             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
983                 sigma\_d[i][j] = sigma[i][j].val();
984 
985     SymmetricTensor<4,dim> C\_Sacado;
986 
987     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
988         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
989         \{
990             \textcolor{keywordtype}{double} *derivs = &sigma[i][j].fastAccessDx(0); \textcolor{comment}{// Access the derivatives of the (i,j)-th
       component of \(\backslash\)a sigma}
991 
992             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0;x<((dim==2)?3:6);++x)
993             \{
994                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=std\_map\_indicies[x].first;
995                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=std\_map\_indicies[x].second;
996 
997                 \textcolor{keywordflow}{if}(k!=l)\textcolor{comment}{/*Compare to Voigt notation since only SymmetricTensor instead of Tensor*/}
998                 \{
999                     C\_Sacado[i][j][k][l] = 0.5*derivs[x];
1000                     C\_Sacado[i][j][l][k] = 0.5*derivs[x];
1001                 \}
1002                 \textcolor{keywordflow}{else}
1003                     C\_Sacado[i][j][k][l] = derivs[x];
1004             \}
1005         \}
1006 
1007     SymmetricTensor<2,dim> eps\_d;
1008     eps\_d[0][0] = 1;
1009     eps\_d[1][1] = 2;
1010     eps\_d[2][2] = 3;
1011 
1012     eps\_d[0][1] = 4;
1013     eps\_d[0][2] = 5;
1014     eps\_d[1][2] = 6;
1015 
1016     SymmetricTensor<2,dim> stress\_from\_tangent = C\_Sacado*eps\_d;
1017 
1018     std::cout << \textcolor{stringliteral}{"C\_Sacado*eps\_d="} << stress\_from\_tangent << std::endl;
1019     std::cout << \textcolor{stringliteral}{"sigma=         "} << sigma\_d << std::endl;
1020 
1021     \textcolor{comment}{// @todo Add the link to the ac.nz site}
1022 
1023     \textcolor{comment}{// As you can see we obtain the correct stress tensor only by using the factor 0.5 onto the
       off-diagonal elements of the symmetric tensor. \(\backslash\)n}
1024     \textcolor{comment}{// @note So, why do we need the factor 0.5 then? (based on [homepages.engineering.auckland.ac.nz
       ...])\(\backslash\)n}
1025     \textcolor{comment}{// When using symmetric tensor one has to be aware of the definition of the independent variables. In
       3d those are the}
1026     \textcolor{comment}{// following 6 components: \(\backslash\)n}
1027     \textcolor{comment}{// - \(\backslash\)f$ A\_\{11\} \(\backslash\)f$}
1028     \textcolor{comment}{// - \(\backslash\)f$ A\_\{22\} \(\backslash\)f$}
1029     \textcolor{comment}{// - \(\backslash\)f$ A\_\{33\} \(\backslash\)f$}
1030     \textcolor{comment}{// - \(\backslash\)f$ \(\backslash\)overline\{A\_\{12\}\} \(\backslash\)f$}
1031     \textcolor{comment}{// - \(\backslash\)f$ \(\backslash\)overline\{A\_\{13\}\} \(\backslash\)f$}
1032     \textcolor{comment}{// - \(\backslash\)f$ \(\backslash\)overline\{A\_\{23\}\} \(\backslash\)f$ \(\backslash\)n}
1033     \textcolor{comment}{// Here the overlined components denote the averaged values, such that}
1034     \textcolor{comment}{// - \(\backslash\)f$ \(\backslash\)overline\{A\_\{12\}\} = 0.5 \(\backslash\)cdot [ A\_\{12\} + A\_\{21\} ] = A\_\{12\} = A\_\{21\} \(\backslash\)f$}
1035     \textcolor{comment}{// - ... \(\backslash\)n}
1036     \textcolor{comment}{// This looks rather boring, because the averaged value of the two identical components (symmetry) is
       identical to the components.}
1037     \textcolor{comment}{// But (and that is a crucial BUT), this only holds for the values NOT the derivatives.}
1038     \textcolor{comment}{// The derivative of a function \(\backslash\)f$ \(\backslash\)Phi \(\backslash\)f$ with respect to a symmetric tensor \(\backslash\)a A is}
1039     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Phi\}\{\(\backslash\)partial \(\backslash\)overline\{A\_\{12\}\}\} = \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Phi\}\{\(\backslash\)partial A\_\{12\}\} \(\backslash\)cdot
       \(\backslash\)frac\{\(\backslash\)partial A\_\{12\}\}\{\(\backslash\)partial \(\backslash\)overline\{A\_\{12\}\}\}}
1040     \textcolor{comment}{//                                                          + \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Phi\}\{\(\backslash\)partial A\_\{21\}\}
       \(\backslash\)cdot \(\backslash\)frac\{\(\backslash\)partial A\_\{21\}\}\{\(\backslash\)partial \(\backslash\)overline\{A\_\{21\}\}\}}
1041     \textcolor{comment}{//                                                          = \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Phi\}\{\(\backslash\)partial A\_\{12\}\} +
       \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Phi\}\{\(\backslash\)partial A\_\{21\}\}}
1042     \textcolor{comment}{//                                                          = 2 \(\backslash\)cdot \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Phi\}\{\(\backslash\)partial
       A\_\{12\}\} \(\backslash\)f]}
1043     \textcolor{comment}{// Note how the derivatives with respect to the actual tensor components (here 12 and 21) are
       identical. \(\backslash\)n}
1044     \textcolor{comment}{// However, our derivatives (computed via Sacado) were calculated with respect to the actually
       independent}
1045     \textcolor{comment}{// variables (overlined). Still, in the tensor with the derivatives we want the derivatives with
       respect to the normal components (not overlined). \(\backslash\)n}
1046     \textcolor{comment}{// Summary: \(\backslash\)n}
1047     \textcolor{comment}{// When you compute derivatives with respect to a symmetric tensor, you have to scale the off-diagonal
       elements by 0.5 to account for the fact that you actually work with}
1048     \textcolor{comment}{// the averaged values. \(\backslash\)n}
1049     \textcolor{comment}{// As a consequence, we use the factor 0.5 for all off-diagonal components of derivatives with respect
       to symmetric tensors. For second derivatives with respect to}
1050     \textcolor{comment}{// symmetric tensors the factors 0.5 and 0.25 come into play.}
1051 
1052 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}\label{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+scalar@{sacado\+\_\+test\+\_\+scalar}}
\index{sacado\+\_\+test\+\_\+scalar@{sacado\+\_\+test\+\_\+scalar}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+scalar()}{sacado\_test\_scalar()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+scalar (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Referenced by main().


\begin{DoxyCode}
44 \{
45     std::cout << \textcolor{stringliteral}{"Scalar Test:"} << std::endl;
46     \textcolor{comment}{// Define the variables used in the computation (inputs/independent variables: a, b; output/result: c;
       auxiliaries/passive variables: *) as the Sacado-data type}
47      \hyperlink{Sacado-auxiliary__functions_8h_a868b94676739e612d9c95940e70892a9}{fad\_double} a,b,c;
48     \textcolor{comment}{// Initialize the input variables a and b; This (a,b) = (1,2) will be the point where the derivatives
       are computed.}
49     \textcolor{comment}{// Compare: y=x² -> (dy/dx)(\(\backslash\)@x=1) = 2. We can only compute the derivative numerically at a certain
       point.}
50      a = 1;
51      b = 2;
52 
53     a.diff(0,2);  \textcolor{comment}{// Set a to be dof 0, in a 2-dof system.}
54     b.diff(1,2);  \textcolor{comment}{// Set b to be dof 1, in a 2-dof system.}
55     \textcolor{comment}{// Our equation here is very simply. But you can use nested equations and many standard mathematical
       operations, such as sqrt, pow, sin, ...}
56     c = 2*a + std::cos(a*b);
57     \textcolor{keywordtype}{double} *derivs = &c.fastAccessDx(0); \textcolor{comment}{// Access the derivatives of}
58     \textcolor{comment}{// Output the derivatives of c with respect to the two above defined degrees of freedom (dof)}
59     std::cout << \textcolor{stringliteral}{"Derivatives at the point ("} << a << \textcolor{stringliteral}{","} << b << \textcolor{stringliteral}{")"} << std::endl;
60     std::cout << \textcolor{stringliteral}{"dc/da = "} << derivs[0] << \textcolor{stringliteral}{", dc/db="} << derivs[1] << std::endl;
61 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_ae6e87a9cc06bd452cb5a1bfec2245569}\label{Sacado__example_8cc_ae6e87a9cc06bd452cb5a1bfec2245569}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!stress\+\_\+strain\+\_\+relation@{stress\+\_\+strain\+\_\+relation}}
\index{stress\+\_\+strain\+\_\+relation@{stress\+\_\+strain\+\_\+relation}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{stress\+\_\+strain\+\_\+relation()}{stress\_strain\_relation()}}
{\footnotesize\ttfamily template$<$int dim, typename Number $>$ \\
Symmetric\+Tensor$<$2,dim,Number$>$ stress\+\_\+strain\+\_\+relation (\begin{DoxyParamCaption}\item[{const Symmetric\+Tensor$<$ 2, dim, Number $>$ \&}]{eps,  }\item[{const double \&}]{kappa,  }\item[{const double \&}]{mu }\end{DoxyParamCaption})}



Referenced by sacado\+\_\+test\+\_\+10().


\begin{DoxyCode}
1057 \{
1058     SymmetricTensor<2,dim,Number> sigma;
1059 
1060     SymmetricTensor<2,dim,Number> stdTensor\_I (( unit\_symmetric\_tensor<dim,Number>()) );
1061 
1062     \textcolor{comment}{// Our stress equation is now computed in index notation to simplify the use of the constants and}
1063     \textcolor{comment}{// especially the use of the \(\backslash\)a deviator.}
1064      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
1065         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
1066             sigma[i][j] = kappa * trace(eps) *  stdTensor\_I[i][j] + 2. * mu * deviator(eps)[i][j];
1067 
1068     \textcolor{keywordflow}{return} sigma;
1069 \}
\end{DoxyCode}
