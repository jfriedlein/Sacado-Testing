\hypertarget{Sacado__example_8cc}{}\section{Sacado\+\_\+example.\+cc File Reference}
\label{Sacado__example_8cc}\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
{\ttfamily \#include $<$deal.\+I\+I/base/symmetric\+\_\+tensor.\+h$>$}\\*
{\ttfamily \#include $<$iostream$>$}\\*
{\ttfamily \#include $<$fstream$>$}\\*
{\ttfamily \#include $<$cmath$>$}\\*
{\ttfamily \#include $<$Sacado.\+hpp$>$}\\*
{\ttfamily \#include \char`\"{}Sacado\+\_\+\+Wrapper.\+h\char`\"{}}\\*
Include dependency graph for Sacado\+\_\+example.\+cc\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{Sacado__example_8cc__incl}
\end{center}
\end{figure}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\+\_\+double} = Sacado\+::\+Fad\+::\+D\+Fad$<$ double $>$
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}{sacado\+\_\+test\+\_\+scalar} ()
\item 
void \hyperlink{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}{sacado\+\_\+test\+\_\+2} ()
\item 
void \hyperlink{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}{sacado\+\_\+test\+\_\+3} ()
\item 
void \hyperlink{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}{sacado\+\_\+test\+\_\+3B} ()
\item 
void \hyperlink{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}{sacado\+\_\+test\+\_\+4} ()
\item 
void \hyperlink{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}{sacado\+\_\+test\+\_\+5} ()
\item 
void \hyperlink{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}{sacado\+\_\+test\+\_\+6} ()
\item 
void \hyperlink{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}{sacado\+\_\+test\+\_\+7} ()
\item 
void \hyperlink{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}{sacado\+\_\+test\+\_\+8} ()
\item 
void \hyperlink{Sacado__example_8cc_ae176f83fe1943e102fe325d4a14f097e}{sacado\+\_\+test\+\_\+9} ()
\item 
void \hyperlink{Sacado__example_8cc_a70dbdff0078e09883ba02d2724a432b2}{sacado\+\_\+test\+\_\+10} ()
\item 
int \hyperlink{Sacado__example_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main} ()
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!fad\+\_\+double@{fad\+\_\+double}}
\index{fad\+\_\+double@{fad\+\_\+double}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{fad\+\_\+double}{fad_double}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf fad\+\_\+double} =  Sacado\+::\+Fad\+::\+D\+Fad$<$double$>$}\hypertarget{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{}\label{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}


\subsection{Function Documentation}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!main@{main}}
\index{main@{main}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{main()}{main()}}]{\setlength{\rightskip}{0pt plus 5cm}int main (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{}\label{Sacado__example_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}


References sacado\+\_\+test\+\_\+10(), sacado\+\_\+test\+\_\+2(), sacado\+\_\+test\+\_\+3(), sacado\+\_\+test\+\_\+3\+B(), sacado\+\_\+test\+\_\+4(), sacado\+\_\+test\+\_\+5(), sacado\+\_\+test\+\_\+6(), sacado\+\_\+test\+\_\+7(), sacado\+\_\+test\+\_\+8(), sacado\+\_\+test\+\_\+9(), and sacado\+\_\+test\+\_\+scalar().


\begin{DoxyCode}
1050 \{
1051     \hyperlink{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}{sacado\_test\_scalar} ();
1052 
1053     std::cout << std::endl;
1054 
1055     \hyperlink{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}{sacado\_test\_2} ();
1056 
1057     std::cout << std::endl;
1058 
1059     \hyperlink{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}{sacado\_test\_3} ();
1060 
1061     std::cout << std::endl;
1062 
1063     \hyperlink{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}{sacado\_test\_3B} ();
1064 
1065     std::cout << std::endl;
1066 
1067     \hyperlink{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}{sacado\_test\_4}();
1068 
1069     std::cout << std::endl;
1070 
1071     \hyperlink{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}{sacado\_test\_5}();
1072 
1073     std::cout << std::endl;
1074 
1075     \hyperlink{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}{sacado\_test\_6}();
1076 
1077     std::cout << std::endl;
1078 
1079     \hyperlink{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}{sacado\_test\_7}();
1080 
1081     std::cout << std::endl;
1082 
1083     \hyperlink{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}{sacado\_test\_8}();
1084 
1085     std::cout << std::endl;
1086 
1087     \hyperlink{Sacado__example_8cc_ae176f83fe1943e102fe325d4a14f097e}{sacado\_test\_9}();
1088 
1089     std::cout << std::endl;
1090 
1091     \hyperlink{Sacado__example_8cc_a70dbdff0078e09883ba02d2724a432b2}{sacado\_test\_10}();
1092 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+10@{sacado\+\_\+test\+\_\+10}}
\index{sacado\+\_\+test\+\_\+10@{sacado\+\_\+test\+\_\+10}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+10()}{sacado_test_10()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+10 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a70dbdff0078e09883ba02d2724a432b2}{}\label{Sacado__example_8cc_a70dbdff0078e09883ba02d2724a432b2}


References Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double2$<$ dim $>$\+::get\+\_\+curvature(), Sacado\+\_\+\+Wrapper\+::\+Do\+Fs\+\_\+summary$<$ dim $>$\+::get\+\_\+curvature(), Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double2$<$ dim $>$\+::get\+\_\+tangent(), and Sacado\+\_\+\+Wrapper\+::\+Do\+Fs\+\_\+summary$<$ dim $>$\+::init\+\_\+set\+\_\+dofs().



Referenced by main().


\begin{DoxyCode}
936 \{
937     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
938 
939     std::cout << \textcolor{stringliteral}{"Test 10:"} << std::endl;
940 
941     \textcolor{comment}{// Defining the inputs (material parameters, strain tensor)}
942      \textcolor{keywordtype}{double} lambda=1;
943      \textcolor{keywordtype}{double} mu=2;
944      SymmetricTensor<2,dim, double> eps;
945      \textcolor{keywordtype}{double} phi = 0.3;
946 
947      eps[0][0] = 1.;
948      eps[1][1] = 2.;
949      eps[2][2] = 3.;
950 
951      eps[0][1] = 4.;
952      eps[0][2] = 5.;
953      eps[1][2] = 6.;
954 
955     \textcolor{comment}{// Declaring the special data types containing all derivatives}
956      \textcolor{keyword}{typedef} Sacado::Fad::DFad<double> \hyperlink{Sacado__Wrapper_8h_a7e0893207b87dad05c66a34baac8ed2e}{DFadType};
957 
958     \textcolor{comment}{// Declare the variables \(\backslash\)a eps\_fad and \(\backslash\)a phi\_fad as the special Wrapper data types}
959      \hyperlink{classSacado__Wrapper_1_1SymTensor2}{Sacado\_Wrapper::SymTensor2<dim>} eps\_fad;
960      \hyperlink{classSacado__Wrapper_1_1SW__double2}{Sacado\_Wrapper::SW\_double2<dim>} phi\_fad;
961 
962     \textcolor{comment}{// Declare the summary data type relating all the dofs and initialising them too}
963      \hyperlink{classSacado__Wrapper_1_1DoFs__summary}{Sacado\_Wrapper::DoFs\_summary<dim>} DoFs\_summary;
964      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_ae273d0fa3197118a11d7005523e27d8a}{init\_set\_dofs}(eps\_fad, eps, phi\_fad, phi);
965 
966     \textcolor{comment}{// The variables are outputted to give some insight into the storage of the values (derivatives still
       trivial).}
967      std::cout << \textcolor{stringliteral}{"eps\_fad="} << eps\_fad << std::endl;
968      std::cout << \textcolor{stringliteral}{"phi\_fad="} << phi\_fad << std::endl;
969 
970     \textcolor{comment}{// Compute epsÂ² = eps\_ij * eps\_jk in index notation}
971      SymmetricTensor<2,dim, Sacado::Fad::DFad<DFadType> > eps\_fad\_squared;
972      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
973         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k )
974             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
975                 \textcolor{keywordflow}{if} ( i>=k )
976                     eps\_fad\_squared[i][k] += eps\_fad[i][j] * eps\_fad[j][k];
977 
978     \textcolor{comment}{// Compute the strain energy density}
979      Sacado::Fad::DFad<DFadType> energy;
980      energy = lambda/2. * trace(eps\_fad)*trace(eps\_fad) + mu * trace(eps\_fad\_squared) + 25 * phi\_fad * 
      trace(eps\_fad);
981 
982     \textcolor{comment}{// The energy is outputted to give some insight into the storage of the values and derivatives. \(\backslash\)n}
983     \textcolor{comment}{// energy=399 [ 17.5 32 40 21.5 48 25.5 150 ] [ 17.5 [ 5 0 0 1 0 1 25 ] 32 [ 0 8 0 0 0 0 0 ] 40 [ 0 0 8
       0 0 0 0 ]}
984     \textcolor{comment}{// 21.5 [ 1 0 0 5 0 1 25 ] 48 [ 0 0 0 0 8 0 0 ] 25.5 [ 1 0 0 1 0 5 25 ] 150 [ 25 0 0 25 0 25 0 ] ]}
985 
986      std::cout << \textcolor{stringliteral}{"energy="} << energy << std::endl;
987 
988     \textcolor{comment}{// Compute sigma as \(\backslash\)f[ \(\backslash\)boldsymbol\{\(\backslash\)sigma\} = \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\}
       \(\backslash\)f]}
989      SymmetricTensor<2,dim> sigma\_Sac;
990      eps\_fad.get\_tangent(sigma\_Sac, energy);
991      std::cout << \textcolor{stringliteral}{"sigma\_Sacado="} << sigma\_Sac << std::endl;
992 
993      \textcolor{keywordtype}{double} d\_energy\_d\_phi;
994      phi\_fad.\hyperlink{classSacado__Wrapper_1_1SW__double2_ad51ba1e79171d60861b28098dfef903d}{get\_tangent}(d\_energy\_d\_phi, energy);
995      std::cout << \textcolor{stringliteral}{"d\_energy\_d\_phi="} << d\_energy\_d\_phi << std::endl;
996 
997 
998     \textcolor{comment}{// Analytical stress tensor:}
999      SymmetricTensor<2,dim> sigma;
1000      sigma = lambda*trace(eps)*unit\_symmetric\_tensor<dim>() + 2. * mu * eps;
1001      std::cout << \textcolor{stringliteral}{"analy. sigma="} << sigma << std::endl;
1002 
1003 
1004     \textcolor{comment}{// Sacado stress tangent (or eps curvature) as \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial
       \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}^2\} \(\backslash\)f]}
1005      SymmetricTensor<4,dim> C\_Sac;
1006      eps\_fad.get\_curvature(C\_Sac, energy);
1007 
1008     \textcolor{comment}{// Sacado phi curvature as \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)varphi^2\} \(\backslash\)f]}
1009      \textcolor{keywordtype}{double} d2\_energy\_d\_phi\_2;
1010      phi\_fad.\hyperlink{classSacado__Wrapper_1_1SW__double2_a7d3f3a21cd842645af9861bf50308825}{get\_curvature}(d2\_energy\_d\_phi\_2, energy);
1011      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_phi\_2="} << d2\_energy\_d\_phi\_2 << std::endl;
1012 
1013     \textcolor{comment}{// Sacado derivatives \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\} \(\backslash\)partial \(\backslash\)varphi\}
       \(\backslash\)f]}
1014      SymmetricTensor<2,dim> d2\_energy\_d\_eps\_d\_phi;
1015      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_adf29bfda10814ecee9572a4751d34db0}{get\_curvature}(d2\_energy\_d\_eps\_d\_phi, energy, eps\_fad, phi\_fad);
1016      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_eps\_d\_phi="} << d2\_energy\_d\_eps\_d\_phi << std::endl;
1017 
1018     \textcolor{comment}{// Sacado derivatives \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)varphi \(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\}
       \(\backslash\)f]}
1019      SymmetricTensor<2,dim> d2\_energy\_d\_phi\_d\_eps;
1020      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_adf29bfda10814ecee9572a4751d34db0}{get\_curvature}(d2\_energy\_d\_phi\_d\_eps, energy, phi\_fad, eps\_fad);
1021      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_phi\_d\_eps="} << d2\_energy\_d\_phi\_d\_eps << std::endl;
1022 
1023     \textcolor{comment}{// When you consider the output: \(\backslash\)n}
1024     \textcolor{comment}{// d2\_energy\_d\_eps\_d\_phi=25 0 0 0 25 0 0 0 25 \(\backslash\)n}
1025     \textcolor{comment}{// d2\_energy\_d\_phi\_d\_eps=25 0 0 0 25 0 0 0 25 \(\backslash\)n}
1026     \textcolor{comment}{// in detail you will notice that both second derivatives are identical. This compplies with the
       Schwarz integrability condition (Symmetry of second derivatives)}
1027     \textcolor{comment}{// (ignoring all limitation and requirements), it holds}
1028     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\} \(\backslash\)partial \(\backslash\)varphi\} = \(\backslash\)frac\{\(\backslash\)partial^2
       \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)varphi \(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\}  \(\backslash\)f]}
1029 
1030     \textcolor{comment}{// Analytical stress tangent}
1031      SymmetricTensor<4,dim> C\_analy;
1032      C\_analy = lambda * outer\_product(unit\_symmetric\_tensor<dim>(), unit\_symmetric\_tensor<dim>()) + 2. * mu
       * identity\_tensor<dim>();
1033 
1034     \textcolor{comment}{// Compute the error for the stress tangent}
1035      \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
1036      \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
1037         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
1038             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
1039                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
1040                     error\_Sacado\_vs\_analy += std::fabs(C\_Sac[i][j][k][l] - C\_analy[i][j][k][l]);
1041      std::cout << \textcolor{stringliteral}{"Numerical error="} << error\_Sacado\_vs\_analy << std::endl;
1042 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+2@{sacado\+\_\+test\+\_\+2}}
\index{sacado\+\_\+test\+\_\+2@{sacado\+\_\+test\+\_\+2}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+2()}{sacado_test_2()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+2 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}{}\label{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}


Referenced by main().


\begin{DoxyCode}
67 \{
68     std::cout << \textcolor{stringliteral}{"Test 2:"} << std::endl;
69 
70     \textcolor{comment}{// First we set the dimension \(\backslash\)a dim: 2D->dim=2; 3D->dim=3 \(\backslash\)n This defines the "size" of the tensors
       and the number of dofs. Ex2 only works in 3D, whereas the following Ex3 is set up dimension-independent.}
71     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim = 3;
72 
73     \textcolor{comment}{// Declare our input, auxiliary and output variables as SymmetricTensors consisting of fad\_doubles
       (instead of the standard SymmetricTensor out of doubles)}
74     SymmetricTensor<2,dim, fad\_double> sigma, eps;
75 
76     \textcolor{comment}{// Init the strain tensor (the point at which the derivative shall be computed)}
77     eps[0][0] = 1;
78     eps[1][1] = 2;
79     eps[2][2] = 3;
80     eps[0][1] = 4;
81     eps[0][2] = 5;
82     eps[1][2] = 6;
83 
84     \textcolor{comment}{// Now we declare the dofs. The derivative to a tensor requires all components, therefore we set the
       components of the strain tensor here one by one as the dofs.}
85     \textcolor{comment}{// Because our tensors are symmetric, we only need 6 components in 3D instead of 9 for a full second
       order tensor}
86     eps[0][0].diff(0,6);
87     eps[1][1].diff(1,6);
88     eps[2][2].diff(2,6);
89     eps[0][1].diff(3,6);
90     eps[0][2].diff(4,6);
91     eps[1][2].diff(5,6);
92 
93     \textcolor{comment}{// The equation describing the stresses (here just a simple test case)}
94     sigma = eps;
95 
96     \textcolor{comment}{// Let's output the computed stress tensor.}
97     std::cout << sigma << std::endl;
98     \textcolor{comment}{// The resulting values of \(\backslash\)a sigma are fairly boring, due to our simple equation. It is the additional
       output generated by}
99     \textcolor{comment}{// this, that is interesting here: \(\backslash\)n}
100     \textcolor{comment}{// output: \(\backslash\)n}
101     \textcolor{comment}{// 1 [ 1 0 0 0 0 0 ] 4 [ 0 0 0 1 0 0 ] 5 [ 0 0 0 0 1 0 ] 4 [ 0 0 0 1 0 0 ] 2 [ 0 1 0 0 0 0 ] 6 [ 0 0 0
       0 0 1 ] 5 [ 0 0 0 0 1 0 ] 6 [ 0 0 0 0 0 1 ] 3 [ 0 0 1 0 0 0 ] \(\backslash\)n}
102     \textcolor{comment}{// The numbers 1, 4, 5, 4, ... are the entries in the stress tensor \(\backslash\)a sigma. In square brackets we see
       the derivatives of sigma with respect to all the dofs set previously}
103     \textcolor{comment}{// given in the order we defined them above. Meaning: The first entry in the square brackets
       corresponds to the 0-th dof set by}
104     \textcolor{comment}{// @code eps[0][0].diff(0,6); @endcode referring to the component (0,0) in the strain tensor \(\backslash\)a eps.}
105 
106     \textcolor{comment}{// Computing the derivatives for certain components of the resulting tangent modulus: \(\backslash\)n}
107     \textcolor{comment}{// We now access these lists of derivatives (output above in square brackets) for one component of the
       stress tensor \(\backslash\)a sigma at a time.}
108     \{
109         \textcolor{comment}{// Access the derivatives corresponding to the component (0,0) of the stress tensor \(\backslash\)a sigma}
110         \textcolor{keywordtype}{double} *derivs = &sigma[0][0].fastAccessDx(0);
111         \textcolor{comment}{// The following output will show us the same derivatives that we already saw above, just formatted
       differently \(\backslash\)n}
112         \textcolor{comment}{// output: d\_sigma[0][0]/d\_eps = 1 , 0 , 0 , 0 , 0 , 0 ,}
113         std::cout << \textcolor{stringliteral}{"d\_sigma[0][0]/d\_eps = "};
114         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<6; ++i)
115             std::cout << derivs[i] << \textcolor{stringliteral}{" , "};
116         std::cout << std::endl;
117     \}
118     \{
119         \textcolor{comment}{// Access the derivatives corresponding to the component (1,2) of the stress tensor \(\backslash\)a sigma}
120         \textcolor{keywordtype}{double} *derivs = &sigma[1][2].fastAccessDx(0);
121         \textcolor{comment}{// output: d\_sigma[1][2]/d\_eps = 0 , 0 , 0 , 0 , 0 , 1 ,}
122         std::cout << \textcolor{stringliteral}{"d\_sigma[1][2]/d\_eps = "};
123         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<6; ++i)
124             std::cout << derivs[i] << \textcolor{stringliteral}{" , "};
125         std::cout << std::endl;
126     \}
127 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+3@{sacado\+\_\+test\+\_\+3}}
\index{sacado\+\_\+test\+\_\+3@{sacado\+\_\+test\+\_\+3}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+3()}{sacado_test_3()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+3 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}{}\label{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}


Referenced by main().


\begin{DoxyCode}
132 \{
133     std::cout << \textcolor{stringliteral}{"Test 3:"} << std::endl;
134 
135     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim = 3;
136 
137     \textcolor{comment}{// Here we also define some constant, for instance the bulk modulus \(\backslash\)a kappa and the second LamÃ¨
       parameter \(\backslash\)a mu.}
138     \textcolor{comment}{// We now also define one of our constants as fad\_double. By doing this we can use the normal
       multiplication (see below).}
139     \textcolor{keywordtype}{double} kappa\_param = 5;
140     \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} kappa (kappa\_param);
141     \textcolor{comment}{// The second constant remains as a double just to show the difference.}
142     \textcolor{keywordtype}{double} mu = 2;
143 
144     SymmetricTensor<2,dim, fad\_double> sigma, eps;
145 
146     \textcolor{comment}{// To simplify the access to the dofs we define a map that relate the components of our strain tensor
       to the dof-nbr}
147     std::map<unsigned int,std::pair<unsigned int,unsigned int>> std\_map\_indicies;
148 
149     \textcolor{comment}{// The point at which the derivative shall be computed: \(\backslash\)n}
150     \textcolor{comment}{// As mentioned previously, we will implement this example for 2D and 3D, hence we once have to set up
       a strain tensor}
151     \textcolor{comment}{// and the derivatives for 3D with 6 independent components ...}
152     \textcolor{keywordflow}{if}(dim==3)
153     \{
154         eps[0][0] = 1;
155         eps[1][1] = 2;
156         eps[2][2] = 3;
157         
158         eps[0][1] = 4;
159         eps[0][2] = 5;
160         eps[1][2] = 6;
161         
162         
163         eps[0][0].diff(0,6);
164         eps[0][1].diff(1,6);
165         eps[0][2].diff(2,6);
166         eps[1][1].diff(3,6);
167         eps[1][2].diff(4,6);
168         eps[2][2].diff(5,6);
169         
170         \textcolor{comment}{// By using the map and the following pairs, we have to set up the relation between strain
       components and dofs only once}
171         \textcolor{comment}{// and can use the map to access the entries of the list later, without possibly mixing up indices
       and creating errors.}
172         \textcolor{comment}{// Please don't be confused, but the dofs in the Wrapper are set up}
173         \textcolor{comment}{// in a different order that we showed earlier. Earlier: (0,0)-(1,1)-(2,2)-...; Now:
       (0,0)-(0,1)-(0,2)-...}
174         std::pair<unsigned int, unsigned int> tmp\_pair;
175         tmp\_pair.first=0; tmp\_pair.second=0;
176         std\_map\_indicies[0] = tmp\_pair;
177 
178         tmp\_pair.first=0; tmp\_pair.second=1;
179         std\_map\_indicies[1] = tmp\_pair;
180 
181         tmp\_pair.first=0; tmp\_pair.second=2;
182         std\_map\_indicies[2] = tmp\_pair;
183 
184         tmp\_pair.first=1; tmp\_pair.second=1;
185         std\_map\_indicies[3] = tmp\_pair;
186 
187         tmp\_pair.first=1; tmp\_pair.second=2;
188         std\_map\_indicies[4] = tmp\_pair;
189 
190         tmp\_pair.first=2; tmp\_pair.second=2;
191         std\_map\_indicies[5] = tmp\_pair;
192     \}
193     \textcolor{comment}{// ... and once for 2D with just 3 independent components.}
194     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(dim==2)
195     \{
196         eps[0][0] = 1;
197         eps[1][1] = 2;
198         
199         eps[0][1] = 4;
200 
201                 
202         eps[0][0].diff(0,3);
203         eps[0][1].diff(1,3);
204         eps[1][1].diff(2,3);
205         
206         std::pair<unsigned int, unsigned int> tmp\_pair;
207         tmp\_pair.first=0; tmp\_pair.second=0;
208         std\_map\_indicies[0] = tmp\_pair;
209         
210         tmp\_pair.first=0; tmp\_pair.second=1;
211         std\_map\_indicies[1] = tmp\_pair;
212         
213         tmp\_pair.first=1; tmp\_pair.second=1;
214         std\_map\_indicies[2] = tmp\_pair;        
215     \}
216     \textcolor{keywordflow}{else}
217     \{
218         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"only dim==2 or dim==3 allowed"});
219     \}
220 
221     \textcolor{comment}{// Instead of calling the *.diff(*) on the components one-by-one we could also use the following
       for-loop, so}
222     \textcolor{comment}{// we also use the map to set the dofs (as we will do in the Wrapper later).}
223     \textcolor{comment}{// @code}
224     \textcolor{comment}{// for ( unsigned int x=0; x<((dim==2)?3:6); ++x )}
225     \textcolor{comment}{// \{}
226     \textcolor{comment}{//  unsigned int i=std\_map\_indicies[x].first;}
227     \textcolor{comment}{//  unsigned int j=std\_map\_indicies[x].second;}
228     \textcolor{comment}{//  eps[i][j].diff(x,((dim==2)?3:6));}
229     \textcolor{comment}{// \}}
230     \textcolor{comment}{// @endcode}
231 
232     \textcolor{comment}{// For our slightly more complicated stress equation we need the unit and deviatoric tensors.}
233     \textcolor{comment}{// We can simply define them by writing the values of the already existing deal.ii functions into newly}
234     \textcolor{comment}{// defined SymmetricTensors build from fad\_doubles.}
235     SymmetricTensor<2,dim, fad\_double> stdTensor\_I (( unit\_symmetric\_tensor<dim,fad\_double>()) );
236     SymmetricTensor<4,dim, fad\_double> stdTensor\_Idev ( (deviator\_tensor<dim,fad\_double>()) );
237     
238     \textcolor{comment}{// With everything set and defined, we can compute our stress \(\backslash\)a sigma according to:}
239     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)sigma = \(\backslash\)kappa \(\backslash\)cdot trace(\(\backslash\)varepsilon) \(\backslash\)cdot \(\backslash\)boldsymbol\{I\} + 2 \(\backslash\)cdot \(\backslash\)mu \(\backslash\)cdot
       \(\backslash\)varepsilon^\{dev\} \(\backslash\)f]}
240     \textcolor{comment}{// Here you can see that we can directly multiply the constant and the tensors when kappa is also
       declared as fad\_double}
241     sigma = kappa * (trace(eps) *  stdTensor\_I);
242     \textcolor{comment}{// We didn't do the same for mu to once again emphasize the difference between constants as double and
       as fad\_double. \(\backslash\)n}
243     \textcolor{comment}{// The remaining code uses a normal double constant.}
244     SymmetricTensor<2,dim,fad\_double> tmp = deviator<dim,fad\_double>(symmetrize<dim,fad\_double>(eps)); tmp*
      =(mu*2);
245     sigma +=  tmp;
246     \textcolor{comment}{// The fairly cumbersome computation is caused by the way the operators are set up for tensors out of
       fad\_doubles.}
247     
248     std::cout << \textcolor{stringliteral}{"sigma="} << sigma << std::endl;
249 
250     \textcolor{comment}{// Now we want to actually build our tangent modulus called \(\backslash\)a C\_Sacado that contains all the
       derivatives and relates}
251     \textcolor{comment}{// the stress tensor with the strain tensor. \(\backslash\)n}
252     \textcolor{comment}{// The fourth-order tensor \(\backslash\)a C\_Sacado is our final goal, we don't have to compute anything that is
       related to Sacado with}
253     \textcolor{comment}{// this tensor, so we can finally return to our standard SymmetricTensor out of doubles. The latter is
       necessary to use}
254     \textcolor{comment}{// the tangent in the actual FE code.}
255     SymmetricTensor<4,dim> C\_Sacado;
256 
257     \textcolor{comment}{// As in Ex2 we access the components of the stress tensor one by one. In order to capture all of them
       we sum over the}
258     \textcolor{comment}{// components i and j of the stress tensor.}
259     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
260         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
261         \{
262             \textcolor{keywordtype}{double} *derivs = &sigma[i][j].fastAccessDx(0); \textcolor{comment}{// Access the derivatives of the (i,j)-th
       component of \(\backslash\)a sigma}
263 
264             \textcolor{comment}{// To visually ensure that every stress component has in fact all 6 derivatives for 3D or 3 for
       2D, we output the size:}
265             std::cout<<\textcolor{stringliteral}{"size: "}<<sigma[i][j].size()<<std::endl;
266 
267             \textcolor{comment}{// We loop over all the dofs. To be able to use this independent of the chosen dimension \(\backslash\)a
       dim, we use a ternary operator}
268             \textcolor{comment}{// to decide whether we have to loop over 6 derivatives or just 3.}
269             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0;x<((dim==2)?3:6);++x)
270             \{
271                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=std\_map\_indicies[x].first;
272                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=std\_map\_indicies[x].second;
273 
274                 \textcolor{keywordflow}{if}(k!=l)\textcolor{comment}{/*Compare to Voigt notation since only SymmetricTensor instead of Tensor*/}
275                 \{
276                     C\_Sacado[i][j][k][l] = 0.5*derivs[x];
277                     C\_Sacado[i][j][l][k] = 0.5*derivs[x];
278                 \}
279                 \textcolor{keywordflow}{else}
280                     C\_Sacado[i][j][k][l] = derivs[x];
281             \}            
282             
283         \}
284 
285     \textcolor{comment}{// After resembling the fourth-order tensor, we now have got our tangent saved in \(\backslash\)a C\_Sacado ready to
       be used}
286 
287     \textcolor{comment}{// To ensure that Sacado works properly, we can compute the analytical tangent for comparison}
288     \textcolor{keywordtype}{double} kappa\_d = 5;
289     \textcolor{keywordtype}{double} mu\_d = 2;
290     \textcolor{comment}{// Our stress equation in this example is still simple enough to derive the tangent analytically by
       hand:}
291     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)overset\{4\}\{C\_\{analy\}\} = \(\backslash\)kappa \(\backslash\)cdot \(\backslash\)boldsymbol\{I\} \(\backslash\)otimes \(\backslash\)boldsymbol\{I\} + 2 \(\backslash\)cdot \(\backslash\)mu \(\backslash\)cdot
       \(\backslash\)overset\{4\}\{I^\{dev\}\} \(\backslash\)f]}
292     SymmetricTensor<4,dim> C\_analy = kappa\_d * outer\_product(unit\_symmetric\_tensor<dim>(), 
      unit\_symmetric\_tensor<dim>()) + 2* mu\_d * deviator\_tensor<dim>();
293 
294 
295     \textcolor{comment}{// We again define our strain tensor \(\backslash\)a eps\_d (*\_d for standard double in contrast to fad\_double)}
296     SymmetricTensor<2,dim> eps\_d;
297     
298     \textcolor{keywordflow}{if}(dim==3)
299     \{
300         eps\_d[0][0] = 1;
301         eps\_d[1][1] = 2;
302         eps\_d[2][2] = 3;
303         
304         eps\_d[0][1] = 4;
305         eps\_d[0][2] = 5;
306         eps\_d[2][1] = 6;
307 
308     \}
309     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(dim==2)
310     \{
311         eps\_d[0][0] = 1;
312         eps\_d[1][1] = 2;
313         
314         eps\_d[1][0] = 4;
315         
316     \}
317     \textcolor{keywordflow}{else}
318     \{
319         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"only dim==2 or dim==3 allowed"});
320     \}
321     \textcolor{comment}{// @todo use boldsymbol for tensors}
322     \textcolor{comment}{//}
323     \textcolor{comment}{// To output the stress tensor we first have to compute it. We do this here via}
324     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)sigma = \(\backslash\)overset\{4\}\{C\_\{analy\}\} : \(\backslash\)varepsilon \(\backslash\)f]}
325     \textcolor{comment}{// The output exactly matched the result obtained with Sacado.}
326     \textcolor{comment}{// @note Checking the Sacado stress tensor against an analytically computed or otherwise determined
       stress tensor is absolutely no way to check whether}
327     \textcolor{comment}{// the tangent computed via Sacado is correct. When we compute the stress tensor with Sacado and for
       example mix up a + and - sign, this might not matter}
328     \textcolor{comment}{// at all if the number that is added or subtracted is small. However, for the tangent this nasty sign
       can be very critical. Just keep in mind: the}
329     \textcolor{comment}{// tangent has 81 components and the stress tensor just 9, so how does one want to verify 81 variables
       by comparing 9?}
330     \textcolor{comment}{//}
331     std::cout << \textcolor{stringliteral}{"sigma\_analy: "} << (C\_analy*eps\_d) << std::endl;
332     
333     \textcolor{comment}{// That's the reason we compare all the entries in the Sacado and the analytical tensor one by one}
334     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
335         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
336             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
337                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
338                     std::cout << \textcolor{stringliteral}{"C\_analy["}<<i<<\textcolor{stringliteral}{"]["}<<j<<\textcolor{stringliteral}{"]["}<<k<<\textcolor{stringliteral}{"]["}<<l<<\textcolor{stringliteral}{"] = "} << C\_analy[i][j][k][l] <<
       \textcolor{stringliteral}{" vs C\_Sacado: "} << C\_Sacado[i][j][k][l] << std::endl;
339 
340 
341     \textcolor{comment}{// To simplify the comparison we compute a scalar error as the sum of the absolute differences of each
       component}
342     \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
343     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
344         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
345             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
346                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
347                     error\_Sacado\_vs\_analy += std::fabs(C\_Sacado[i][j][k][l] - C\_analy[i][j][k][l]);
348                     
349 
350     \textcolor{comment}{// As desired: The numerical error is zero (0 in double precision) and the tensor components are equal}
351     std::cout << \textcolor{stringliteral}{"numerical error: "} << error\_Sacado\_vs\_analy << std::endl;
352 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+3B@{sacado\+\_\+test\+\_\+3B}}
\index{sacado\+\_\+test\+\_\+3B@{sacado\+\_\+test\+\_\+3B}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+3\+B()}{sacado_test_3B()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+3B (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}{}\label{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}


References Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::get\+\_\+tangent(), Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::init(), and Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::set\+\_\+dofs().



Referenced by main().


\begin{DoxyCode}
357 \{
358     std::cout << \textcolor{stringliteral}{"Test 3B:"} << std::endl;
359     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
360 
361     \textcolor{comment}{// The following declarations are usually input arguments. So you receive the strain tensor and the
       constants out of doubles.}
362     SymmetricTensor<2,dim> eps\_d;
363     eps\_d[0][0] = 1;
364     eps\_d[1][1] = 2;
365     eps\_d[2][2] = 3;
366 
367     eps\_d[0][1] = 4;
368     eps\_d[0][2] = 5;
369     eps\_d[1][2] = 6;
370 
371     \textcolor{keywordtype}{double} kappa = 5;
372     \textcolor{keywordtype}{double} mu = 2;
373 
374     \textcolor{comment}{// Now we start working with Sacado: \(\backslash\)n}
375     \textcolor{comment}{// When we use the index notation to compute e.g. our stress we do not need to declare our constants
       (here kappa, mu) as}
376     \textcolor{comment}{// fad\_double.}
377 
378     \textcolor{comment}{// We declare our strain tensor as the special data type Sacado\_Wrapper::SymTensor from the file
       "Sacado\_Wrapper.h"}
379     \textcolor{comment}{// where this data type was derived from the SymmetricTensor<2,dim,fad\_double>.}
380      \hyperlink{classSacado__Wrapper_1_1SymTensor}{Sacado\_Wrapper::SymTensor<dim>} eps;
381 
382     \textcolor{comment}{// Next we initialize our Sacado strain tensor with the values of the inputed double strain tensor:}
383      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_acbad579d5ead9e96ff46aa15d9b5aef4}{init}(eps\_d);
384 
385     \textcolor{comment}{// We define all the entries in the symmetric tensor \(\backslash\)a eps as the dofs. So we can later derive any
       variable}
386     \textcolor{comment}{// with respect to the strain tensor \(\backslash\)a eps.}
387      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_aa9e0fcc9d4e0a4120bedb8ef9b8d7ecb}{set\_dofs}();
388 
389     \textcolor{comment}{// Now we declare our output and auxiliary variables as Sacado-Tensors.}
390      SymmetricTensor<2,dim,fad\_double> sigma;
391 
392      SymmetricTensor<2,dim, fad\_double> stdTensor\_I (( unit\_symmetric\_tensor<dim,fad\_double>()) );
393 
394      \textcolor{comment}{// Our stress equation is now computed in index notation to simplify the use of the constants and}
395      \textcolor{comment}{// especially the use of the \(\backslash\)a deviator.}
396       \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
397         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
398             sigma[i][j] = kappa * trace(eps) *  stdTensor\_I[i][j] + 2. * mu * deviator(eps)[i][j];
399 
400     \textcolor{comment}{// Finally we declare our desired tangent as the fourth order tensor \(\backslash\)a C\_Sacado and compute the
       tangent via}
401     \textcolor{comment}{// the command \(\backslash\)a get\_tangent.}
402      SymmetricTensor<4,dim> C\_Sacado;
403      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ab97427c3b5cab279e58607cf431ab262}{get\_tangent}(C\_Sacado, sigma);
404 
405     \textcolor{comment}{// We could again compare the herein computed tangent with the analytical tangent from Ex2, but as
       before}
406     \textcolor{comment}{// the results are fairly boring, because Sacado hits the analytical tangent exactly --- no surprise
       for such}
407     \textcolor{comment}{// simple equations.}
408 
409     \textcolor{comment}{// And that's it. By using the Sacado\_wrapper we can achieve everything from Ex2 (besides the
       equations)}
410     \textcolor{comment}{// with just four lines of code namely:}
411     \textcolor{comment}{// - eps.init(eps\_d);    // To initialize the Sacado strain tensor}
412     \textcolor{comment}{// - eps.set\_dofs();     // To declare the components of eps as the dofs}
413     \textcolor{comment}{// - eps.get\_tangent(*); // To get the tangent}
414 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+4@{sacado\+\_\+test\+\_\+4}}
\index{sacado\+\_\+test\+\_\+4@{sacado\+\_\+test\+\_\+4}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+4()}{sacado_test_4()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+4 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}{}\label{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}


References Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::get\+\_\+tangent(), Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double$<$ dim $>$\+::get\+\_\+tangent(), Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::init(), Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double$<$ dim $>$\+::init(), and Sacado\+\_\+\+Wrapper\+::\+Do\+Fs\+\_\+summary$<$ dim $>$\+::set\+\_\+dofs().



Referenced by main().


\begin{DoxyCode}
419 \{
420     std::cout << \textcolor{stringliteral}{"Test 4:"} << std::endl;
421     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
422 
423     \textcolor{comment}{// The following declarations are usually input arguments. So you receive the strain tensor \(\backslash\)q eps\_d,}
424     \textcolor{comment}{// the damage variable \(\backslash\)a phi and the constants \(\backslash\)a kappa and \(\backslash\)a mu out of doubles.}
425     SymmetricTensor<2,dim> eps\_d;
426     eps\_d[0][0] = 1;
427     eps\_d[1][1] = 2;
428     eps\_d[2][2] = 3;
429 
430     eps\_d[0][1] = 4;
431     eps\_d[0][2] = 5;
432     eps\_d[1][2] = 6;
433 
434     \textcolor{keywordtype}{double} phi\_d = 0.3;
435 
436     \textcolor{comment}{// We don't need these constants in the current example.}
437     \textcolor{comment}{// double kappa = 5;}
438     \textcolor{comment}{// double mu = 2;}
439 
440 
441     \textcolor{comment}{// We set up our strain tensor as in Ex3B.}
442      \hyperlink{classSacado__Wrapper_1_1SymTensor}{Sacado\_Wrapper::SymTensor<dim>} eps;
443      \hyperlink{classSacado__Wrapper_1_1SW__double}{Sacado\_Wrapper::SW\_double<dim>} phi;
444 
445     \textcolor{comment}{// Initialize the strain tensor and the damage variable}
446      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_acbad579d5ead9e96ff46aa15d9b5aef4}{init}(eps\_d);
447      phi.\hyperlink{classSacado__Wrapper_1_1SW__double_adca799dd92dadebda9aebc91c797682a}{init}(phi\_d);
448 
449      \textcolor{comment}{// Set the dofs, where the argument sets the total nbr of dofs (3 or 6 for the sym. tensor and 1 for
       the double)}
450 \textcolor{comment}{//    eps.set\_dofs(eps.n\_independent\_components+1/*an additional dof for phi*/);}
451 \textcolor{comment}{//}
452      \textcolor{comment}{// In order to also compute derivatives with respect to the scalar \(\backslash\)a phi, we add this scalar to our
       list}
453      \textcolor{comment}{// of derivatives. Because we have already defined 3 or 6 dofs our additional dof will be placed at
       the end}
454      \textcolor{comment}{// of this list. We set this up with the member variable start\_index ...}
455 \textcolor{comment}{//    phi.start\_index=eps.n\_independent\_components;}
456      \textcolor{comment}{// and again using the input argument representing the total number of dofs}
457 \textcolor{comment}{//    phi.set\_dofs(eps.n\_independent\_components+1);}
458 
459     \textcolor{comment}{// All of the above 3 lines of code are automatically done by the DoFs\_summary class. So, to}
460     \textcolor{comment}{// set our dofs we just create an instance and call set\_dofs with our variables containing the desired
       dofs.}
461      \hyperlink{classSacado__Wrapper_1_1DoFs__summary}{Sacado\_Wrapper::DoFs\_summary<dim>} DoFs\_summary;
462      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_a556293f6e683cb30151d9faadc2cc90d}{set\_dofs}(eps, phi);
463 
464 
465     \textcolor{comment}{// Compute the stress tensor and damage variable \(\backslash\)a d (here we just use some arbitrary equations for
       testing): \(\backslash\)n}
466      \textcolor{comment}{// Let us first declare our output (and auxiliary) variables as Sacado data types.}
467       SymmetricTensor<2,dim,fad\_double> sigma;
468       \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} d;
469      \textcolor{comment}{// @todo It would be nice to use the data types from the Sacado\_Wrapper for all the Sacado variables.
       But}
470      \textcolor{comment}{// somehow the operators (multiply*, ...) seem to cause conflicts again.}
471 
472      \textcolor{comment}{// The actual computation in the following scope uses the exact same equation as your normal
       computation e. g. via the data type double.}
473      \textcolor{comment}{// Hence, you could either directly compute your stress, etc. via the Sacado variables or you define}
474      \textcolor{comment}{// template functions that contain your equations and are either called templated with double or
       fad\_double.}
475      \textcolor{comment}{// When using the first option, please consider the computation time that is generally higher for a
       computation}
476      \textcolor{comment}{// with fad\_double than with normal doubles (own experience in a special case: slower by factor 30).}
477      \textcolor{comment}{// The second option with templates does not suffer these issues.}
478       \{
479       \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
480         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
481             sigma[i][j] = phi * eps[i][j];
482              \textcolor{comment}{// ToDo: strangely when phi is a fad\_double then the multiplication phi * eps works directly
       without}
483              \textcolor{comment}{// having to use the index notation}
484       std::cout << \textcolor{stringliteral}{"sigma="} << sigma << std::endl;
485 
486       d = phi*phi + 25 + trace(eps);
487       std::cout << \textcolor{stringliteral}{"d="} << d << std::endl;
488       \}
489 
490 
491     \textcolor{comment}{// Get the tangents}
492      \textcolor{comment}{// d\_sigma / d\_eps: SymmetricTensor with respect to SymmetricTensor}
493       SymmetricTensor<4,dim> C\_Sacado;
494       eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ab97427c3b5cab279e58607cf431ab262}{get\_tangent}(C\_Sacado, sigma);
495       std::cout << \textcolor{stringliteral}{"C\_Sacado="} << C\_Sacado << std::endl;
496 
497      \textcolor{comment}{// Compute the analytical tangent:}
498       SymmetricTensor<4,dim> C\_analy;
499       C\_analy = phi\_d * identity\_tensor<dim>();
500       std::cout << \textcolor{stringliteral}{"C\_analy ="} << C\_analy << std::endl;
501 
502      \textcolor{comment}{// d\_d / d\_eps: double with respect to SymmetricTensor}
503       SymmetricTensor<2,dim> d\_d\_d\_eps;
504       eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ab97427c3b5cab279e58607cf431ab262}{get\_tangent}(d\_d\_d\_eps, d);
505       std::cout << \textcolor{stringliteral}{"d\_d\_d\_eps="} << d\_d\_d\_eps << std::endl;
506 
507      \textcolor{comment}{// d\_sigma / d\_phi: SymmetricTensor with respect to double}
508       SymmetricTensor<2,dim> d\_sigma\_d\_phi;
509       phi.\hyperlink{classSacado__Wrapper_1_1SW__double_a2e6eca4457eb22b06172bb5749038f1e}{get\_tangent}(d\_sigma\_d\_phi, sigma);
510       std::cout << \textcolor{stringliteral}{"d\_sigma\_d\_phi="} << d\_sigma\_d\_phi << std::endl;
511       std::cout << \textcolor{stringliteral}{"sigma = d\_sigma\_d\_phi * phi = "} << d\_sigma\_d\_phi * phi\_d << std::endl;
512 
513      \textcolor{comment}{// d\_d / d\_phi: double with respect to double}
514       \textcolor{keywordtype}{double} d\_d\_d\_phi;
515       phi.\hyperlink{classSacado__Wrapper_1_1SW__double_a2e6eca4457eb22b06172bb5749038f1e}{get\_tangent}(d\_d\_d\_phi, d);
516       std::cout << \textcolor{stringliteral}{"d\_d\_d\_phi="} << d\_d\_d\_phi << std::endl;
517 
518     \textcolor{comment}{// And that's it. By using the Sacado\_wrapper we can compute derivatives with respect to}
519     \textcolor{comment}{// a tensor and a scalar at the same time (besides the equations)}
520     \textcolor{comment}{// in essence with just the following lines of code namely:}
521     \textcolor{comment}{// - eps.init(eps\_d); phi.init(phi\_d);   // To initialize the Sacado strain tensor and scalar damage
       variable}
522     \textcolor{comment}{// - DoFs\_summary.set\_dofs(eps, phi);    // To declare the components of eps and phi as the dofs}
523     \textcolor{comment}{// - eps.get\_tangent(*); // To get tangents with respect to eps}
524     \textcolor{comment}{// - phi.get\_tangent(*); // To get tangents with respect to phi}
525 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+5@{sacado\+\_\+test\+\_\+5}}
\index{sacado\+\_\+test\+\_\+5@{sacado\+\_\+test\+\_\+5}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+5()}{sacado_test_5()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+5 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}{}\label{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}


Referenced by main().


\begin{DoxyCode}
531 \{
532     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
533     std::cout << \textcolor{stringliteral}{"Test 5:"} << std::endl;
534     Tensor<1,dim,fad\_double> c;
535     \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} a,b;
536     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n\_dofs=2;
537     a = 1; b = 2;   \textcolor{comment}{// at the point (a,b) = (1,2)}
538     a.diff(0,2);  \textcolor{comment}{// Set a to be dof 0, in a 2-dof system.}
539     b.diff(1,2);  \textcolor{comment}{// Set b to be dof 1, in a 2-dof system.}
540     \textcolor{comment}{// c is now a vector with three components}
541     c[0] = 2*a+3*b;
542     c[1] = 4*a+5*b;
543     c[2] = 6*a+7*b;
544     
545     \textcolor{comment}{// Access to the derivatives works as before.}
546     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<dim;++i)
547     \{
548         \textcolor{keyword}{const} \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} &derivs = c[i]; \textcolor{comment}{// Access derivatives}
549         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0;j<n\_dofs;++j)
550         \{
551             std::cout << \textcolor{stringliteral}{"Derivatives at the point ("} << a << \textcolor{stringliteral}{","} << b << \textcolor{stringliteral}{") for "}
552             <<i<<\textcolor{stringliteral}{"th component wrt "}<<j<<\textcolor{stringliteral}{"th direction "}<< std::endl;
553             std::cout << \textcolor{stringliteral}{"dc\_i/dxj = "} << derivs.fastAccessDx(j) << std::endl;            
554         \}
555     \}
556 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+6@{sacado\+\_\+test\+\_\+6}}
\index{sacado\+\_\+test\+\_\+6@{sacado\+\_\+test\+\_\+6}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+6()}{sacado_test_6()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+6 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}{}\label{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}


Referenced by main().


\begin{DoxyCode}
564 \{
565     std::cout << \textcolor{stringliteral}{"Test 6:"} << std::endl;
566     \textcolor{comment}{// define the variables used in the computation (inputs: a, b; output: c; auxiliaries: *) as the
       Sacado-data type}
567      \textcolor{keywordtype}{double} a=1;
568      \textcolor{keywordtype}{double} b=2;
569 
570     \textcolor{comment}{// Number of independent variables}
571      \textcolor{keywordtype}{int} num\_dofs = 2;
572 
573     \textcolor{keyword}{typedef} Sacado::Fad::DFad<double> \hyperlink{Sacado__Wrapper_8h_a7e0893207b87dad05c66a34baac8ed2e}{DFadType};
574     Sacado::Fad::DFad<DFadType> afad(num\_dofs, 0, a);
575     Sacado::Fad::DFad<DFadType> bfad(num\_dofs, 1, b);
576     Sacado::Fad::DFad<DFadType> cfad;
577 
578     std::cout << \textcolor{stringliteral}{"afad="} << afad << std::endl;
579     std::cout << \textcolor{stringliteral}{"bfad="} << bfad << std::endl;
580     std::cout << \textcolor{stringliteral}{"cfad="} << cfad << std::endl;
581 
582     afad.val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(num\_dofs, 0, a); \textcolor{comment}{// set afad.val() as the first dof and init it with
       the double a}
583     bfad.val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(num\_dofs, 1, b);
584 
585     \textcolor{comment}{// Compute function and derivative with AD}
586      cfad = 2*afad + std::cos(afad*bfad);
587 
588         std::cout << \textcolor{stringliteral}{"afad="} << afad << std::endl;
589         std::cout << \textcolor{stringliteral}{"bfad="} << bfad << std::endl;
590         std::cout << \textcolor{stringliteral}{"cfad="} << cfad << std::endl;
591 
592     \textcolor{comment}{// Extract value and derivatives}
593     \textcolor{keywordtype}{double} c\_ad = cfad.val().val();       \textcolor{comment}{// r}
594     \textcolor{keywordtype}{double} dcda\_ad = cfad.dx(0).val();    \textcolor{comment}{// dr/da}
595     \textcolor{keywordtype}{double} dcdb\_ad = cfad.dx(1).val();    \textcolor{comment}{// dr/db}
596     \textcolor{keywordtype}{double} d2cda2\_ad = cfad.dx(0).dx(0);  \textcolor{comment}{// d^2r/da^2}
597     \textcolor{keywordtype}{double} d2cdadb\_ad = cfad.dx(0).dx(1); \textcolor{comment}{// d^2r/dadb}
598     \textcolor{keywordtype}{double} d2cdbda\_ad = cfad.dx(1).dx(0); \textcolor{comment}{// d^2r/dbda}
599     \textcolor{keywordtype}{double} d2cdb2\_ad = cfad.dx(1).dx(1);  \textcolor{comment}{// d^2/db^2}
600 
601 
602     std::cout << \textcolor{stringliteral}{"cfad="} << cfad << std::endl;
603     std::cout << \textcolor{stringliteral}{"c\_ad="} << c\_ad << std::endl;
604 
605     std::cout << \textcolor{stringliteral}{"Derivatives at the point ("} << a << \textcolor{stringliteral}{","} << b << \textcolor{stringliteral}{")"} << std::endl;
606     std::cout << \textcolor{stringliteral}{"dc/da = "} << dcda\_ad << \textcolor{stringliteral}{", dc/db="} << dcdb\_ad << std::endl;
607     std::cout << \textcolor{stringliteral}{"dÂ²c/daÂ² = "} << d2cda2\_ad << \textcolor{stringliteral}{", dÂ²c/dbÂ²="} << d2cdb2\_ad << std::endl;
608     std::cout << \textcolor{stringliteral}{"dÂ²c/dadb = "} << d2cdadb\_ad << \textcolor{stringliteral}{", dÂ²c/dbda="} << d2cdbda\_ad << std::endl;
609 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+7@{sacado\+\_\+test\+\_\+7}}
\index{sacado\+\_\+test\+\_\+7@{sacado\+\_\+test\+\_\+7}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+7()}{sacado_test_7()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+7 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}{}\label{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}


Referenced by main().


\begin{DoxyCode}
616 \{
617     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
618 
619     std::cout << \textcolor{stringliteral}{"Test 7:"} << std::endl;
620 
621      SymmetricTensor<2,dim, double> eps;
622 
623      eps[0][0] = 1.;
624      eps[1][1] = 2.;
625      eps[2][2] = 3.;
626 
627      eps[0][1] = 4.;
628      eps[0][2] = 5.;
629      eps[1][2] = 6.;
630 
631 
632 
633     \textcolor{comment}{// Number of independent variables}
634      \textcolor{keywordtype}{int} nbr\_dofs = 6;
635 
636     \textcolor{keyword}{typedef} Sacado::Fad::DFad<double> \hyperlink{Sacado__Wrapper_8h_a7e0893207b87dad05c66a34baac8ed2e}{DFadType};
637      SymmetricTensor<2,dim, Sacado::Fad::DFad<DFadType> > eps\_fad;
638 
639 
640     (eps\_fad[0][0]).diff( 0, nbr\_dofs); \textcolor{comment}{// set up the "inner" derivatives}
641     (eps\_fad[0][0]).val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, 0, eps[0][0]); \textcolor{comment}{// set up the "outer" derivatives}
642 
643     (eps\_fad[1][1]).diff( 1, nbr\_dofs);
644     (eps\_fad[1][1]).val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, 1, eps[1][1]); \textcolor{comment}{// set up the "outer" derivatives}
645 
646     (eps\_fad[2][2]).diff( 2, nbr\_dofs);
647     (eps\_fad[2][2]).val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, 2, eps[2][2]); \textcolor{comment}{// set up the "outer" derivatives}
648 
649     (eps\_fad[0][1]).diff( 3, nbr\_dofs);
650     (eps\_fad[0][1]).val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, 3, eps[0][1]); \textcolor{comment}{// set up the "outer" derivatives}
651 
652     (eps\_fad[0][2]).diff( 4, nbr\_dofs);
653     (eps\_fad[0][2]).val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, 4, eps[0][2]); \textcolor{comment}{// set up the "outer" derivatives}
654 
655     (eps\_fad[1][2]).diff( 5, nbr\_dofs);
656     (eps\_fad[1][2]).val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, 5, eps[1][2]); \textcolor{comment}{// set up the "outer" derivatives}
657 
658     std::cout << eps\_fad << std::endl;
659 
660      SymmetricTensor<2,dim, Sacado::Fad::DFad<DFadType> > sigma;
661 
662 
663     \textcolor{comment}{// Compute function and derivative with AD}
664     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
665         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
666             sigma[i][j] = 25 * trace(eps\_fad)*trace(eps\_fad) + eps\_fad[i][j];
667 
668     std::cout << \textcolor{stringliteral}{"sigma="} << sigma << std::endl;
669 
670     \textcolor{keywordtype}{double} d\_sigma00\_d\_eps00 = sigma[0][0].dx(0).val();
671     \textcolor{keywordtype}{double} d2\_sigma00\_d\_eps00\_2 = sigma[0][0].dx(0).dx(0);
672     \textcolor{comment}{//double d2\_sigma00\_d\_eps11\_2 = sigma[0][0].dx(0).dx(1);}
673 
674     std::cout << \textcolor{stringliteral}{"d\_sigma00\_d\_eps00 = "} << d\_sigma00\_d\_eps00 << \textcolor{stringliteral}{", d2\_sigma00\_d\_eps00\_2 = "} << 
      d2\_sigma00\_d\_eps00\_2 << std::endl;
675 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+8@{sacado\+\_\+test\+\_\+8}}
\index{sacado\+\_\+test\+\_\+8@{sacado\+\_\+test\+\_\+8}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+8()}{sacado_test_8()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+8 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}{}\label{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}


Referenced by main().


\begin{DoxyCode}
682 \{
683     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
684 
685     std::cout << \textcolor{stringliteral}{"Test 8:"} << std::endl;
686 
687     \textcolor{comment}{// Defining the inputs (material parameters, strain tensor)}
688      \textcolor{keywordtype}{double} lambda=1;
689      \textcolor{keywordtype}{double} mu=2;
690      SymmetricTensor<2,dim, double> eps;
691      \textcolor{keywordtype}{double} phi=0.3;
692 
693      eps[0][0] = 1.;
694      eps[1][1] = 2.;
695      eps[2][2] = 3.;
696 
697      eps[0][1] = 4.;
698      eps[0][2] = 5.;
699      eps[1][2] = 6.;
700 
701     \textcolor{comment}{// Setup of the map relating the indices}
702      std::map<unsigned int,std::pair<unsigned int,unsigned int>> std\_map\_indicies;
703 
704      std::pair<unsigned int, unsigned int> tmp\_pair;
705      tmp\_pair.first=0; tmp\_pair.second=0;
706      std\_map\_indicies[0] = tmp\_pair;
707 
708      tmp\_pair.first=0; tmp\_pair.second=1;
709      std\_map\_indicies[1] = tmp\_pair;
710 
711      tmp\_pair.first=0; tmp\_pair.second=2;
712      std\_map\_indicies[2] = tmp\_pair;
713 
714      tmp\_pair.first=1; tmp\_pair.second=1;
715      std\_map\_indicies[3] = tmp\_pair;
716 
717      tmp\_pair.first=1; tmp\_pair.second=2;
718      std\_map\_indicies[4] = tmp\_pair;
719 
720      tmp\_pair.first=2; tmp\_pair.second=2;
721      std\_map\_indicies[5] = tmp\_pair;
722 
723     \textcolor{comment}{// Number of independent variables}
724      \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nbr\_dofs = 6+1;
725 
726     \textcolor{comment}{// Declaring the special data types containing all derivatives}
727      \textcolor{keyword}{typedef} Sacado::Fad::DFad<double> \hyperlink{Sacado__Wrapper_8h_a7e0893207b87dad05c66a34baac8ed2e}{DFadType};
728      SymmetricTensor<2,dim, Sacado::Fad::DFad<DFadType> > eps\_fad, eps\_fad\_squared;
729      Sacado::Fad::DFad<DFadType> phi\_fad;
730 
731 
732     \textcolor{comment}{// Setting the dofs}
733      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0; x<6; ++x )
734      \{
735         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=std\_map\_indicies[x].first;
736         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=std\_map\_indicies[x].second;
737         (eps\_fad[i][j]).diff( x, nbr\_dofs); \textcolor{comment}{// set up the "inner" derivatives}
738         (eps\_fad[i][j]).val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, x, eps[i][j]); \textcolor{comment}{// set up the "outer"
       derivatives}
739      \}
740 
741      phi\_fad.diff( 6, nbr\_dofs );
742      phi\_fad.val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, 6, phi); \textcolor{comment}{// set up the "outer" derivatives}
743 
744      std::cout << \textcolor{stringliteral}{"eps\_fad="} << eps\_fad << std::endl;
745      std::cout << \textcolor{stringliteral}{"phi\_fad="} << phi\_fad << std::endl;
746 
747     \textcolor{comment}{// Compute epsÂ² = eps\_ij * eps\_jk in index notation}
748      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
749         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k )
750             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
751                 \textcolor{keywordflow}{if} ( i>=k )
752                     eps\_fad\_squared[i][k] += eps\_fad[i][j] * eps\_fad[j][k];
753 
754     \textcolor{comment}{// Compute the strain energy density}
755      Sacado::Fad::DFad<DFadType> energy;
756      energy = lambda/2. * trace(eps\_fad)*trace(eps\_fad) + mu * trace(eps\_fad\_squared) + 25 * phi\_fad * 
      trace(eps\_fad);
757 
758     \textcolor{comment}{// Give some insight into the storage of the values and derivatives}
759      std::cout << \textcolor{stringliteral}{"energy="} << energy << std::endl;
760 
761     \textcolor{comment}{// Compute sigma as \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\} \(\backslash\)f]}
762      SymmetricTensor<2,dim> sigma\_Sac;
763      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0; x<6; ++x )
764      \{
765         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=std\_map\_indicies[x].first;
766         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=std\_map\_indicies[x].second;
767         \textcolor{keywordflow}{if} ( i!=j )
768             sigma\_Sac[i][j] = 0.5 * energy.dx(x).val();
769         \textcolor{keywordflow}{else}
770             sigma\_Sac[i][j] = energy.dx(x).val();
771      \}
772      std::cout << \textcolor{stringliteral}{"sigma\_Sacado="} << sigma\_Sac << std::endl;
773 
774      \textcolor{keywordtype}{double} d\_energy\_d\_phi = energy.dx(6).val();
775      std::cout << \textcolor{stringliteral}{"d\_energy\_d\_phi="} << d\_energy\_d\_phi << std::endl;
776 
777     \textcolor{comment}{// Analytical stress tensor:}
778      SymmetricTensor<2,dim> sigma;
779      sigma = lambda*trace(eps)*unit\_symmetric\_tensor<dim>() + 2. * mu * eps;
780      std::cout << \textcolor{stringliteral}{"analy. sigma="} << sigma << std::endl;
781 
782 
783     \textcolor{comment}{// Sacado-Tangent}
784      SymmetricTensor<4,dim> C\_Sac;
785      \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0;x<6;++x)
786         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} y=0;y<6;++y)
787         \{
788             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=std\_map\_indicies[y].first;
789             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=std\_map\_indicies[y].second;
790             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=std\_map\_indicies[x].first;
791             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=std\_map\_indicies[x].second;
792 
793             \textcolor{keywordtype}{double} deriv = energy.dx(x).dx(y); \textcolor{comment}{// Access the derivatives of the (i,j)-th component of \(\backslash\)a
       sigma}
794 
795             \textcolor{keywordflow}{if} ( k!=l && i!=j )
796                 C\_Sac[i][j][k][l] = 0.25* deriv;
797             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(k!=l)\textcolor{comment}{/*Compare to Voigt notation since only SymmetricTensor instead of Tensor*/}
798             \{
799                 C\_Sac[i][j][k][l] = 0.5*deriv;
800                 C\_Sac[i][j][l][k] = 0.5*deriv;
801             \}
802             \textcolor{keywordflow}{else}
803                 C\_Sac[i][j][k][l] = deriv;
804         \}
805 
806      \textcolor{keywordtype}{double} d2\_energy\_d\_phi\_2 = energy.dx(6).dx(6);
807      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_phi\_2="} << d2\_energy\_d\_phi\_2 << std::endl;
808 
809      SymmetricTensor<2,dim> d2\_energy\_d\_eps\_d\_phi;
810 
811      SymmetricTensor<2,dim, Sacado::Fad::DFad<DFadType> > sigma\_Sac\_full;
812      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0; x<6; ++x )
813      \{
814         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=std\_map\_indicies[x].first;
815         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=std\_map\_indicies[x].second;
816         \textcolor{keywordflow}{if} ( i!=j )
817             sigma\_Sac\_full[i][j] = 0.5 * energy.dx(x);
818         \textcolor{keywordflow}{else}
819             sigma\_Sac\_full[i][j] = energy.dx(x);
820      \}
821 
822      std::cout << \textcolor{stringliteral}{"sigma\_Sac\_full="} << sigma\_Sac\_full << std::endl;
823      d2\_energy\_d\_eps\_d\_phi[0][0] = sigma\_Sac\_full[0][0].val().dx(6);
824      d2\_energy\_d\_eps\_d\_phi[1][1] = sigma\_Sac\_full[1][1].val().dx(6);
825      d2\_energy\_d\_eps\_d\_phi[2][2] = sigma\_Sac\_full[2][2].val().dx(6);
826      d2\_energy\_d\_eps\_d\_phi[0][1] = sigma\_Sac\_full[0][1].val().dx(6);
827      d2\_energy\_d\_eps\_d\_phi[0][2] = sigma\_Sac\_full[0][2].val().dx(6);
828      d2\_energy\_d\_eps\_d\_phi[1][2] = sigma\_Sac\_full[1][2].val().dx(6);
829 
830      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_eps\_d\_phi="} << d2\_energy\_d\_eps\_d\_phi << std::endl;
831 
832      SymmetricTensor<2,dim> d2\_energy\_d\_phi\_d\_eps;
833      d2\_energy\_d\_phi\_d\_eps[0][0] = energy.dx(6).dx(0);
834      d2\_energy\_d\_phi\_d\_eps[0][1] = energy.dx(6).dx(1);
835      d2\_energy\_d\_phi\_d\_eps[0][2] = energy.dx(6).dx(2);
836      d2\_energy\_d\_phi\_d\_eps[1][1] = energy.dx(6).dx(3);
837      d2\_energy\_d\_phi\_d\_eps[1][2] = energy.dx(6).dx(4);
838      d2\_energy\_d\_phi\_d\_eps[2][2] = energy.dx(6).dx(5);
839      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_phi\_d\_eps="} << d2\_energy\_d\_phi\_d\_eps << std::endl;
840 
841 
842     \textcolor{comment}{// Analytical tangent}
843      SymmetricTensor<4,dim> C\_analy;
844      C\_analy = lambda * outer\_product(unit\_symmetric\_tensor<dim>(), unit\_symmetric\_tensor<dim>()) + 2. * mu
       * identity\_tensor<dim>();
845 
846     \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
847     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
848         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
849             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
850                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
851                     error\_Sacado\_vs\_analy += std::fabs(C\_Sac[i][j][k][l] - C\_analy[i][j][k][l]);
852 
853     std::cout << \textcolor{stringliteral}{"Numerical error="} << error\_Sacado\_vs\_analy << std::endl;
854 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+9@{sacado\+\_\+test\+\_\+9}}
\index{sacado\+\_\+test\+\_\+9@{sacado\+\_\+test\+\_\+9}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+9()}{sacado_test_9()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+9 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_ae176f83fe1943e102fe325d4a14f097e}{}\label{Sacado__example_8cc_ae176f83fe1943e102fe325d4a14f097e}


References Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor2$<$ dim $>$\+::init\+\_\+set\+\_\+dofs().



Referenced by main().


\begin{DoxyCode}
861 \{
862     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
863 
864     std::cout << \textcolor{stringliteral}{"Test 9:"} << std::endl;
865 
866     \textcolor{comment}{// Defining the inputs (material parameters, strain tensor)}
867      \textcolor{keywordtype}{double} lambda=1;
868      \textcolor{keywordtype}{double} mu=2;
869      SymmetricTensor<2,dim, double> eps;
870 
871      eps[0][0] = 1.;
872      eps[1][1] = 2.;
873      eps[2][2] = 3.;
874 
875      eps[0][1] = 4.;
876      eps[0][2] = 5.;
877      eps[1][2] = 6.;
878 
879     \textcolor{comment}{// Declaring the special data types containing all derivatives}
880      \textcolor{keyword}{typedef} Sacado::Fad::DFad<double> \hyperlink{Sacado__Wrapper_8h_a7e0893207b87dad05c66a34baac8ed2e}{DFadType};
881 
882      \hyperlink{classSacado__Wrapper_1_1SymTensor2}{Sacado\_Wrapper::SymTensor2<dim>} eps\_fad;
883      eps\_fad.\hyperlink{classSacado__Wrapper_1_1SymTensor2_a54495897cfdd887d0081015571a28107}{init\_set\_dofs}(eps);
884      std::cout << \textcolor{stringliteral}{"eps\_fad="} << eps\_fad << std::endl;
885 
886     \textcolor{comment}{// Compute epsÂ² = eps\_ij * eps\_jk in index notation}
887      SymmetricTensor<2,dim, Sacado::Fad::DFad<DFadType> > eps\_fad\_squared;
888      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
889         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k )
890             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
891                 \textcolor{keywordflow}{if} ( i>=k )
892                     eps\_fad\_squared[i][k] += eps\_fad[i][j] * eps\_fad[j][k];
893 
894     \textcolor{comment}{// Compute the strain energy density}
895 \textcolor{comment}{//   Sacado\_Wrapper::SW\_double2<dim> energy;}
896      Sacado::Fad::DFad<DFadType> energy;
897      energy = lambda/2. * trace(eps\_fad)*trace(eps\_fad) + mu * trace(eps\_fad\_squared);
898 
899     \textcolor{comment}{// The energy is outputted to give some insight into the storage of the values and derivatives.}
900     std::cout << \textcolor{stringliteral}{"energy="} << energy << std::endl;
901 
902     \textcolor{comment}{// Compute sigma as \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\}}
903      SymmetricTensor<2,dim> sigma\_Sac;
904      eps\_fad.get\_tangent(sigma\_Sac, energy);
905      std::cout << \textcolor{stringliteral}{"sigma\_Sacado="} << sigma\_Sac << std::endl;
906 
907     \textcolor{comment}{// Analytical stress tensor:}
908      SymmetricTensor<2,dim> sigma;
909      sigma = lambda*trace(eps)*unit\_symmetric\_tensor<dim>() + 2. * mu * eps;
910      std::cout << \textcolor{stringliteral}{"analy. sigma="} << sigma << std::endl;
911 
912 
913     \textcolor{comment}{// Sacado-Tangent as \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}^2\}}
914      SymmetricTensor<4,dim> C\_Sac;
915      eps\_fad.get\_curvature(C\_Sac, energy);
916 
917     \textcolor{comment}{// Analytical tangent}
918      SymmetricTensor<4,dim> C\_analy;
919      C\_analy = lambda * outer\_product(unit\_symmetric\_tensor<dim>(), unit\_symmetric\_tensor<dim>()) + 2. * mu
       * identity\_tensor<dim>();
920 
921     \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
922     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
923         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
924             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
925                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
926                     error\_Sacado\_vs\_analy += std::fabs(C\_Sac[i][j][k][l] - C\_analy[i][j][k][l]);
927 
928     std::cout << \textcolor{stringliteral}{"Numerical error="} << error\_Sacado\_vs\_analy << std::endl;
929 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+scalar@{sacado\+\_\+test\+\_\+scalar}}
\index{sacado\+\_\+test\+\_\+scalar@{sacado\+\_\+test\+\_\+scalar}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+scalar()}{sacado_test_scalar()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+scalar (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}{}\label{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}


Referenced by main().


\begin{DoxyCode}
39 \{
40     std::cout << \textcolor{stringliteral}{"Scalar Test:"} << std::endl;
41     \textcolor{comment}{// define the variables used in the computation (inputs: a, b; output: c; auxiliaries: *) as the
       Sacado-data type}
42      \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} a,b,c;
43     \textcolor{comment}{// initialize the input variables a and b; This (a,b) = (1,2) will be the point where the derivatives
       are computed.}
44     \textcolor{comment}{// Compare: y=xÂ² -> (dy/dx)(\(\backslash\)@x=1) = 2. We can only compute the derivative numerically at a certain
       point.}
45      a = 1;
46      b = 2;
47 
48     a.diff(0,2);  \textcolor{comment}{// Set a to be dof 0, in a 2-dof system.}
49     b.diff(1,2);  \textcolor{comment}{// Set b to be dof 1, in a 2-dof system.}
50     \textcolor{comment}{// Our equation here is very simply. But you can use nested equations and many standard mathematical
       operations, such as sqrt, pow, sin, ...}
51     c = 2*a + std::cos(a*b);
52     \textcolor{keywordtype}{double} *derivs = &c.fastAccessDx(0); \textcolor{comment}{// Access the derivatives of}
53     \textcolor{comment}{// Output the derivatives of c with respect to the two above defined degrees of freedom (dof)}
54     std::cout << \textcolor{stringliteral}{"Derivatives at the point ("} << a << \textcolor{stringliteral}{","} << b << \textcolor{stringliteral}{")"} << std::endl;
55     std::cout << \textcolor{stringliteral}{"dc/da = "} << derivs[0] << \textcolor{stringliteral}{", dc/db="} << derivs[1] << std::endl;
56 \}
\end{DoxyCode}
