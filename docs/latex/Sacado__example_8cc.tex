\hypertarget{Sacado__example_8cc}{}\section{Sacado\+\_\+example.\+cc File Reference}
\label{Sacado__example_8cc}\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
{\ttfamily \#include $<$deal.\+I\+I/base/symmetric\+\_\+tensor.\+h$>$}\\*
{\ttfamily \#include $<$iostream$>$}\\*
{\ttfamily \#include $<$fstream$>$}\\*
{\ttfamily \#include $<$cmath$>$}\\*
{\ttfamily \#include $<$Sacado.\+hpp$>$}\\*
{\ttfamily \#include \char`\"{}Sacado\+\_\+\+Wrapper.\+h\char`\"{}}\\*
Include dependency graph for Sacado\+\_\+example.\+cc\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{Sacado__example_8cc__incl}
\end{center}
\end{figure}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\+\_\+double} = Sacado\+::\+Fad\+::\+D\+Fad$<$ double $>$
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}{sacado\+\_\+test\+\_\+scalar} ()
\item 
void \hyperlink{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}{sacado\+\_\+test\+\_\+2} ()
\item 
void \hyperlink{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}{sacado\+\_\+test\+\_\+3} ()
\item 
void \hyperlink{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}{sacado\+\_\+test\+\_\+3B} ()
\item 
void \hyperlink{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}{sacado\+\_\+test\+\_\+4} ()
\item 
void \hyperlink{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}{sacado\+\_\+test\+\_\+5} ()
\item 
void \hyperlink{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}{sacado\+\_\+test\+\_\+6} ()
\item 
void \hyperlink{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}{sacado\+\_\+test\+\_\+7} ()
\item 
void \hyperlink{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}{sacado\+\_\+test\+\_\+8} ()
\item 
\hyperlink{CMakeCache_8txt_a79a3d8790b2588b09777910863574e09}{int} \hyperlink{Sacado__example_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main} ()
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!fad\+\_\+double@{fad\+\_\+double}}
\index{fad\+\_\+double@{fad\+\_\+double}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{fad\+\_\+double}{fad_double}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf fad\+\_\+double} =  Sacado\+::\+Fad\+::\+D\+Fad$<$double$>$}\hypertarget{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{}\label{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}


\subsection{Function Documentation}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!main@{main}}
\index{main@{main}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{main()}{main()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int} main (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{}\label{Sacado__example_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}


References sacado\+\_\+test\+\_\+2(), sacado\+\_\+test\+\_\+3(), sacado\+\_\+test\+\_\+3\+B(), sacado\+\_\+test\+\_\+4(), sacado\+\_\+test\+\_\+5(), sacado\+\_\+test\+\_\+6(), sacado\+\_\+test\+\_\+7(), sacado\+\_\+test\+\_\+8(), and sacado\+\_\+test\+\_\+scalar().


\begin{DoxyCode}
917 \{
918     \hyperlink{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}{sacado\_test\_scalar} ();
919 
920     std::cout << std::endl;
921 
922     \hyperlink{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}{sacado\_test\_2} ();
923 
924     std::cout << std::endl;
925 
926     \hyperlink{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}{sacado\_test\_3} ();
927 
928     std::cout << std::endl;
929 
930     \hyperlink{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}{sacado\_test\_3B} ();
931 
932     std::cout << std::endl;
933 
934     \hyperlink{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}{sacado\_test\_4}();
935 
936     std::cout << std::endl;
937 
938     \hyperlink{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}{sacado\_test\_5}();
939 
940     std::cout << std::endl;
941 
942     \hyperlink{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}{sacado\_test\_6}();
943 
944     std::cout << std::endl;
945 
946     \hyperlink{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}{sacado\_test\_7}();
947 
948     std::cout << std::endl;
949 
950     \hyperlink{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}{sacado\_test\_8}();
951 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+2@{sacado\+\_\+test\+\_\+2}}
\index{sacado\+\_\+test\+\_\+2@{sacado\+\_\+test\+\_\+2}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+2()}{sacado_test_2()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+2 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}{}\label{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}


Referenced by main().


\begin{DoxyCode}
68 \{
69     std::cout << \textcolor{stringliteral}{"Test 2:"} << std::endl;
70 
71     \textcolor{comment}{// First we set the dimension \(\backslash\)a dim: 2D->dim=2; 3D->dim=3 \(\backslash\)n This defines the "size" of the tensors
       and the number of dofs. Ex2 only works in 3D, whereas the following Ex3 is set up dimension-independent.}
72     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim = 3;
73 
74     \textcolor{comment}{// Declare our input, auxiliary and output variables as SymmetricTensors consisting of fad\_doubles
       (instead of the standard SymmetricTensor out of doubles)}
75     SymmetricTensor<2,dim, fad\_double> sigma, eps;
76 
77     \textcolor{comment}{// Init the strain tensor (the point at which the derivative shall be computed)}
78     eps[0][0] = 1;
79     eps[1][1] = 2;
80     eps[2][2] = 3;
81     eps[0][1] = 4;
82     eps[0][2] = 5;
83     eps[1][2] = 6;
84 
85     \textcolor{comment}{// Now we declare the dofs. The derivative to a tensor requires all components, therefore we set the
       components of the strain tensor here one by one as the dofs.}
86     \textcolor{comment}{// Because our tensors are symmetric, we only need 6 components in 3D instead of 9 for a full second
       order tensor}
87     eps[0][0].diff(0,6);
88     eps[1][1].diff(1,6);
89     eps[2][2].diff(2,6);
90     eps[0][1].diff(3,6);
91     eps[0][2].diff(4,6);
92     eps[1][2].diff(5,6);
93 
94     \textcolor{comment}{// The equation describing the stresses (here just a simple test case)}
95     sigma = eps;
96 
97     \textcolor{comment}{// Let's output the computed stress tensor.}
98     std::cout << sigma << std::endl;
99     \textcolor{comment}{// The resulting values of \(\backslash\)a sigma are fairly boring, due to our simple equation. It is the additional
       output generated by}
100     \textcolor{comment}{// this, that is interesting here: \(\backslash\)n}
101     \textcolor{comment}{// output: \(\backslash\)n}
102     \textcolor{comment}{// 1 [ 1 0 0 0 0 0 ] 4 [ 0 0 0 1 0 0 ] 5 [ 0 0 0 0 1 0 ] 4 [ 0 0 0 1 0 0 ] 2 [ 0 1 0 0 0 0 ] 6 [ 0 0 0
       0 0 1 ] 5 [ 0 0 0 0 1 0 ] 6 [ 0 0 0 0 0 1 ] 3 [ 0 0 1 0 0 0 ] \(\backslash\)n}
103     \textcolor{comment}{// The numbers 1, 4, 5, 4, ... are the entries in the stress tensor \(\backslash\)a sigma. In square brackets we see
       the derivatives of sigma with respect to all the dofs set previously}
104     \textcolor{comment}{// given in the order we defined them above. Meaning: The first entry in the square brackets
       corresponds to the 0-th dof set by}
105     \textcolor{comment}{// @code eps[0][0].diff(0,6); @endcode referring to the component (0,0) in the strain tensor \(\backslash\)a eps.}
106 
107     \textcolor{comment}{// Computing the derivatives for certain components of the resulting tangent modulus: \(\backslash\)n}
108     \textcolor{comment}{// We now access these lists of derivatives (output above in square brackets) for one component of the
       stress tensor \(\backslash\)a sigma at a time.}
109     \{
110         \textcolor{comment}{// Access the derivatives corresponding to the component (0,0) of the stress tensor \(\backslash\)a sigma}
111         \textcolor{keywordtype}{double} *derivs = &sigma[0][0].fastAccessDx(0);
112         \textcolor{comment}{// The following output will show us the same derivatives that we already saw above, just formatted
       differently \(\backslash\)n}
113         \textcolor{comment}{// output: d\_sigma[0][0]/d\_eps = 1 , 0 , 0 , 0 , 0 , 0 ,}
114         std::cout << \textcolor{stringliteral}{"d\_sigma[0][0]/d\_eps = "};
115         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<6; ++i)
116             std::cout << derivs[i] << \textcolor{stringliteral}{" , "};
117         std::cout << std::endl;
118     \}
119     \{
120         \textcolor{comment}{// Access the derivatives corresponding to the component (1,2) of the stress tensor \(\backslash\)a sigma}
121         \textcolor{keywordtype}{double} *derivs = &sigma[1][2].fastAccessDx(0);
122         \textcolor{comment}{// output: d\_sigma[1][2]/d\_eps = 0 , 0 , 0 , 0 , 0 , 1 ,}
123         std::cout << \textcolor{stringliteral}{"d\_sigma[1][2]/d\_eps = "};
124         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<6; ++i)
125             std::cout << derivs[i] << \textcolor{stringliteral}{" , "};
126         std::cout << std::endl;
127     \}
128 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+3@{sacado\+\_\+test\+\_\+3}}
\index{sacado\+\_\+test\+\_\+3@{sacado\+\_\+test\+\_\+3}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+3()}{sacado_test_3()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+3 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}{}\label{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}


Referenced by main().


\begin{DoxyCode}
133 \{
134     std::cout << \textcolor{stringliteral}{"Test 3:"} << std::endl;
135 
136     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim = 3;
137 
138     \textcolor{comment}{// Here we also define some constant, for instance the bulk modulus \(\backslash\)a kappa and the second Lamè
       parameter \(\backslash\)a mu.}
139     \textcolor{comment}{// We now also define one of our constants as fad\_double. By doing this we can use the normal
       multiplication (see below).}
140     \textcolor{keywordtype}{double} kappa\_param = 5;
141     \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} kappa (kappa\_param);
142     \textcolor{comment}{// The second constant remains as a double just to show the difference.}
143     \textcolor{keywordtype}{double} mu = 2;
144 
145     SymmetricTensor<2,dim, fad\_double> sigma, eps;
146 
147     \textcolor{comment}{// To simplify the access to the dofs we define a map that relate the components of our strain tensor
       to the dof-nbr}
148     std::map<unsigned int,std::pair<unsigned int,unsigned int>> std\_map\_indicies;
149 
150     \textcolor{comment}{// The point at which the derivative shall be computed: \(\backslash\)n}
151     \textcolor{comment}{// As mentioned previously, we will implement this example for 2D and 3D, hence we once have to set up
       a strain tensor}
152     \textcolor{comment}{// and the derivatives for 3D with 6 independent components ...}
153     \textcolor{keywordflow}{if}(dim==3)
154     \{
155         eps[0][0] = 1;
156         eps[1][1] = 2;
157         eps[2][2] = 3;
158         
159         eps[0][1] = 4;
160         eps[0][2] = 5;
161         eps[1][2] = 6;
162         
163         
164         eps[0][0].diff(0,6);
165         eps[0][1].diff(1,6);
166         eps[0][2].diff(2,6);
167         eps[1][1].diff(3,6);
168         eps[1][2].diff(4,6);
169         eps[2][2].diff(5,6);
170         
171         \textcolor{comment}{// By using the map and the following pairs, we have to set up the relation between strain
       components and dofs only once}
172         \textcolor{comment}{// and can use the map to access the entries of the list later, without possibly mixing up indices
       and creating errors.}
173         \textcolor{comment}{// Please don't be confused, but the dofs in the Wrapper are set up}
174         \textcolor{comment}{// in a different order that we showed earlier. Earlier: (0,0)-(1,1)-(2,2)-...; Now:
       (0,0)-(0,1)-(0,2)-...}
175         std::pair<unsigned int, unsigned int> tmp\_pair;
176         tmp\_pair.first=0; tmp\_pair.second=0;
177         std\_map\_indicies[0] = tmp\_pair;
178 
179         tmp\_pair.first=0; tmp\_pair.second=1;
180         std\_map\_indicies[1] = tmp\_pair;
181 
182         tmp\_pair.first=0; tmp\_pair.second=2;
183         std\_map\_indicies[2] = tmp\_pair;
184 
185         tmp\_pair.first=1; tmp\_pair.second=1;
186         std\_map\_indicies[3] = tmp\_pair;
187 
188         tmp\_pair.first=1; tmp\_pair.second=2;
189         std\_map\_indicies[4] = tmp\_pair;
190 
191         tmp\_pair.first=2; tmp\_pair.second=2;
192         std\_map\_indicies[5] = tmp\_pair;
193     \}
194     \textcolor{comment}{// ... and once for 2D with just 3 independent components.}
195     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(dim==2)
196     \{
197         eps[0][0] = 1;
198         eps[1][1] = 2;
199         
200         eps[0][1] = 4;
201 
202                 
203         eps[0][0].diff(0,3);
204         eps[0][1].diff(1,3);
205         eps[1][1].diff(2,3);
206         
207         std::pair<unsigned int, unsigned int> tmp\_pair;
208         tmp\_pair.first=0; tmp\_pair.second=0;
209         std\_map\_indicies[0] = tmp\_pair;
210         
211         tmp\_pair.first=0; tmp\_pair.second=1;
212         std\_map\_indicies[1] = tmp\_pair;
213         
214         tmp\_pair.first=1; tmp\_pair.second=1;
215         std\_map\_indicies[2] = tmp\_pair;        
216     \}
217     \textcolor{keywordflow}{else}
218     \{
219         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"only dim==2 or dim==3 allowed"});
220     \}
221 
222     \textcolor{comment}{// Instead of calling the *.diff(*) on the components one-by-one we could also use the following
       for-loop, so}
223     \textcolor{comment}{// we also use the map to set the dofs (as we will do in the Wrapper later).}
224     \textcolor{comment}{// @code}
225     \textcolor{comment}{// for ( unsigned int x=0; x<((dim==2)?3:6); ++x )}
226     \textcolor{comment}{// \{}
227     \textcolor{comment}{//  unsigned int i=std\_map\_indicies[x].first;}
228     \textcolor{comment}{//  unsigned int j=std\_map\_indicies[x].second;}
229     \textcolor{comment}{//  eps[i][j].diff(x,((dim==2)?3:6));}
230     \textcolor{comment}{// \}}
231     \textcolor{comment}{// @endcode}
232 
233     \textcolor{comment}{// For our slightly more complicated stress equation we need the unit and deviatoric tensors.}
234     \textcolor{comment}{// We can simply define them by writing the values of the already existing deal.ii functions into newly}
235     \textcolor{comment}{// defined SymmetricTensors build from fad\_doubles.}
236     SymmetricTensor<2,dim, fad\_double> stdTensor\_I (( unit\_symmetric\_tensor<dim,fad\_double>()) );
237     SymmetricTensor<4,dim, fad\_double> stdTensor\_Idev ( (deviator\_tensor<dim,fad\_double>()) );
238     
239     \textcolor{comment}{// With everything set and defined, we can compute our stress \(\backslash\)a sigma according to:}
240     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)sigma = \(\backslash\)kappa \(\backslash\)cdot trace(\(\backslash\)varepsilon) \(\backslash\)cdot \(\backslash\)boldsymbol\{I\} + 2 \(\backslash\)cdot \(\backslash\)mu \(\backslash\)cdot
       \(\backslash\)varepsilon^\{dev\} \(\backslash\)f]}
241     \textcolor{comment}{// Here you can see that we can directly multiply the constant and the tensors when kappa is also
       declared as fad\_double}
242     sigma = kappa * (trace(eps) *  stdTensor\_I);
243     \textcolor{comment}{// We didn't do the same for mu to once again emphasize the difference between constants as double and
       as fad\_double. \(\backslash\)n}
244     \textcolor{comment}{// The remaining code uses a normal double constant.}
245     SymmetricTensor<2,dim,fad\_double> tmp = deviator<dim,fad\_double>(symmetrize<dim,fad\_double>(eps)); tmp*
      =(mu*2);
246     sigma +=  tmp;
247     \textcolor{comment}{// The fairly cumbersome computation is caused by the way the operators are set up for tensors out of
       fad\_doubles.}
248     
249     std::cout << \textcolor{stringliteral}{"sigma="} << sigma << std::endl;
250 
251     \textcolor{comment}{// Now we want to actually build our tangent modulus called \(\backslash\)a C\_Sacado that contains all the
       derivatives and relates}
252     \textcolor{comment}{// the stress tensor with the strain tensor. \(\backslash\)n}
253     \textcolor{comment}{// The fourth-order tensor \(\backslash\)a C\_Sacado is our final goal, we don't have to compute anything that is
       related to Sacado with}
254     \textcolor{comment}{// this tensor, so we can finally return to our standard SymmetricTensor out of doubles. The latter is
       necessary to use}
255     \textcolor{comment}{// the tangent in the actual FE code.}
256     SymmetricTensor<4,dim> C\_Sacado;
257 
258     \textcolor{comment}{// As in Ex2 we access the components of the stress tensor one by one. In order to capture all of them
       we loop over the}
259     \textcolor{comment}{// components i and j of the stress tensor.}
260     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
261         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
262         \{
263             \textcolor{keywordtype}{double} *derivs = &sigma[i][j].fastAccessDx(0); \textcolor{comment}{// Access the derivatives of the (i,j)-th
       component of \(\backslash\)a sigma}
264 
265             \textcolor{comment}{// To visually ensure that every stress component has in fact all 6 derivatives for 3D or 3 for
       2D, we output the size:}
266             std::cout<<\textcolor{stringliteral}{"size: "}<<sigma[i][j].size()<<std::endl;
267 
268             \textcolor{comment}{// We loop over all the dofs. To be able to use this independent of the chosen dimension \(\backslash\)a
       dim, we use a ternary operator}
269             \textcolor{comment}{// to decide whether we have to loop over 6 derivatives or just 3.}
270             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0;x<((dim==2)?3:6);++x)
271             \{
272                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=std\_map\_indicies[x].first;
273                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=std\_map\_indicies[x].second;
274 
275                 \textcolor{keywordflow}{if}(k!=l)\textcolor{comment}{/*Compare to Voigt notation since only SymmetricTensor instead of Tensor*/}
276                 \{
277                     C\_Sacado[i][j][k][l] = 0.5*derivs[x];
278                     C\_Sacado[i][j][l][k] = 0.5*derivs[x];
279                 \}
280                 \textcolor{keywordflow}{else}
281                     C\_Sacado[i][j][k][l] = derivs[x];
282             \}            
283             
284         \}
285 
286     \textcolor{comment}{// After resembling the fourth-order tensor, we now have got our tangent saved in \(\backslash\)a C\_Sacado ready to
       be used}
287 
288     \textcolor{comment}{// To ensure that Sacado works properly, we can compute the analytical tangent for comparison}
289     \textcolor{keywordtype}{double} kappa\_d = 5;
290     \textcolor{keywordtype}{double} mu\_d = 2;
291     \textcolor{comment}{// Our stress equation in this example is still simple enough to derive the tangent analytically by
       hand:}
292     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)overset\{4\}\{C\_\{analy\}\} = \(\backslash\)kappa \(\backslash\)cdot \(\backslash\)boldsymbol\{I\} \(\backslash\)otimes \(\backslash\)boldsymbol\{I\} + 2 \(\backslash\)cdot \(\backslash\)mu \(\backslash\)cdot
       \(\backslash\)overset\{4\}\{I^\{dev\}\} \(\backslash\)f]}
293     SymmetricTensor<4,dim> C\_analy = kappa\_d * outer\_product(unit\_symmetric\_tensor<dim>(), 
      unit\_symmetric\_tensor<dim>()) + 2* mu\_d * deviator\_tensor<dim>();
294 
295 
296     \textcolor{comment}{// We again define our strain tensor \(\backslash\)a eps\_d (*\_d for standard double in contrast to fad\_double)}
297     SymmetricTensor<2,dim> eps\_d;
298     
299     \textcolor{keywordflow}{if}(dim==3)
300     \{
301         eps\_d[0][0] = 1;
302         eps\_d[1][1] = 2;
303         eps\_d[2][2] = 3;
304         
305         eps\_d[0][1] = 4;
306         eps\_d[0][2] = 5;
307         eps\_d[2][1] = 6;
308 
309     \}
310     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(dim==2)
311     \{
312         eps\_d[0][0] = 1;
313         eps\_d[1][1] = 2;
314         
315         eps\_d[1][0] = 4;
316         
317     \}
318     \textcolor{keywordflow}{else}
319     \{
320         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"only dim==2 or dim==3 allowed"});
321     \}
322     \textcolor{comment}{// @todo use boldsymbol for tensors}
323     \textcolor{comment}{//}
324     \textcolor{comment}{// To output the stress tensor we first have to compute it. We do this here via}
325     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)sigma = \(\backslash\)overset\{4\}\{C\_\{analy\}\} : \(\backslash\)varepsilon \(\backslash\)f]}
326     \textcolor{comment}{// The output exactly matched the result obtained with Sacado.}
327     \textcolor{comment}{// @note Checking the Sacado stress tensor against an analytically computed or otherwise determined
       stress tensor is absolutely no way to check whether}
328     \textcolor{comment}{// the tangent computed via Sacado is correct. When we compute the stress tensor with Sacado and for
       example mix up a + and - sign, this might not matter}
329     \textcolor{comment}{// at all if the number that is added or subtracted is small. However, for the tangent this nasty sign
       can be very critical. Just keep in mind: the}
330     \textcolor{comment}{// tangent has 81 components and the stress tensor just 9, so how does one want to verify 81 variables
       by comparing 9?}
331     \textcolor{comment}{//}
332     std::cout << \textcolor{stringliteral}{"sigma\_analy: "} << (C\_analy*eps\_d) << std::endl;
333     
334     \textcolor{comment}{// That's the reason we compare all the entries in the Sacado and the analytical tensor one by one}
335     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
336         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
337             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
338                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
339                     std::cout << \textcolor{stringliteral}{"C\_analy["}<<i<<\textcolor{stringliteral}{"]["}<<j<<\textcolor{stringliteral}{"]["}<<k<<\textcolor{stringliteral}{"]["}<<l<<\textcolor{stringliteral}{"] = "} << C\_analy[i][j][k][l] <<
       \textcolor{stringliteral}{" vs C\_Sacado: "} << C\_Sacado[i][j][k][l] << std::endl;
340 
341 
342     \textcolor{comment}{// To simplify the comparison we compute a scalar error as the sum of the absolute differences of each
       component}
343     \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
344     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
345         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
346             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
347                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
348                     error\_Sacado\_vs\_analy += std::fabs(C\_Sacado[i][j][k][l] - C\_analy[i][j][k][l]);
349                     
350 
351     \textcolor{comment}{// As desired: The numerical error is zero (0 in double precision) and the tensor components are equal}
352     std::cout << \textcolor{stringliteral}{"numerical error: "} << error\_Sacado\_vs\_analy << std::endl;
353 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+3B@{sacado\+\_\+test\+\_\+3B}}
\index{sacado\+\_\+test\+\_\+3B@{sacado\+\_\+test\+\_\+3B}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+3\+B()}{sacado_test_3B()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+3B (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}{}\label{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}


References Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::get\+\_\+tangent(), Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::init(), and Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::set\+\_\+dofs().



Referenced by main().


\begin{DoxyCode}
358 \{
359     std::cout << \textcolor{stringliteral}{"Test 3B:"} << std::endl;
360     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
361 
362     \textcolor{comment}{// The following declarations are usually input arguments. So you receive the strain tensor and the
       constants out of doubles.}
363     SymmetricTensor<2,dim> eps\_d;
364     eps\_d[0][0] = 1;
365     eps\_d[1][1] = 2;
366     eps\_d[2][2] = 3;
367 
368     eps\_d[0][1] = 4;
369     eps\_d[0][2] = 5;
370     eps\_d[1][2] = 6;
371 
372     \textcolor{keywordtype}{double} kappa = 5;
373     \textcolor{keywordtype}{double} mu = 2;
374 
375     \textcolor{comment}{// Now we start working with Sacado: \(\backslash\)n}
376     \textcolor{comment}{// When we use the index notation to compute e.g. our stress we do not need to declare our constants
       (here kappa, mu) as}
377     \textcolor{comment}{// fad\_double.}
378 
379     \textcolor{comment}{// We declare our strain tensor as the special data type Sacado\_Wrapper::SymTensor from the file
       "Sacado\_Wrapper.h"}
380     \textcolor{comment}{// where this data type was derived from the SymmetricTensor<2,dim,fad\_double>.}
381      \hyperlink{classSacado__Wrapper_1_1SymTensor}{Sacado\_Wrapper::SymTensor<dim>} eps;
382 
383     \textcolor{comment}{// Next we initialize our Sacado strain tensor with the values of the inputed double strain tensor:}
384      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_acbad579d5ead9e96ff46aa15d9b5aef4}{init}(eps\_d);
385 
386     \textcolor{comment}{// We define all the entries in the symmetric tensor \(\backslash\)a eps as the dofs. So we can later derive any
       variable}
387     \textcolor{comment}{// with respect to the strain tensor \(\backslash\)a eps.}
388      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_aa9e0fcc9d4e0a4120bedb8ef9b8d7ecb}{set\_dofs}();
389 
390     \textcolor{comment}{// Now we declare our output and auxiliary variables as Sacado-Tensors.}
391      SymmetricTensor<2,dim,fad\_double> sigma;
392 
393      SymmetricTensor<2,dim, fad\_double> stdTensor\_I (( unit\_symmetric\_tensor<dim,fad\_double>()) );
394 
395      \textcolor{comment}{// Our stress equation is now computed in index notation to simplify the use of the constants and}
396      \textcolor{comment}{// especially the use of the \(\backslash\)a deviator.}
397       \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
398         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
399             sigma[i][j] = kappa * trace(eps) *  stdTensor\_I[i][j] + 2. * mu * deviator(eps)[i][j];
400 
401     \textcolor{comment}{// Finally we declare our desired tangent as the fourth order tensor \(\backslash\)a C\_Sacado and compute the
       tangent via}
402     \textcolor{comment}{// the command \(\backslash\)a get\_tangent.}
403      SymmetricTensor<4,dim> C\_Sacado;
404      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ab97427c3b5cab279e58607cf431ab262}{get\_tangent}(C\_Sacado, sigma);
405 
406     \textcolor{comment}{// We could again compare the herein computed tangent with the analytical tangent from Ex2, but as
       before}
407     \textcolor{comment}{// the results are fairly boring, because Sacado hits the analytical tangent exactly --- no surprise
       for such}
408     \textcolor{comment}{// simple equations.}
409 
410     \textcolor{comment}{// And that's it. By using the Sacado\_wrapper we can achieve everything from Ex2 (besides the
       equations)}
411     \textcolor{comment}{// with just four lines of code namely:}
412     \textcolor{comment}{// - eps.init(eps\_d);    // To initialize the Sacado strain tensor}
413     \textcolor{comment}{// - eps.set\_dofs();     // To declare the components of eps as the dofs}
414     \textcolor{comment}{// - eps.get\_tangent(*); // To get the tangent}
415 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+4@{sacado\+\_\+test\+\_\+4}}
\index{sacado\+\_\+test\+\_\+4@{sacado\+\_\+test\+\_\+4}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+4()}{sacado_test_4()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+4 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}{}\label{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}


References Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::get\+\_\+tangent(), Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double$<$ dim $>$\+::get\+\_\+tangent(), Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::init(), Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double$<$ dim $>$\+::init(), and Sacado\+\_\+\+Wrapper\+::\+Do\+Fs\+\_\+summary$<$ dim $>$\+::set\+\_\+dofs().



Referenced by main().


\begin{DoxyCode}
420 \{
421     std::cout << \textcolor{stringliteral}{"Test 4:"} << std::endl;
422     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
423 
424     \textcolor{comment}{// The following declarations are usually input arguments. So you receive the strain tensor \(\backslash\)q eps\_d,}
425     \textcolor{comment}{// the damage variable \(\backslash\)a phi and the constants \(\backslash\)a kappa and \(\backslash\)a mu out of doubles.}
426     SymmetricTensor<2,dim> eps\_d;
427     eps\_d[0][0] = 1;
428     eps\_d[1][1] = 2;
429     eps\_d[2][2] = 3;
430 
431     eps\_d[0][1] = 4;
432     eps\_d[0][2] = 5;
433     eps\_d[1][2] = 6;
434 
435     \textcolor{keywordtype}{double} phi\_d = 0.3;
436 
437     \textcolor{comment}{// We don't need these constants in the current example.}
438     \textcolor{comment}{// double kappa = 5;}
439     \textcolor{comment}{// double mu = 2;}
440 
441 
442     \textcolor{comment}{// We set up our strain tensor as in Ex3B.}
443      \hyperlink{classSacado__Wrapper_1_1SymTensor}{Sacado\_Wrapper::SymTensor<dim>} eps;
444      \hyperlink{classSacado__Wrapper_1_1SW__double}{Sacado\_Wrapper::SW\_double<dim>} phi;
445 
446     \textcolor{comment}{// Initialize the strain tensor and the damage variable}
447      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_acbad579d5ead9e96ff46aa15d9b5aef4}{init}(eps\_d);
448      phi.\hyperlink{classSacado__Wrapper_1_1SW__double_adca799dd92dadebda9aebc91c797682a}{init}(phi\_d);
449 
450      \textcolor{comment}{// Set the dofs, where the argument sets the total nbr of dofs (3 or 6 for the sym. tensor and 1 for
       the double)}
451 \textcolor{comment}{//    eps.set\_dofs(eps.n\_independent\_components+1/*an additional dof for phi*/);}
452 \textcolor{comment}{//}
453      \textcolor{comment}{// In order to also compute derivatives with respect to the scalar \(\backslash\)a phi, we add this scalar to our
       list}
454      \textcolor{comment}{// of derivatives. Because we have already defined 3 or 6 dofs our additional dof will be placed at
       the end}
455      \textcolor{comment}{// of this list. We set this up with the member variable start\_index ...}
456 \textcolor{comment}{//    phi.start\_index=eps.n\_independent\_components;}
457      \textcolor{comment}{// and again using the input argument representing the total number of dofs}
458 \textcolor{comment}{//    phi.set\_dofs(eps.n\_independent\_components+1);}
459 
460     \textcolor{comment}{// All of the above 3 lines of code are automatically done by the DoFs\_summary class. So, to}
461     \textcolor{comment}{// set our dofs we just create an instance and call set\_dofs with our variables containing the desired
       dofs.}
462      \hyperlink{classSacado__Wrapper_1_1DoFs__summary}{Sacado\_Wrapper::DoFs\_summary<dim>} DoFs\_summary;
463      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_a556293f6e683cb30151d9faadc2cc90d}{set\_dofs}(eps, phi);
464 
465 
466     \textcolor{comment}{// Compute the stress tensor and damage variable \(\backslash\)a d (here we just use some arbitrary equations for
       testing): \(\backslash\)n}
467      \textcolor{comment}{// Let us first declare our output (and auxiliary) variables as Sacado data types.}
468       SymmetricTensor<2,dim,fad\_double> sigma;
469       \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} d;
470      \textcolor{comment}{// @todo It would be nice to use the data types from the Sacado\_Wrapper for all the Sacado variables.
       But}
471      \textcolor{comment}{// somehow the operators (multiply*, ...) seem to cause conflicts again.}
472 
473      \textcolor{comment}{// The actual computation in the following scope uses the exact same equation as your normal
       computation e. g. via the data type double.}
474      \textcolor{comment}{// Hence, you could either directly compute your stress, etc. via the Sacado variables or you define}
475      \textcolor{comment}{// template functions that contain your equations and are either called templated with double or
       fad\_double.}
476      \textcolor{comment}{// When using the first option, please consider the computation time that is generally higher for a
       computation}
477      \textcolor{comment}{// with fad\_double than with normal doubles (own experience in a special case: slower by factor 30).}
478      \textcolor{comment}{// The second option with templates does not suffer these issues.}
479       \{
480       \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
481         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
482             sigma[i][j] = phi * eps[i][j];
483              \textcolor{comment}{// ToDo: strangely when phi is a fad\_double then the multiplication phi * eps works directly
       without}
484              \textcolor{comment}{// having to use the index notation}
485       std::cout << \textcolor{stringliteral}{"sigma="} << sigma << std::endl;
486 
487       d = phi*phi + 25 + trace(eps);
488       std::cout << \textcolor{stringliteral}{"d="} << d << std::endl;
489       \}
490 
491 
492     \textcolor{comment}{// Get the tangents}
493      \textcolor{comment}{// d\_sigma / d\_eps: SymmetricTensor with respect to SymmetricTensor}
494       SymmetricTensor<4,dim> C\_Sacado;
495       eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ab97427c3b5cab279e58607cf431ab262}{get\_tangent}(C\_Sacado, sigma);
496       std::cout << \textcolor{stringliteral}{"C\_Sacado="} << C\_Sacado << std::endl;
497 
498      \textcolor{comment}{// Compute the analytical tangent:}
499       SymmetricTensor<4,dim> C\_analy;
500       C\_analy = phi\_d * identity\_tensor<dim>();
501       std::cout << \textcolor{stringliteral}{"C\_analy ="} << C\_analy << std::endl;
502 
503      \textcolor{comment}{// d\_d / d\_eps: double with respect to SymmetricTensor}
504       SymmetricTensor<2,dim> d\_d\_d\_eps;
505       eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ab97427c3b5cab279e58607cf431ab262}{get\_tangent}(d\_d\_d\_eps, d);
506       std::cout << \textcolor{stringliteral}{"d\_d\_d\_eps="} << d\_d\_d\_eps << std::endl;
507 
508      \textcolor{comment}{// d\_sigma / d\_phi: SymmetricTensor with respect to double}
509       SymmetricTensor<2,dim> d\_sigma\_d\_phi;
510       phi.\hyperlink{classSacado__Wrapper_1_1SW__double_a2e6eca4457eb22b06172bb5749038f1e}{get\_tangent}(d\_sigma\_d\_phi, sigma);
511       std::cout << \textcolor{stringliteral}{"d\_sigma\_d\_phi="} << d\_sigma\_d\_phi << std::endl;
512       std::cout << \textcolor{stringliteral}{"sigma = d\_sigma\_d\_phi * phi = "} << d\_sigma\_d\_phi * phi\_d << std::endl;
513 
514      \textcolor{comment}{// d\_d / d\_phi: double with respect to double}
515       \textcolor{keywordtype}{double} d\_d\_d\_phi;
516       phi.\hyperlink{classSacado__Wrapper_1_1SW__double_a2e6eca4457eb22b06172bb5749038f1e}{get\_tangent}(d\_d\_d\_phi, d);
517       std::cout << \textcolor{stringliteral}{"d\_d\_d\_phi="} << d\_d\_d\_phi << std::endl;
518 
519     \textcolor{comment}{// And that's it. By using the Sacado\_wrapper we can compute derivatives with respect to}
520     \textcolor{comment}{// a tensor and a scalar at the same time (besides the equations)}
521     \textcolor{comment}{// in essence with just the following lines of code namely:}
522     \textcolor{comment}{// - eps.init(eps\_d); phi.init(phi\_d);   // To initialize the Sacado strain tensor and scalar damage
       variable}
523     \textcolor{comment}{// - DoFs\_summary.set\_dofs(eps, phi);    // To declare the components of eps and phi as the dofs}
524     \textcolor{comment}{// - eps.get\_tangent(*); // To get tangents with respect to eps}
525     \textcolor{comment}{// - phi.get\_tangent(*); // To get tangents with respect to phi}
526 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+5@{sacado\+\_\+test\+\_\+5}}
\index{sacado\+\_\+test\+\_\+5@{sacado\+\_\+test\+\_\+5}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+5()}{sacado_test_5()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+5 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}{}\label{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}


References c.



Referenced by main().


\begin{DoxyCode}
532 \{
533     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
534     std::cout << \textcolor{stringliteral}{"Test 5:"} << std::endl;
535     Tensor<1,dim,fad\_double> \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c};
536     \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} a,b;
537     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n\_dofs=2;
538     a = 1; b = 2;   \textcolor{comment}{// at the point (a,b) = (1,2)}
539     a.diff(0,2);  \textcolor{comment}{// Set a to be dof 0, in a 2-dof system.}
540     b.diff(1,2);  \textcolor{comment}{// Set b to be dof 1, in a 2-dof system.}
541     \textcolor{comment}{// c is now a vector with three components}
542     c[0] = 2*a+3*b;
543     c[1] = 4*a+5*b;
544     c[2] = 6*a+7*b;
545     
546     \textcolor{comment}{// Access to the derivatives works as before.}
547     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<dim;++i)
548     \{
549         \textcolor{keyword}{const} \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} &derivs = c[i]; \textcolor{comment}{// Access derivatives}
550         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0;j<n\_dofs;++j)
551         \{
552             std::cout << \textcolor{stringliteral}{"Derivatives at the point ("} << a << \textcolor{stringliteral}{","} << b << \textcolor{stringliteral}{") for "}
553             <<i<<\textcolor{stringliteral}{"th component wrt "}<<j<<\textcolor{stringliteral}{"th direction "}<< std::endl;
554             std::cout << \textcolor{stringliteral}{"dc\_i/dxj = "} << derivs.fastAccessDx(j) << std::endl;            
555         \}
556     \}
557 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+6@{sacado\+\_\+test\+\_\+6}}
\index{sacado\+\_\+test\+\_\+6@{sacado\+\_\+test\+\_\+6}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+6()}{sacado_test_6()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+6 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}{}\label{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}


Referenced by main().


\begin{DoxyCode}
565 \{
566     std::cout << \textcolor{stringliteral}{"Test 6:"} << std::endl;
567     \textcolor{comment}{// Define the variables used in the computation (inputs: a, b; output: c; auxiliaries: *) as doubles}
568      \textcolor{keywordtype}{double} a=1;
569      \textcolor{keywordtype}{double} b=2;
570 
571     \textcolor{comment}{// Number of independent variables (scalar a and b)}
572      \textcolor{keywordtype}{int} num\_dofs = 2;
573 
574     \textcolor{comment}{// Define another data type containing even more Sacado data types}
575     \textcolor{comment}{// @todo try to merge the fad\_double data type with this templated data type}
576      \textcolor{keyword}{typedef} Sacado::Fad::DFad<double> \hyperlink{Sacado__Wrapper_8h_a7e0893207b87dad05c66a34baac8ed2e}{DFadType};
577      Sacado::Fad::DFad<DFadType> afad(num\_dofs, 0, a);
578      Sacado::Fad::DFad<DFadType> bfad(num\_dofs, 1, b);
579      Sacado::Fad::DFad<DFadType> cfad;
580 
581     \textcolor{comment}{// Output the variables: We se that the values of \(\backslash\)a a and \(\backslash\)a b are set but the derivatives have not
       yet been fully declared}
582      std::cout << \textcolor{stringliteral}{"afad="} << afad << std::endl;
583      std::cout << \textcolor{stringliteral}{"bfad="} << bfad << std::endl;
584      std::cout << \textcolor{stringliteral}{"cfad="} << cfad << std::endl;
585 
586     \textcolor{comment}{// Now we set the "inner" derivatives.}
587     afad.val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(num\_dofs, 0, a); \textcolor{comment}{// set afad.val() as the first dof and init it with
       the double a}
588     bfad.val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(num\_dofs, 1, b);
589 
590     \textcolor{comment}{// Compute function and derivative with AD}
591      cfad = 2*afad + std::cos(afad*bfad);
592 
593     \textcolor{comment}{// After this, we output the variables again and see that some additional derivatives have been
       declared. Furthermore,}
594     \textcolor{comment}{// \(\backslash\)a cfad is filled with the values and derivatives}
595      std::cout << \textcolor{stringliteral}{"afad="} << afad << std::endl;
596      std::cout << \textcolor{stringliteral}{"bfad="} << bfad << std::endl;
597      std::cout << \textcolor{stringliteral}{"cfad="} << cfad << std::endl;
598 
599     \textcolor{comment}{// Extract value and derivatives}
600      \textcolor{keywordtype}{double} c\_ad = cfad.val().val();       \textcolor{comment}{// r}
601      \textcolor{keywordtype}{double} dcda\_ad = cfad.dx(0).val();    \textcolor{comment}{// dr/da}
602      \textcolor{keywordtype}{double} dcdb\_ad = cfad.dx(1).val();    \textcolor{comment}{// dr/db}
603      \textcolor{keywordtype}{double} d2cda2\_ad = cfad.dx(0).dx(0);  \textcolor{comment}{// d^2r/da^2}
604      \textcolor{keywordtype}{double} d2cdadb\_ad = cfad.dx(0).dx(1); \textcolor{comment}{// d^2r/dadb}
605      \textcolor{keywordtype}{double} d2cdbda\_ad = cfad.dx(1).dx(0); \textcolor{comment}{// d^2r/dbda}
606      \textcolor{keywordtype}{double} d2cdb2\_ad = cfad.dx(1).dx(1);  \textcolor{comment}{// d^2/db^2}
607 
608     \textcolor{comment}{// Now we can print the actual double value of c and some of the derivatives:}
609      std::cout << \textcolor{stringliteral}{"c\_ad="} << c\_ad << std::endl;
610      std::cout << \textcolor{stringliteral}{"Derivatives at the point ("} << a << \textcolor{stringliteral}{","} << b << \textcolor{stringliteral}{")"} << std::endl;
611      std::cout << \textcolor{stringliteral}{"dc/da = "} << dcda\_ad << \textcolor{stringliteral}{", dc/db="} << dcdb\_ad << std::endl;
612      std::cout << \textcolor{stringliteral}{"d²c/da² = "} << d2cda2\_ad << \textcolor{stringliteral}{", d²c/db²="} << d2cdb2\_ad << std::endl;
613      std::cout << \textcolor{stringliteral}{"d²c/dadb = "} << d2cdadb\_ad << \textcolor{stringliteral}{", d²c/dbda="} << d2cdbda\_ad << std::endl;
614 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+7@{sacado\+\_\+test\+\_\+7}}
\index{sacado\+\_\+test\+\_\+7@{sacado\+\_\+test\+\_\+7}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+7()}{sacado_test_7()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+7 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}{}\label{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}


Referenced by main().


\begin{DoxyCode}
619 \{
620     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
621 
622     std::cout << \textcolor{stringliteral}{"Test 7:"} << std::endl;
623 
624     \textcolor{comment}{// Defining the inputs (material parameters, strain tensor)}
625      \textcolor{keywordtype}{double} lambda=1;
626      \textcolor{keywordtype}{double} mu=2;
627      SymmetricTensor<2,dim, double> eps;
628 
629      eps[0][0] = 1.;
630      eps[1][1] = 2.;
631      eps[2][2] = 3.;
632 
633      eps[0][1] = 4.;
634      eps[0][2] = 5.;
635      eps[1][2] = 6.;
636 
637     \textcolor{comment}{// Here we skip the one-field example and right away show the equations for a two-field problem}
638     \textcolor{comment}{// with \(\backslash\)a eps and \(\backslash\)a phi.}
639      \textcolor{keywordtype}{double} phi=0.3;
640 
641     \textcolor{comment}{// Setup of the map relating the indices (as before)}
642      std::map<unsigned int,std::pair<unsigned int,unsigned int>> std\_map\_indicies;
643 
644      std::pair<unsigned int, unsigned int> tmp\_pair;
645      tmp\_pair.first=0; tmp\_pair.second=0;
646      std\_map\_indicies[0] = tmp\_pair;
647 
648      tmp\_pair.first=0; tmp\_pair.second=1;
649      std\_map\_indicies[1] = tmp\_pair;
650 
651      tmp\_pair.first=0; tmp\_pair.second=2;
652      std\_map\_indicies[2] = tmp\_pair;
653 
654      tmp\_pair.first=1; tmp\_pair.second=1;
655      std\_map\_indicies[3] = tmp\_pair;
656 
657      tmp\_pair.first=1; tmp\_pair.second=2;
658      std\_map\_indicies[4] = tmp\_pair;
659 
660      tmp\_pair.first=2; tmp\_pair.second=2;
661      std\_map\_indicies[5] = tmp\_pair;
662 
663     \textcolor{comment}{// Number of independent variables (6 for the tensor and 1 for the scalar phi)}
664      \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nbr\_dofs = 6+1;
665 
666     \textcolor{comment}{// Declaring the special data types containing all derivatives}
667      \textcolor{keyword}{typedef} Sacado::Fad::DFad<double> \hyperlink{Sacado__Wrapper_8h_a7e0893207b87dad05c66a34baac8ed2e}{DFadType};
668      SymmetricTensor<2,dim, Sacado::Fad::DFad<DFadType> > eps\_fad, eps\_fad\_squared;
669      Sacado::Fad::DFad<DFadType> phi\_fad;
670 
671 
672     \textcolor{comment}{// Setting the dofs}
673      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0; x<6; ++x )
674      \{
675         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=std\_map\_indicies[x].first;
676         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=std\_map\_indicies[x].second;
677         (eps\_fad[i][j]).diff( x, nbr\_dofs); \textcolor{comment}{// set up the "inner" derivatives}
678         (eps\_fad[i][j]).val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, x, eps[i][j]); \textcolor{comment}{// set up the "outer"
       derivatives}
679      \}
680 
681      phi\_fad.diff( 6, nbr\_dofs );
682      phi\_fad.val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, 6, phi); \textcolor{comment}{// set up the "outer" derivatives}
683 
684      std::cout << \textcolor{stringliteral}{"eps\_fad="} << eps\_fad << std::endl;
685      std::cout << \textcolor{stringliteral}{"phi\_fad="} << phi\_fad << std::endl;
686 
687     \textcolor{comment}{// Compute eps² = eps\_ij * eps\_jk in index notation}
688      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
689         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k )
690             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
691                 \textcolor{keywordflow}{if} ( i>=k )
692                     eps\_fad\_squared[i][k] += eps\_fad[i][j] * eps\_fad[j][k];
693 
694     \textcolor{comment}{// Compute the strain energy density}
695      Sacado::Fad::DFad<DFadType> energy;
696      energy = lambda/2. * trace(eps\_fad)*trace(eps\_fad) + mu * trace(eps\_fad\_squared) + 25 * phi\_fad * 
      trace(eps\_fad);
697 
698     \textcolor{comment}{// Give some insight into the storage of the values and derivatives}
699      std::cout << \textcolor{stringliteral}{"energy="} << energy << std::endl;
700 
701     \textcolor{comment}{// Compute sigma as \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\} \(\backslash\)f]}
702      SymmetricTensor<2,dim> sigma\_Sac;
703      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0; x<6; ++x )
704      \{
705         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=std\_map\_indicies[x].first;
706         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=std\_map\_indicies[x].second;
707         \textcolor{keywordflow}{if} ( i!=j )
708             sigma\_Sac[i][j] = 0.5 * energy.dx(x).val();
709         \textcolor{keywordflow}{else}
710             sigma\_Sac[i][j] = energy.dx(x).val();
711      \}
712      std::cout << \textcolor{stringliteral}{"sigma\_Sacado="} << sigma\_Sac << std::endl;
713 
714      \textcolor{keywordtype}{double} d\_energy\_d\_phi = energy.dx(6).val();
715      std::cout << \textcolor{stringliteral}{"d\_energy\_d\_phi="} << d\_energy\_d\_phi << std::endl;
716 
717     \textcolor{comment}{// Analytical stress tensor:}
718      SymmetricTensor<2,dim> sigma;
719      sigma = lambda*trace(eps)*unit\_symmetric\_tensor<dim>() + 2. * mu * eps;
720      std::cout << \textcolor{stringliteral}{"analy. sigma="} << sigma << std::endl;
721 
722 
723     \textcolor{comment}{// Sacado-Tangent}
724      SymmetricTensor<4,dim> C\_Sac;
725      \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0;x<6;++x)
726         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} y=0;y<6;++y)
727         \{
728             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=std\_map\_indicies[y].first;
729             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=std\_map\_indicies[y].second;
730             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=std\_map\_indicies[x].first;
731             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=std\_map\_indicies[x].second;
732 
733             \textcolor{keywordtype}{double} deriv = energy.dx(x).dx(y); \textcolor{comment}{// Access the derivatives of the (i,j)-th component of \(\backslash\)a
       sigma}
734 
735             \textcolor{keywordflow}{if} ( k!=l && i!=j )
736                 C\_Sac[i][j][k][l] = 0.25* deriv;
737             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(k!=l)\textcolor{comment}{/*Compare to Voigt notation since only SymmetricTensor instead of Tensor*/}
738             \{
739                 C\_Sac[i][j][k][l] = 0.5*deriv;
740                 C\_Sac[i][j][l][k] = 0.5*deriv;
741             \}
742             \textcolor{keywordflow}{else}
743                 C\_Sac[i][j][k][l] = deriv;
744         \}
745 
746      \textcolor{keywordtype}{double} d2\_energy\_d\_phi\_2 = energy.dx(6).dx(6);
747      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_phi\_2="} << d2\_energy\_d\_phi\_2 << std::endl;
748 
749      SymmetricTensor<2,dim> d2\_energy\_d\_eps\_d\_phi;
750 
751      SymmetricTensor<2,dim, Sacado::Fad::DFad<DFadType> > sigma\_Sac\_full;
752      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0; x<6; ++x )
753      \{
754         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=std\_map\_indicies[x].first;
755         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=std\_map\_indicies[x].second;
756         \textcolor{keywordflow}{if} ( i!=j )
757             sigma\_Sac\_full[i][j] = 0.5 * energy.dx(x);
758         \textcolor{keywordflow}{else}
759             sigma\_Sac\_full[i][j] = energy.dx(x);
760      \}
761 
762      std::cout << \textcolor{stringliteral}{"sigma\_Sac\_full="} << sigma\_Sac\_full << std::endl;
763      d2\_energy\_d\_eps\_d\_phi[0][0] = sigma\_Sac\_full[0][0].val().dx(6);
764      d2\_energy\_d\_eps\_d\_phi[1][1] = sigma\_Sac\_full[1][1].val().dx(6);
765      d2\_energy\_d\_eps\_d\_phi[2][2] = sigma\_Sac\_full[2][2].val().dx(6);
766      d2\_energy\_d\_eps\_d\_phi[0][1] = sigma\_Sac\_full[0][1].val().dx(6);
767      d2\_energy\_d\_eps\_d\_phi[0][2] = sigma\_Sac\_full[0][2].val().dx(6);
768      d2\_energy\_d\_eps\_d\_phi[1][2] = sigma\_Sac\_full[1][2].val().dx(6);
769 
770      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_eps\_d\_phi="} << d2\_energy\_d\_eps\_d\_phi << std::endl;
771 
772      SymmetricTensor<2,dim> d2\_energy\_d\_phi\_d\_eps;
773      d2\_energy\_d\_phi\_d\_eps[0][0] = energy.dx(6).dx(0);
774      d2\_energy\_d\_phi\_d\_eps[0][1] = energy.dx(6).dx(1);
775      d2\_energy\_d\_phi\_d\_eps[0][2] = energy.dx(6).dx(2);
776      d2\_energy\_d\_phi\_d\_eps[1][1] = energy.dx(6).dx(3);
777      d2\_energy\_d\_phi\_d\_eps[1][2] = energy.dx(6).dx(4);
778      d2\_energy\_d\_phi\_d\_eps[2][2] = energy.dx(6).dx(5);
779      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_phi\_d\_eps="} << d2\_energy\_d\_phi\_d\_eps << std::endl;
780 
781 
782     \textcolor{comment}{// Analytical tangent}
783      SymmetricTensor<4,dim> C\_analy;
784      C\_analy = lambda * outer\_product(unit\_symmetric\_tensor<dim>(), unit\_symmetric\_tensor<dim>()) + 2. * mu
       * identity\_tensor<dim>();
785 
786     \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
787     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
788         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
789             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
790                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
791                     error\_Sacado\_vs\_analy += std::fabs(C\_Sac[i][j][k][l] - C\_analy[i][j][k][l]);
792 
793     std::cout << \textcolor{stringliteral}{"Numerical error="} << error\_Sacado\_vs\_analy << std::endl;
794 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+8@{sacado\+\_\+test\+\_\+8}}
\index{sacado\+\_\+test\+\_\+8@{sacado\+\_\+test\+\_\+8}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+8()}{sacado_test_8()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+8 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}{}\label{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}


References Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double2$<$ dim $>$\+::get\+\_\+curvature(), Sacado\+\_\+\+Wrapper\+::\+Do\+Fs\+\_\+summary$<$ dim $>$\+::get\+\_\+curvature(), Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double2$<$ dim $>$\+::get\+\_\+tangent(), and Sacado\+\_\+\+Wrapper\+::\+Do\+Fs\+\_\+summary$<$ dim $>$\+::init\+\_\+set\+\_\+dofs().



Referenced by main().


\begin{DoxyCode}
801 \{
802     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
803 
804     std::cout << \textcolor{stringliteral}{"Test 8:"} << std::endl;
805 
806     \textcolor{comment}{// Defining the inputs (material parameters, strain tensor)}
807      \textcolor{keywordtype}{double} lambda=1;
808      \textcolor{keywordtype}{double} mu=2;
809      SymmetricTensor<2,dim, double> eps;
810      \textcolor{keywordtype}{double} phi = 0.3;
811 
812      eps[0][0] = 1.;
813      eps[1][1] = 2.;
814      eps[2][2] = 3.;
815 
816      eps[0][1] = 4.;
817      eps[0][2] = 5.;
818      eps[1][2] = 6.;
819 
820     \textcolor{comment}{// Declaring the special data types containing all derivatives}
821      \textcolor{keyword}{typedef} Sacado::Fad::DFad<double> \hyperlink{Sacado__Wrapper_8h_a7e0893207b87dad05c66a34baac8ed2e}{DFadType};
822 
823     \textcolor{comment}{// Declare the variables \(\backslash\)a eps\_fad and \(\backslash\)a phi\_fad as the special Wrapper data types}
824      \hyperlink{classSacado__Wrapper_1_1SymTensor2}{Sacado\_Wrapper::SymTensor2<dim>} eps\_fad;
825      \hyperlink{classSacado__Wrapper_1_1SW__double2}{Sacado\_Wrapper::SW\_double2<dim>} phi\_fad;
826 
827     \textcolor{comment}{// Declare the summary data type relating all the dofs and initialising them too}
828      \hyperlink{classSacado__Wrapper_1_1DoFs__summary}{Sacado\_Wrapper::DoFs\_summary<dim>} DoFs\_summary;
829      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_ae273d0fa3197118a11d7005523e27d8a}{init\_set\_dofs}(eps\_fad, eps, phi\_fad, phi);
830 
831     \textcolor{comment}{// The variables are outputted to give some insight into the storage of the values (derivatives still
       trivial).}
832      std::cout << \textcolor{stringliteral}{"eps\_fad="} << eps\_fad << std::endl;
833      std::cout << \textcolor{stringliteral}{"phi\_fad="} << phi\_fad << std::endl;
834 
835     \textcolor{comment}{// Compute eps² = eps\_ij * eps\_jk in index notation}
836      SymmetricTensor<2,dim, Sacado::Fad::DFad<DFadType> > eps\_fad\_squared;
837      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
838         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k )
839             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
840                 \textcolor{keywordflow}{if} ( i>=k )
841                     eps\_fad\_squared[i][k] += eps\_fad[i][j] * eps\_fad[j][k];
842 
843     \textcolor{comment}{// Compute the strain energy density}
844      Sacado::Fad::DFad<DFadType> energy;
845      energy = lambda/2. * trace(eps\_fad)*trace(eps\_fad) + mu * trace(eps\_fad\_squared) + 25 * phi\_fad * 
      trace(eps\_fad);
846 
847     \textcolor{comment}{// The energy is outputted (formatted by hand) to give some insight into the storage of the values and
       derivatives. \(\backslash\)n}
848     \textcolor{comment}{// energy=399 [ 17.5 32 40 21.5 48 25.5 150 ] \(\backslash\)n}
849     \textcolor{comment}{//              [ 17.5 [ 5 0 0 1 0 1 25 ] 32 [ 0 8 0 0 0 0 0 ] 40 [ 0 0 8 0 0 0 0 ] \(\backslash\)n}
850     \textcolor{comment}{//              21.5 [ 1 0 0 5 0 1 25 ] 48 [ 0 0 0 0 8 0 0 ] 25.5 [ 1 0 0 1 0 5 25 ] \(\backslash\)n}
851     \textcolor{comment}{//              150 [ 25 0 0 25 0 25 0 ] ]}
852 
853      std::cout << \textcolor{stringliteral}{"energy="} << energy << std::endl;
854 
855     \textcolor{comment}{// Compute sigma as \(\backslash\)f[ \(\backslash\)boldsymbol\{\(\backslash\)sigma\} = \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\}
       \(\backslash\)f]}
856      SymmetricTensor<2,dim> sigma\_Sac;
857      eps\_fad.get\_tangent(sigma\_Sac, energy);
858      std::cout << \textcolor{stringliteral}{"sigma\_Sacado="} << sigma\_Sac << std::endl;
859 
860      \textcolor{keywordtype}{double} d\_energy\_d\_phi;
861      phi\_fad.\hyperlink{classSacado__Wrapper_1_1SW__double2_ad51ba1e79171d60861b28098dfef903d}{get\_tangent}(d\_energy\_d\_phi, energy);
862      std::cout << \textcolor{stringliteral}{"d\_energy\_d\_phi="} << d\_energy\_d\_phi << std::endl;
863 
864 
865     \textcolor{comment}{// Analytical stress tensor:}
866      SymmetricTensor<2,dim> sigma;
867      sigma = lambda*trace(eps)*unit\_symmetric\_tensor<dim>() + 2. * mu * eps;
868      std::cout << \textcolor{stringliteral}{"analy. sigma="} << sigma << std::endl;
869 
870 
871     \textcolor{comment}{// Sacado stress tangent (or eps curvature) as \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial
       \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}^2\} \(\backslash\)f]}
872      SymmetricTensor<4,dim> C\_Sac;
873      eps\_fad.get\_curvature(C\_Sac, energy);
874 
875     \textcolor{comment}{// Sacado phi curvature as \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)varphi^2\} \(\backslash\)f]}
876      \textcolor{keywordtype}{double} d2\_energy\_d\_phi\_2;
877      phi\_fad.\hyperlink{classSacado__Wrapper_1_1SW__double2_a7d3f3a21cd842645af9861bf50308825}{get\_curvature}(d2\_energy\_d\_phi\_2, energy);
878      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_phi\_2="} << d2\_energy\_d\_phi\_2 << std::endl;
879 
880     \textcolor{comment}{// Sacado derivatives \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\} \(\backslash\)partial \(\backslash\)varphi\}
       \(\backslash\)f]}
881      SymmetricTensor<2,dim> d2\_energy\_d\_eps\_d\_phi;
882      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_adf29bfda10814ecee9572a4751d34db0}{get\_curvature}(d2\_energy\_d\_eps\_d\_phi, energy, eps\_fad, phi\_fad);
883      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_eps\_d\_phi="} << d2\_energy\_d\_eps\_d\_phi << std::endl;
884 
885     \textcolor{comment}{// Sacado derivatives \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)varphi \(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\}
       \(\backslash\)f]}
886      SymmetricTensor<2,dim> d2\_energy\_d\_phi\_d\_eps;
887      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_adf29bfda10814ecee9572a4751d34db0}{get\_curvature}(d2\_energy\_d\_phi\_d\_eps, energy, phi\_fad, eps\_fad);
888      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_phi\_d\_eps="} << d2\_energy\_d\_phi\_d\_eps << std::endl;
889 
890     \textcolor{comment}{// When you consider the output: \(\backslash\)n}
891     \textcolor{comment}{// d2\_energy\_d\_eps\_d\_phi=25 0 0 0 25 0 0 0 25 \(\backslash\)n}
892     \textcolor{comment}{// d2\_energy\_d\_phi\_d\_eps=25 0 0 0 25 0 0 0 25 \(\backslash\)n}
893     \textcolor{comment}{// in detail you will notice that both second derivatives are identical. This compplies with the
       Schwarz integrability condition (Symmetry of second derivatives)}
894     \textcolor{comment}{// (ignoring all limitation and requirements), it holds}
895     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\} \(\backslash\)partial \(\backslash\)varphi\} = \(\backslash\)frac\{\(\backslash\)partial^2
       \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)varphi \(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\}  \(\backslash\)f]}
896 
897     \textcolor{comment}{// Analytical stress tangent}
898      SymmetricTensor<4,dim> C\_analy;
899      C\_analy = lambda * outer\_product(unit\_symmetric\_tensor<dim>(), unit\_symmetric\_tensor<dim>()) + 2. * mu
       * identity\_tensor<dim>();
900 
901     \textcolor{comment}{// Compute the error for the stress tangent}
902      \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
903      \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
904         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
905             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
906                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
907                     error\_Sacado\_vs\_analy += std::fabs(C\_Sac[i][j][k][l] - C\_analy[i][j][k][l]);
908      std::cout << \textcolor{stringliteral}{"Numerical error="} << error\_Sacado\_vs\_analy << std::endl;
909 \}
\end{DoxyCode}
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+scalar@{sacado\+\_\+test\+\_\+scalar}}
\index{sacado\+\_\+test\+\_\+scalar@{sacado\+\_\+test\+\_\+scalar}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection[{\texorpdfstring{sacado\+\_\+test\+\_\+scalar()}{sacado_test_scalar()}}]{\setlength{\rightskip}{0pt plus 5cm}void sacado\+\_\+test\+\_\+scalar (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}{}\label{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}


References c.



Referenced by main().


\begin{DoxyCode}
39 \{
40     std::cout << \textcolor{stringliteral}{"Scalar Test:"} << std::endl;
41     \textcolor{comment}{// define the variables used in the computation (inputs: a, b; output: c; auxiliaries: *) as the
       Sacado-data type}
42      \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} a,b,\hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c};
43     \textcolor{comment}{// initialize the input variables a and b; This (a,b) = (1,2) will be the point where the derivatives
       are computed.}
44     \textcolor{comment}{// Compare: y=x² -> (dy/dx)(\(\backslash\)@x=1) = 2. We can only compute the derivative numerically at a certain
       point.}
45      a = 1;
46      b = 2;
47 
48     a.diff(0,2);  \textcolor{comment}{// Set a to be dof 0, in a 2-dof system.}
49     b.diff(1,2);  \textcolor{comment}{// Set b to be dof 1, in a 2-dof system.}
50     \textcolor{comment}{// Our equation here is very simply. But you can use nested equations and many standard mathematical
       operations, such as sqrt, pow, sin, ...}
51     c = 2*a + std::cos(a*b);
52     \textcolor{keywordtype}{double} *derivs = &c.fastAccessDx(0); \textcolor{comment}{// Access the derivatives of}
53     \textcolor{comment}{// Output the derivatives of c with respect to the two above defined degrees of freedom (dof)}
54     std::cout << \textcolor{stringliteral}{"Derivatives at the point ("} << a << \textcolor{stringliteral}{","} << b << \textcolor{stringliteral}{")"} << std::endl;
55     std::cout << \textcolor{stringliteral}{"dc/da = "} << derivs[0] << \textcolor{stringliteral}{", dc/db="} << derivs[1] << std::endl;
56 \}
\end{DoxyCode}
