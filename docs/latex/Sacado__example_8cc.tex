\hypertarget{Sacado__example_8cc}{}\section{Sacado\+\_\+example.\+cc File Reference}
\label{Sacado__example_8cc}\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
{\ttfamily \#include $<$deal.\+I\+I/base/symmetric\+\_\+tensor.\+h$>$}\newline
{\ttfamily \#include $<$iostream$>$}\newline
{\ttfamily \#include $<$fstream$>$}\newline
{\ttfamily \#include $<$cmath$>$}\newline
{\ttfamily \#include $<$Sacado.\+hpp$>$}\newline
{\ttfamily \#include \char`\"{}Sacado\+\_\+\+Wrapper.\+h\char`\"{}}\newline
Include dependency graph for Sacado\+\_\+example.\+cc\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{Sacado__example_8cc__incl}
\end{center}
\end{figure}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\+\_\+double} = Sacado\+::\+Fad\+::\+D\+Fad$<$ double $>$
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}{sacado\+\_\+test\+\_\+scalar} ()
\item 
void \hyperlink{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}{sacado\+\_\+test\+\_\+2} ()
\item 
void \hyperlink{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}{sacado\+\_\+test\+\_\+3} ()
\item 
void \hyperlink{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}{sacado\+\_\+test\+\_\+3B} ()
\item 
void \hyperlink{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}{sacado\+\_\+test\+\_\+4} ()
\item 
void \hyperlink{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}{sacado\+\_\+test\+\_\+5} ()
\item 
void \hyperlink{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}{sacado\+\_\+test\+\_\+6} ()
\item 
void \hyperlink{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}{sacado\+\_\+test\+\_\+7} ()
\item 
void \hyperlink{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}{sacado\+\_\+test\+\_\+8} ()
\item 
void \hyperlink{Sacado__example_8cc_ae176f83fe1943e102fe325d4a14f097e}{sacado\+\_\+test\+\_\+9} ()
\item 
int \hyperlink{Sacado__example_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main} ()
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\mbox{\Hypertarget{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}\label{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!fad\+\_\+double@{fad\+\_\+double}}
\index{fad\+\_\+double@{fad\+\_\+double}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{fad\+\_\+double}{fad\_double}}
{\footnotesize\ttfamily using \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\+\_\+double} =  Sacado\+::\+Fad\+::\+D\+Fad$<$double$>$}



\subsection{Function Documentation}
\mbox{\Hypertarget{Sacado__example_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}\label{Sacado__example_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!main@{main}}
\index{main@{main}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{main()}{main()}}
{\footnotesize\ttfamily int main (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



References sacado\+\_\+test\+\_\+2(), sacado\+\_\+test\+\_\+3(), sacado\+\_\+test\+\_\+3\+B(), sacado\+\_\+test\+\_\+4(), sacado\+\_\+test\+\_\+5(), sacado\+\_\+test\+\_\+6(), sacado\+\_\+test\+\_\+7(), sacado\+\_\+test\+\_\+8(), sacado\+\_\+test\+\_\+9(), and sacado\+\_\+test\+\_\+scalar().


\begin{DoxyCode}
1053 \{
1054     \hyperlink{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}{sacado\_test\_scalar} ();
1055 
1056     std::cout << std::endl;
1057 
1058     \hyperlink{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}{sacado\_test\_2} ();
1059 
1060     std::cout << std::endl;
1061 
1062     \hyperlink{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}{sacado\_test\_3} ();
1063 
1064     std::cout << std::endl;
1065 
1066     \hyperlink{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}{sacado\_test\_3B} ();
1067 
1068     std::cout << std::endl;
1069 
1070     \hyperlink{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}{sacado\_test\_4}();
1071 
1072     std::cout << std::endl;
1073 
1074     \hyperlink{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}{sacado\_test\_5}();
1075 
1076     std::cout << std::endl;
1077 
1078     \hyperlink{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}{sacado\_test\_6}();
1079 
1080     std::cout << std::endl;
1081 
1082     \hyperlink{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}{sacado\_test\_7}();
1083 
1084     std::cout << std::endl;
1085 
1086     \hyperlink{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}{sacado\_test\_8}();
1087 
1088     std::cout << std::endl;
1089 
1090     \hyperlink{Sacado__example_8cc_ae176f83fe1943e102fe325d4a14f097e}{sacado\_test\_9}();
1091 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}\label{Sacado__example_8cc_a8ef4ff1e9526ca8451cdcd1678366d2c}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+2@{sacado\+\_\+test\+\_\+2}}
\index{sacado\+\_\+test\+\_\+2@{sacado\+\_\+test\+\_\+2}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+2()}{sacado\_test\_2()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+2 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Referenced by main().


\begin{DoxyCode}
68 \{
69     std::cout << \textcolor{stringliteral}{"Test 2:"} << std::endl;
70 
71     \textcolor{comment}{// First we set the dimension \(\backslash\)a dim: 2D->dim=2; 3D->dim=3 \(\backslash\)n This defines the "size" of the tensors
       and the number of dofs. \(\backslash\)ref Ex2 "Example 2" only works in 3D, whereas the following Ex3 is set up
       dimension-independent.}
72     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim = 3;
73 
74     \textcolor{comment}{// Declare our input, auxiliary and output variables as SymmetricTensors consisting of fad\_doubles
       (instead of the standard SymmetricTensor out of doubles)}
75     SymmetricTensor<2,dim, fad\_double> sigma, eps;
76 
77     \textcolor{comment}{// Init the strain tensor (the point at which the derivative shall be computed)}
78     eps[0][0] = 1;
79     eps[1][1] = 2;
80     eps[2][2] = 3;
81     eps[0][1] = 4;
82     eps[0][2] = 5;
83     eps[1][2] = 6;
84 
85     \textcolor{comment}{// Now we declare the dofs. The derivative to a tensor requires all components, therefore we set the
       components of the strain tensor here one by one as the dofs.}
86     \textcolor{comment}{// Because our tensors are symmetric, we only need 6 components in 3D instead of 9 for a full second
       order tensor}
87     eps[0][0].diff(0,6);
88     eps[1][1].diff(1,6);
89     eps[2][2].diff(2,6);
90     eps[0][1].diff(3,6);
91     eps[0][2].diff(4,6);
92     eps[1][2].diff(5,6);
93 
94     \textcolor{comment}{// The equation describing the stresses (here just a simple test case)}
95     sigma = eps;
96 
97     \textcolor{comment}{// Let's output the computed stress tensor.}
98     std::cout << sigma << std::endl;
99     \textcolor{comment}{// The resulting values of \(\backslash\)a sigma are fairly boring, due to our simple equation. It is the additional
       output generated by}
100     \textcolor{comment}{// this, that is interesting here: \(\backslash\)n}
101     \textcolor{comment}{// output: \(\backslash\)n}
102     \textcolor{comment}{// 1 [ 1 0 0 0 0 0 ] 4 [ 0 0 0 1 0 0 ] 5 [ 0 0 0 0 1 0 ] 4 [ 0 0 0 1 0 0 ] 2 [ 0 1 0 0 0 0 ] 6 [ 0 0 0
       0 0 1 ] 5 [ 0 0 0 0 1 0 ] 6 [ 0 0 0 0 0 1 ] 3 [ 0 0 1 0 0 0 ] \(\backslash\)n}
103     \textcolor{comment}{// The numbers 1, 4, 5, 4, ... are the entries in the stress tensor \(\backslash\)a sigma. In square brackets we see
       the derivatives of sigma with respect to all the dofs set previously}
104     \textcolor{comment}{// given in the order we defined them above. Meaning: The first entry in the square brackets
       corresponds to the 0-th dof set by}
105     \textcolor{comment}{// @code eps[0][0].diff(0,6); @endcode referring to the component (0,0) in the strain tensor \(\backslash\)a eps.}
106 
107     \textcolor{comment}{// Computing the derivatives for certain components of the resulting tangent modulus: \(\backslash\)n}
108     \textcolor{comment}{// We now access these lists of derivatives (output above in square brackets) for one component of the
       stress tensor \(\backslash\)a sigma at a time.}
109     \{
110         \textcolor{comment}{// Access the derivatives corresponding to the component (0,0) of the stress tensor \(\backslash\)a sigma}
111         \textcolor{keywordtype}{double} *derivs = &sigma[0][0].fastAccessDx(0);
112         \textcolor{comment}{// The following output will show us the same derivatives that we already saw above, just formatted
       differently \(\backslash\)n}
113         \textcolor{comment}{// output: d\_sigma[0][0]/d\_eps = 1 , 0 , 0 , 0 , 0 , 0 ,}
114         std::cout << \textcolor{stringliteral}{"d\_sigma[0][0]/d\_eps = "};
115         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<6; ++i)
116             std::cout << derivs[i] << \textcolor{stringliteral}{" , "};
117         std::cout << std::endl;
118     \}
119     \{
120         \textcolor{comment}{// Access the derivatives corresponding to the component (1,2) of the stress tensor \(\backslash\)a sigma}
121         \textcolor{keywordtype}{double} *derivs = &sigma[1][2].fastAccessDx(0);
122         \textcolor{comment}{// output: d\_sigma[1][2]/d\_eps = 0 , 0 , 0 , 0 , 0 , 1 ,}
123         std::cout << \textcolor{stringliteral}{"d\_sigma[1][2]/d\_eps = "};
124         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<6; ++i)
125             std::cout << derivs[i] << \textcolor{stringliteral}{" , "};
126         std::cout << std::endl;
127     \}
128 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}\label{Sacado__example_8cc_ae45e1df0eec246dbb6f2c3d28a2a58e4}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+3@{sacado\+\_\+test\+\_\+3}}
\index{sacado\+\_\+test\+\_\+3@{sacado\+\_\+test\+\_\+3}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+3()}{sacado\_test\_3()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+3 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Referenced by main().


\begin{DoxyCode}
133 \{
134     std::cout << \textcolor{stringliteral}{"Test 3:"} << std::endl;
135 
136     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim = 3;
137 
138     \textcolor{comment}{// Here we also define some constant, for instance the bulk modulus \(\backslash\)a kappa and the second Lamè
       parameter \(\backslash\)a mu.}
139     \textcolor{comment}{// We now also define one of our constants as fad\_double. By doing this we can use the normal
       multiplication (see below).}
140     \textcolor{keywordtype}{double} kappa\_param = 5;
141     \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} kappa (kappa\_param);
142     \textcolor{comment}{// The second constant remains as a double just to show the difference.}
143     \textcolor{keywordtype}{double} mu = 2;
144 
145     SymmetricTensor<2,dim, fad\_double> sigma, eps;
146 
147     \textcolor{comment}{// To simplify the access to the dofs we define a map that relate the components of our strain tensor
       to the dof-nbr}
148     std::map<unsigned int,std::pair<unsigned int,unsigned int>> std\_map\_indicies;
149 
150     \textcolor{comment}{// The point at which the derivative shall be computed: \(\backslash\)n}
151     \textcolor{comment}{// As mentioned previously, we will implement this example for 2D and 3D, hence we once have to set up
       a strain tensor}
152     \textcolor{comment}{// and the derivatives for 3D with 6 independent components ...}
153     \textcolor{keywordflow}{if}(dim==3)
154     \{
155         eps[0][0] = 1;
156         eps[1][1] = 2;
157         eps[2][2] = 3;
158         
159         eps[0][1] = 4;
160         eps[0][2] = 5;
161         eps[1][2] = 6;
162         
163         
164         eps[0][0].diff(0,6);
165         eps[0][1].diff(1,6);
166         eps[0][2].diff(2,6);
167         eps[1][1].diff(3,6);
168         eps[1][2].diff(4,6);
169         eps[2][2].diff(5,6);
170         
171         \textcolor{comment}{// By using the map and the following pairs, we have to set up the relation between strain
       components and dofs only once}
172         \textcolor{comment}{// and can use the map to access the entries of the list later, without possibly mixing up indices
       and creating errors.}
173         \textcolor{comment}{// Please don't be confused, but the dofs in the Wrapper are set up}
174         \textcolor{comment}{// in a different order that we showed earlier. Earlier: (0,0)-(1,1)-(2,2)-...; Now:
       (0,0)-(0,1)-(0,2)-...}
175         std::pair<unsigned int, unsigned int> tmp\_pair;
176         tmp\_pair.first=0; tmp\_pair.second=0;
177         std\_map\_indicies[0] = tmp\_pair;
178 
179         tmp\_pair.first=0; tmp\_pair.second=1;
180         std\_map\_indicies[1] = tmp\_pair;
181 
182         tmp\_pair.first=0; tmp\_pair.second=2;
183         std\_map\_indicies[2] = tmp\_pair;
184 
185         tmp\_pair.first=1; tmp\_pair.second=1;
186         std\_map\_indicies[3] = tmp\_pair;
187 
188         tmp\_pair.first=1; tmp\_pair.second=2;
189         std\_map\_indicies[4] = tmp\_pair;
190 
191         tmp\_pair.first=2; tmp\_pair.second=2;
192         std\_map\_indicies[5] = tmp\_pair;
193     \}
194     \textcolor{comment}{// ... and once for 2D with just 3 independent components.}
195     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(dim==2)
196     \{
197         eps[0][0] = 1;
198         eps[1][1] = 2;
199         
200         eps[0][1] = 4;
201 
202                 
203         eps[0][0].diff(0,3);
204         eps[0][1].diff(1,3);
205         eps[1][1].diff(2,3);
206         
207         std::pair<unsigned int, unsigned int> tmp\_pair;
208         tmp\_pair.first=0; tmp\_pair.second=0;
209         std\_map\_indicies[0] = tmp\_pair;
210         
211         tmp\_pair.first=0; tmp\_pair.second=1;
212         std\_map\_indicies[1] = tmp\_pair;
213         
214         tmp\_pair.first=1; tmp\_pair.second=1;
215         std\_map\_indicies[2] = tmp\_pair;        
216     \}
217     \textcolor{keywordflow}{else}
218     \{
219         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"only dim==2 or dim==3 allowed"});
220     \}
221 
222     \textcolor{comment}{// Instead of calling the *.diff(*) on the components one-by-one we could also use the following
       for-loop, so}
223     \textcolor{comment}{// we also use the map to set the dofs (as we will do in the Wrapper later).}
224     \textcolor{comment}{// @code}
225     \textcolor{comment}{// for ( unsigned int x=0; x<((dim==2)?3:6); ++x )}
226     \textcolor{comment}{// \{}
227     \textcolor{comment}{//  unsigned int i=std\_map\_indicies[x].first;}
228     \textcolor{comment}{//  unsigned int j=std\_map\_indicies[x].second;}
229     \textcolor{comment}{//  eps[i][j].diff(x,((dim==2)?3:6));}
230     \textcolor{comment}{// \}}
231     \textcolor{comment}{// @endcode}
232 
233     \textcolor{comment}{// For our slightly more complicated stress equation we need the unit and deviatoric tensors.}
234     \textcolor{comment}{// We can simply define them by writing the values of the already existing deal.ii functions into newly}
235     \textcolor{comment}{// defined SymmetricTensors build from fad\_doubles.}
236     SymmetricTensor<2,dim, fad\_double> stdTensor\_I (( unit\_symmetric\_tensor<dim,fad\_double>()) );
237     SymmetricTensor<4,dim, fad\_double> stdTensor\_Idev ( (deviator\_tensor<dim,fad\_double>()) );
238     
239     \textcolor{comment}{// With everything set and defined, we can compute our stress \(\backslash\)a sigma according to:}
240     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)sigma = \(\backslash\)kappa \(\backslash\)cdot trace(\(\backslash\)varepsilon) \(\backslash\)cdot \(\backslash\)boldsymbol\{I\} + 2 \(\backslash\)cdot \(\backslash\)mu \(\backslash\)cdot
       \(\backslash\)varepsilon^\{dev\} \(\backslash\)f]}
241     \textcolor{comment}{// Here you can see that we can directly multiply the constant and the tensors when kappa is also
       declared as fad\_double}
242     sigma = kappa * (trace(eps) *  stdTensor\_I);
243     \textcolor{comment}{// We didn't do the same for mu to once again emphasize the difference between constants as double and
       as fad\_double. \(\backslash\)n}
244     \textcolor{comment}{// The remaining code uses a normal double constant.}
245     SymmetricTensor<2,dim,fad\_double> tmp = deviator<dim,fad\_double>(symmetrize<dim,fad\_double>(eps)); tmp*
      =(mu*2);
246     sigma +=  tmp;
247     \textcolor{comment}{// The fairly cumbersome computation is caused by the way the operators are set up for tensors out of
       fad\_doubles.}
248     
249     std::cout << \textcolor{stringliteral}{"sigma="} << sigma << std::endl;
250 
251     \textcolor{comment}{// Now we want to actually build our tangent modulus called \(\backslash\)a C\_Sacado that contains all the
       derivatives and relates}
252     \textcolor{comment}{// the stress tensor with the strain tensor. \(\backslash\)n}
253     \textcolor{comment}{// The fourth-order tensor \(\backslash\)a C\_Sacado is our final goal, we don't have to compute anything that is
       related to Sacado with}
254     \textcolor{comment}{// this tensor, so we can finally return to our standard SymmetricTensor out of doubles. The latter is
       necessary to use}
255     \textcolor{comment}{// the tangent in the actual FE code.}
256     SymmetricTensor<4,dim> C\_Sacado;
257 
258     \textcolor{comment}{// As in \(\backslash\)ref Ex2 "example 2" we access the components of the stress tensor one by one. In order to
       capture all of them we loop over the}
259     \textcolor{comment}{// components i and j of the stress tensor.}
260     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
261         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
262         \{
263             \textcolor{keywordtype}{double} *derivs = &sigma[i][j].fastAccessDx(0); \textcolor{comment}{// Access the derivatives of the (i,j)-th
       component of \(\backslash\)a sigma}
264 
265             \textcolor{comment}{// To visually ensure that every stress component has in fact all 6 derivatives for 3D or 3 for
       2D, we output the size:}
266             std::cout<<\textcolor{stringliteral}{"size: "}<<sigma[i][j].size()<<std::endl;
267 
268             \textcolor{comment}{// We loop over all the dofs. To be able to use this independent of the chosen dimension \(\backslash\)a
       dim, we use a ternary operator}
269             \textcolor{comment}{// to decide whether we have to loop over 6 derivatives or just 3.}
270             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0;x<((dim==2)?3:6);++x)
271             \{
272                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=std\_map\_indicies[x].first;
273                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=std\_map\_indicies[x].second;
274 
275                 \textcolor{keywordflow}{if}(k!=l)\textcolor{comment}{/*Compare to Voigt notation since only SymmetricTensor instead of Tensor*/}
276                 \{
277                     C\_Sacado[i][j][k][l] = 0.5*derivs[x];
278                     C\_Sacado[i][j][l][k] = 0.5*derivs[x];
279                 \}
280                 \textcolor{keywordflow}{else}
281                     C\_Sacado[i][j][k][l] = derivs[x];
282             \}            
283             
284         \}
285 
286     \textcolor{comment}{// After resembling the fourth-order tensor, we now have got our tangent saved in \(\backslash\)a C\_Sacado ready to
       be used}
287 
288     \textcolor{comment}{// To ensure that Sacado works properly, we can compute the analytical tangent for comparison}
289     \textcolor{keywordtype}{double} kappa\_d = 5;
290     \textcolor{keywordtype}{double} mu\_d = 2;
291     \textcolor{comment}{// Our stress equation in this example is still simple enough to derive the tangent analytically by
       hand:}
292     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)overset\{4\}\{C\_\{analy\}\} = \(\backslash\)kappa \(\backslash\)cdot \(\backslash\)boldsymbol\{I\} \(\backslash\)otimes \(\backslash\)boldsymbol\{I\} + 2 \(\backslash\)cdot \(\backslash\)mu \(\backslash\)cdot
       \(\backslash\)overset\{4\}\{I^\{dev\}\} \(\backslash\)f]}
293     SymmetricTensor<4,dim> C\_analy = kappa\_d * outer\_product(unit\_symmetric\_tensor<dim>(), 
      unit\_symmetric\_tensor<dim>()) + 2* mu\_d * deviator\_tensor<dim>();
294 
295 
296     \textcolor{comment}{// We again define our strain tensor \(\backslash\)a eps\_d (*\_d for standard double in contrast to fad\_double)}
297     SymmetricTensor<2,dim> eps\_d;
298     
299     \textcolor{keywordflow}{if}(dim==3)
300     \{
301         eps\_d[0][0] = 1;
302         eps\_d[1][1] = 2;
303         eps\_d[2][2] = 3;
304         
305         eps\_d[0][1] = 4;
306         eps\_d[0][2] = 5;
307         eps\_d[2][1] = 6;
308 
309     \}
310     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(dim==2)
311     \{
312         eps\_d[0][0] = 1;
313         eps\_d[1][1] = 2;
314         
315         eps\_d[1][0] = 4;
316         
317     \}
318     \textcolor{keywordflow}{else}
319     \{
320         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"only dim==2 or dim==3 allowed"});
321     \}
322     \textcolor{comment}{// @todo use boldsymbol for tensors}
323     \textcolor{comment}{//}
324     \textcolor{comment}{// To output the stress tensor we first have to compute it. We do this here via}
325     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)sigma = \(\backslash\)overset\{4\}\{C\_\{analy\}\} : \(\backslash\)varepsilon \(\backslash\)f]}
326     \textcolor{comment}{// The output exactly matched the result obtained with Sacado.}
327     \textcolor{comment}{// @note Checking the Sacado stress tensor against an analytically computed or otherwise determined
       stress tensor is absolutely no way to check whether}
328     \textcolor{comment}{// the tangent computed via Sacado is correct. When we compute the stress tensor with Sacado and for
       example mix up a + and - sign, this might not matter}
329     \textcolor{comment}{// at all if the number that is added or subtracted is small. However, for the tangent this nasty sign
       can be very critical. Just keep in mind: the}
330     \textcolor{comment}{// tangent has 81 components and the stress tensor just 9, so how does one want to verify 81 variables
       by comparing 9?}
331     \textcolor{comment}{//}
332     std::cout << \textcolor{stringliteral}{"sigma\_analy: "} << (C\_analy*eps\_d) << std::endl;
333     
334     \textcolor{comment}{// That's the reason we compare all the entries in the Sacado and the analytical tensor one by one}
335     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
336         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
337             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
338                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
339                     std::cout << \textcolor{stringliteral}{"C\_analy["}<<i<<\textcolor{stringliteral}{"]["}<<j<<\textcolor{stringliteral}{"]["}<<k<<\textcolor{stringliteral}{"]["}<<l<<\textcolor{stringliteral}{"] = "} << C\_analy[i][j][k][l] <<
       \textcolor{stringliteral}{" vs C\_Sacado: "} << C\_Sacado[i][j][k][l] << std::endl;
340 
341 
342     \textcolor{comment}{// To simplify the comparison we compute a scalar error as the sum of the absolute differences of each
       component}
343     \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
344     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
345         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
346             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
347                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
348                     error\_Sacado\_vs\_analy += std::fabs(C\_Sacado[i][j][k][l] - C\_analy[i][j][k][l]);
349                     
350 
351     \textcolor{comment}{// As desired: The numerical error is zero (0 in double precision) and the tensor components are equal}
352     std::cout << \textcolor{stringliteral}{"numerical error: "} << error\_Sacado\_vs\_analy << std::endl;
353 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}\label{Sacado__example_8cc_ae63cc8526935cb0512668e83cfc7b929}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+3B@{sacado\+\_\+test\+\_\+3B}}
\index{sacado\+\_\+test\+\_\+3B@{sacado\+\_\+test\+\_\+3B}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+3\+B()}{sacado\_test\_3B()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+3B (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



References Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::get\+\_\+tangent(), Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::init(), and Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::set\+\_\+dofs().



Referenced by main().


\begin{DoxyCode}
358 \{
359     std::cout << \textcolor{stringliteral}{"Test 3B:"} << std::endl;
360     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
361 
362     \textcolor{comment}{// The following declarations are usually input arguments. So you receive the strain tensor and the
       constants out of doubles.}
363     SymmetricTensor<2,dim> eps\_d;
364     eps\_d[0][0] = 1;
365     eps\_d[1][1] = 2;
366     eps\_d[2][2] = 3;
367 
368     eps\_d[0][1] = 4;
369     eps\_d[0][2] = 5;
370     eps\_d[1][2] = 6;
371 
372     \textcolor{keywordtype}{double} kappa = 5;
373     \textcolor{keywordtype}{double} mu = 2;
374 
375     \textcolor{comment}{// Now we start working with Sacado: \(\backslash\)n}
376     \textcolor{comment}{// When we use the index notation to compute e.g. our stress we do not need to declare our constants
       (here kappa, mu) as}
377     \textcolor{comment}{// fad\_double.}
378 
379     \textcolor{comment}{// We declare our strain tensor as the special data type Sacado\_Wrapper::SymTensor from the file
       "Sacado\_Wrapper.h"}
380     \textcolor{comment}{// where this data type was derived from the SymmetricTensor<2,dim,fad\_double>.}
381      \hyperlink{classSacado__Wrapper_1_1SymTensor}{Sacado\_Wrapper::SymTensor<dim>} eps;
382 
383     \textcolor{comment}{// Next we initialize our Sacado strain tensor with the values of the inputed double strain tensor:}
384      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_acbad579d5ead9e96ff46aa15d9b5aef4}{init}(eps\_d);
385 
386     \textcolor{comment}{// We define all the entries in the symmetric tensor \(\backslash\)a eps as the dofs. So we can later derive any
       variable}
387     \textcolor{comment}{// with respect to the strain tensor \(\backslash\)a eps.}
388     \textcolor{comment}{// @note Keep the order first declare \(\backslash\)a eps, then initialise it and afterwards set it as dofs}
389      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_aa9e0fcc9d4e0a4120bedb8ef9b8d7ecb}{set\_dofs}();
390 
391     \textcolor{comment}{// Now we declare our output and auxiliary variables as Sacado-Tensors.}
392      SymmetricTensor<2,dim,fad\_double> sigma;
393 
394      SymmetricTensor<2,dim, fad\_double> stdTensor\_I (( unit\_symmetric\_tensor<dim,fad\_double>()) );
395 
396      \textcolor{comment}{// Our stress equation is now computed in index notation to simplify the use of the constants and}
397      \textcolor{comment}{// especially the use of the \(\backslash\)a deviator.}
398       \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
399         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
400             sigma[i][j] = kappa * trace(eps) *  stdTensor\_I[i][j] + 2. * mu * deviator(eps)[i][j];
401 
402     \textcolor{comment}{// Finally we declare our desired tangent as the fourth order tensor \(\backslash\)a C\_Sacado and compute the
       tangent via}
403     \textcolor{comment}{// the command \(\backslash\)a get\_tangent.}
404      SymmetricTensor<4,dim> C\_Sacado;
405      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ab97427c3b5cab279e58607cf431ab262}{get\_tangent}(C\_Sacado, sigma);
406 
407     \textcolor{comment}{// We could again compare the herein computed tangent with the analytical tangent from Ex2, but as
       before}
408     \textcolor{comment}{// the results are fairly boring, because Sacado hits the analytical tangent exactly --- no surprise
       for such}
409     \textcolor{comment}{// simple equations.}
410 
411     \textcolor{comment}{// And that's it. By using the Sacado\_wrapper we can achieve everything from Ex2 (besides the
       equations)}
412     \textcolor{comment}{// with just four lines of code namely:}
413     \textcolor{comment}{// - eps.init(eps\_d);    // To initialize the Sacado strain tensor}
414     \textcolor{comment}{// - eps.set\_dofs();     // To declare the components of eps as the dofs}
415     \textcolor{comment}{// - eps.get\_tangent(*); // To get the tangent}
416 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}\label{Sacado__example_8cc_a2f4def4563e31d720e07bc7d6363ebe2}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+4@{sacado\+\_\+test\+\_\+4}}
\index{sacado\+\_\+test\+\_\+4@{sacado\+\_\+test\+\_\+4}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+4()}{sacado\_test\_4()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+4 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



References Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::get\+\_\+tangent(), Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double$<$ dim $>$\+::get\+\_\+tangent(), Sacado\+\_\+\+Wrapper\+::\+Sym\+Tensor$<$ dim $>$\+::init(), Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double$<$ dim $>$\+::init(), and Sacado\+\_\+\+Wrapper\+::\+Do\+Fs\+\_\+summary$<$ dim $>$\+::set\+\_\+dofs().



Referenced by main().


\begin{DoxyCode}
421 \{
422     std::cout << \textcolor{stringliteral}{"Test 4:"} << std::endl;
423     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
424 
425     \textcolor{comment}{// The following declarations are usually input arguments. So you receive the strain tensor \(\backslash\)q eps\_d,}
426     \textcolor{comment}{// the damage variable \(\backslash\)a phi and the constants \(\backslash\)a kappa and \(\backslash\)a mu out of doubles.}
427     SymmetricTensor<2,dim> eps\_d;
428     eps\_d[0][0] = 1;
429     eps\_d[1][1] = 2;
430     eps\_d[2][2] = 3;
431 
432     eps\_d[0][1] = 4;
433     eps\_d[0][2] = 5;
434     eps\_d[1][2] = 6;
435 
436     \textcolor{keywordtype}{double} phi\_d = 0.3;
437 
438     \textcolor{comment}{// We don't need these constants in the current example.}
439     \textcolor{comment}{// double kappa = 5;}
440     \textcolor{comment}{// double mu = 2;}
441 
442 
443     \textcolor{comment}{// We set up our strain tensor as in Ex3B.}
444      \hyperlink{classSacado__Wrapper_1_1SymTensor}{Sacado\_Wrapper::SymTensor<dim>} eps;
445      \hyperlink{classSacado__Wrapper_1_1SW__double}{Sacado\_Wrapper::SW\_double<dim>} phi;
446 
447     \textcolor{comment}{// Initialize the strain tensor and the damage variable}
448      eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_acbad579d5ead9e96ff46aa15d9b5aef4}{init}(eps\_d);
449      phi.\hyperlink{classSacado__Wrapper_1_1SW__double_adca799dd92dadebda9aebc91c797682a}{init}(phi\_d);
450 
451      \textcolor{comment}{// Set the dofs, where the argument sets the total nbr of dofs (3 or 6 for the sym. tensor and 1 for
       the double)}
452 \textcolor{comment}{//    eps.set\_dofs(eps.n\_independent\_components+1/*an additional dof for phi*/);}
453 \textcolor{comment}{//}
454      \textcolor{comment}{// In order to also compute derivatives with respect to the scalar \(\backslash\)a phi, we add this scalar to our
       list}
455      \textcolor{comment}{// of derivatives. Because we have already defined 3 or 6 dofs our additional dof will be placed at
       the end}
456      \textcolor{comment}{// of this list. We set this up with the member variable start\_index ...}
457 \textcolor{comment}{//    phi.start\_index=eps.n\_independent\_components;}
458      \textcolor{comment}{// and again using the input argument representing the total number of dofs}
459 \textcolor{comment}{//    phi.set\_dofs(eps.n\_independent\_components+1);}
460 
461     \textcolor{comment}{// All of the above 3 lines of code are automatically done by the DoFs\_summary class. So, to}
462     \textcolor{comment}{// set our dofs we just create an instance and call set\_dofs with our variables containing the desired
       dofs.}
463      \hyperlink{classSacado__Wrapper_1_1DoFs__summary}{Sacado\_Wrapper::DoFs\_summary<dim>} DoFs\_summary;
464      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_a556293f6e683cb30151d9faadc2cc90d}{set\_dofs}(eps, phi);
465 
466 
467     \textcolor{comment}{// Compute the stress tensor and damage variable \(\backslash\)a d (here we just use some arbitrary equations for
       testing): \(\backslash\)n}
468      \textcolor{comment}{// Let us first declare our output (and auxiliary) variables as Sacado data types.}
469       SymmetricTensor<2,dim,fad\_double> sigma;
470       \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} d;
471      \textcolor{comment}{// @todo It would be nice to use the data types from the Sacado\_Wrapper for all the Sacado variables.
       But}
472      \textcolor{comment}{// somehow the operators (multiply*, ...) seem to cause conflicts again.}
473 
474      \textcolor{comment}{// The actual computation in the following scope uses the exact same equation as your normal
       computation e. g. via the data type double.}
475      \textcolor{comment}{// Hence, you could either directly compute your stress, etc. via the Sacado variables or you define}
476      \textcolor{comment}{// template functions that contain your equations and are either called templated with double or
       fad\_double.}
477      \textcolor{comment}{// When using the first option, please consider the computation time that is generally higher for a
       computation}
478      \textcolor{comment}{// with fad\_double than with normal doubles (own experience in a special case: slower by factor 30).}
479      \textcolor{comment}{// The second option with templates does not suffer these issues.}
480       \{
481       d = phi*phi + 25 + trace(eps) + eps.norm();
482       std::cout << \textcolor{stringliteral}{"d="} << d << std::endl;
483 
484       \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
485         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
486             sigma[i][j] = phi * d * eps[i][j];
487              \textcolor{comment}{// ToDo: strangely when phi is a fad\_double then the multiplication phi * eps works directly
       without}
488              \textcolor{comment}{// having to use the index notation}
489       std::cout << \textcolor{stringliteral}{"sigma="} << sigma << std::endl << std::endl;
490       \}
491 
492 
493     \textcolor{comment}{// Get the tangents}
494      \textcolor{comment}{// d\_sigma / d\_eps: SymmetricTensor with respect to SymmetricTensor}
495       SymmetricTensor<4,dim> C\_Sacado;
496       eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ab97427c3b5cab279e58607cf431ab262}{get\_tangent}(C\_Sacado, sigma);
497       std::cout << \textcolor{stringliteral}{"C\_Sacado="} << C\_Sacado << std::endl;
498 
499      \textcolor{comment}{// Compute the analytical tangent:}
500       SymmetricTensor<4,dim> C\_analy;
501       C\_analy = ( std::pow(phi\_d, 3) + 25*phi\_d + phi\_d*trace(eps\_d) + phi\_d*eps\_d.norm() ) * 
      identity\_tensor<dim>()
502                 + phi\_d * outer\_product( eps\_d, unit\_symmetric\_tensor<dim>())
503                 + phi\_d * outer\_product( eps\_d, eps\_d ) * 1./eps\_d.norm();
504       \textcolor{comment}{// @note Be aware of the difference between \(\backslash\)f[ eps\_d \(\backslash\)otimes \(\backslash\)boldsymbol\{1\} \(\backslash\)text\{ and \}
       \(\backslash\)boldsymbol\{1\} \(\backslash\)otimes eps\_d \(\backslash\)f]}
505       std::cout << \textcolor{stringliteral}{"C\_analy ="} << C\_analy << std::endl;
506 
507       \textcolor{comment}{// To simplify the comparison we compute a scalar error as the sum of the absolute differences of
       each component}
508        \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
509        \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
510             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
511                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
512                     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
513                         error\_Sacado\_vs\_analy += std::fabs(C\_Sacado[i][j][k][l] - C\_analy[i][j][k][l]);
514        std::cout << \textcolor{stringliteral}{"numerical error: "} << error\_Sacado\_vs\_analy << std::endl << std::endl;
515 
516      \textcolor{comment}{// d\_d / d\_eps: double with respect to SymmetricTensor}
517       SymmetricTensor<2,dim> d\_d\_d\_eps;
518       eps.\hyperlink{classSacado__Wrapper_1_1SymTensor_ab97427c3b5cab279e58607cf431ab262}{get\_tangent}(d\_d\_d\_eps, d);
519       std::cout << \textcolor{stringliteral}{"d\_d\_d\_eps      ="} << d\_d\_d\_eps << std::endl;
520       SymmetricTensor<2,dim> d\_d\_d\_eps\_analy;
521       d\_d\_d\_eps\_analy = unit\_symmetric\_tensor<dim>() + eps\_d / eps\_d.norm();
522       std::cout << \textcolor{stringliteral}{"d\_d\_d\_eps\_analy="} << d\_d\_d\_eps\_analy << std::endl << std::endl;
523 
524      \textcolor{comment}{// d\_sigma / d\_phi: SymmetricTensor with respect to double}
525       SymmetricTensor<2,dim> d\_sigma\_d\_phi;
526       phi.\hyperlink{classSacado__Wrapper_1_1SW__double_a2e6eca4457eb22b06172bb5749038f1e}{get\_tangent}(d\_sigma\_d\_phi, sigma);
527       std::cout << \textcolor{stringliteral}{"d\_sigma\_d\_phi      ="} << d\_sigma\_d\_phi << std::endl;
528       SymmetricTensor<2,dim> d\_sigma\_d\_phi\_analy;
529       d\_sigma\_d\_phi\_analy = ( phi\_d*phi\_d + 25 + trace(eps\_d) + eps\_d.norm() + 2 * phi\_d*phi\_d ) * eps\_d;
530       std::cout << \textcolor{stringliteral}{"d\_sigma\_d\_phi\_analy="} << d\_sigma\_d\_phi\_analy << std::endl << std::endl;
531 
532      \textcolor{comment}{// Retrieve the values stored in \(\backslash\)a sigma:}
533       SymmetricTensor<2,dim> sigma\_d;
534       \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
535             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
536                 sigma\_d[i][j] = sigma[i][j].val();
537       std::cout << \textcolor{stringliteral}{"sigma\_d = "} << sigma\_d << std::endl;
538 
539      \textcolor{comment}{// d\_d / d\_phi: double with respect to double}
540       \textcolor{keywordtype}{double} d\_d\_d\_phi;
541       phi.\hyperlink{classSacado__Wrapper_1_1SW__double_a2e6eca4457eb22b06172bb5749038f1e}{get\_tangent}(d\_d\_d\_phi, d);
542       std::cout << \textcolor{stringliteral}{"d\_d\_d\_phi="} << d\_d\_d\_phi << std::endl;
543 
544      \textcolor{comment}{// Retrieve the value stored in d}
545       \textcolor{keywordtype}{double} d\_double = d.val();
546 
547      \textcolor{comment}{// Taylor-series for point x}
548      \textcolor{comment}{// @todo Maybe add some more text on the linearization}
549       \textcolor{keywordtype}{double} x = phi\_d + 0.05;
550       std::cout << \textcolor{stringliteral}{"d\_lin = d\_d\_d\_phi * (phi\_d - x) + d@(phi\_d) = "} << d\_d\_d\_phi * (x-phi\_d) + d\_double << 
      std::endl;
551       std::cout << \textcolor{stringliteral}{"d@x = "} << x*x + 25 + trace(eps\_d) + eps\_d.norm() << std::endl;
552 
553     \textcolor{comment}{// And that's it. By using the Sacado\_wrapper we can compute derivatives with respect to}
554     \textcolor{comment}{// a tensor and a scalar at the same time (besides the equations)}
555     \textcolor{comment}{// in essence with just the following lines of code namely:}
556     \textcolor{comment}{// - eps.init(eps\_d); phi.init(phi\_d);   // To initialize the Sacado strain tensor and scalar damage
       variable}
557     \textcolor{comment}{// - DoFs\_summary.set\_dofs(eps, phi);    // To declare the components of eps and phi as the dofs}
558     \textcolor{comment}{// - eps.get\_tangent(*); // To get tangents with respect to eps}
559     \textcolor{comment}{// - phi.get\_tangent(*); // To get tangents with respect to phi}
560 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}\label{Sacado__example_8cc_a327dbbb4ea7fc9840c46d149843a44c2}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+5@{sacado\+\_\+test\+\_\+5}}
\index{sacado\+\_\+test\+\_\+5@{sacado\+\_\+test\+\_\+5}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+5()}{sacado\_test\_5()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+5 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Referenced by main().


\begin{DoxyCode}
566 \{
567     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
568     std::cout << \textcolor{stringliteral}{"Test 5:"} << std::endl;
569     Tensor<1,dim,fad\_double> c;
570     \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} a,b;
571     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n\_dofs=2;
572     a = 1; b = 2;   \textcolor{comment}{// at the point (a,b) = (1,2)}
573     a.diff(0,2);  \textcolor{comment}{// Set a to be dof 0, in a 2-dof system.}
574     b.diff(1,2);  \textcolor{comment}{// Set b to be dof 1, in a 2-dof system.}
575     \textcolor{comment}{// c is now a vector with three components}
576     c[0] = 2*a+3*b;
577     c[1] = 4*a+5*b;
578     c[2] = 6*a+7*b;
579     
580     \textcolor{comment}{// Access to the derivatives works as before.}
581     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<dim;++i)
582     \{
583         \textcolor{keyword}{const} \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} &derivs = c[i]; \textcolor{comment}{// Access derivatives}
584         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0;j<n\_dofs;++j)
585         \{
586             std::cout << \textcolor{stringliteral}{"Derivatives at the point ("} << a << \textcolor{stringliteral}{","} << b << \textcolor{stringliteral}{") for "}
587             <<i<<\textcolor{stringliteral}{"th component wrt "}<<j<<\textcolor{stringliteral}{"th direction "}<< std::endl;
588             std::cout << \textcolor{stringliteral}{"dc\_i/dxj = "} << derivs.fastAccessDx(j) << std::endl;            
589         \}
590     \}
591 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}\label{Sacado__example_8cc_a27450ab52a9d4250e3f5a5f2a3f8f317}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+6@{sacado\+\_\+test\+\_\+6}}
\index{sacado\+\_\+test\+\_\+6@{sacado\+\_\+test\+\_\+6}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+6()}{sacado\_test\_6()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+6 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Referenced by main().


\begin{DoxyCode}
599 \{
600     std::cout << \textcolor{stringliteral}{"Test 6:"} << std::endl;
601     \textcolor{comment}{// Define the variables used in the computation (inputs: a, b; output: c; auxiliaries: *) as doubles}
602      \textcolor{keywordtype}{double} a=1;
603      \textcolor{keywordtype}{double} b=2;
604 
605     \textcolor{comment}{// Number of independent variables (scalar a and b)}
606      \textcolor{keywordtype}{int} num\_dofs = 2;
607 
608     \textcolor{comment}{// Define another data type containing even more Sacado data types}
609     \textcolor{comment}{// @todo try to merge the fad\_double data type with this templated data type}
610      \textcolor{keyword}{typedef} Sacado::Fad::DFad<double> \hyperlink{Sacado__Wrapper_8h_a7e0893207b87dad05c66a34baac8ed2e}{DFadType};
611      Sacado::Fad::DFad<DFadType> afad(num\_dofs, 0, a);
612      Sacado::Fad::DFad<DFadType> bfad(num\_dofs, 1, b);
613      Sacado::Fad::DFad<DFadType> cfad;
614 
615     \textcolor{comment}{// Output the variables: We se that the values of \(\backslash\)a a and \(\backslash\)a b are set but the derivatives have not
       yet been fully declared}
616      std::cout << \textcolor{stringliteral}{"afad="} << afad << std::endl;
617      std::cout << \textcolor{stringliteral}{"bfad="} << bfad << std::endl;
618      std::cout << \textcolor{stringliteral}{"cfad="} << cfad << std::endl;
619 
620     \textcolor{comment}{// Now we set the "inner" derivatives.}
621     afad.val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(num\_dofs, 0, a); \textcolor{comment}{// set afad.val() as the first dof and init it with
       the double a}
622     bfad.val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(num\_dofs, 1, b);
623 
624     \textcolor{comment}{// Compute function and derivative with AD}
625      cfad = 2*afad + std::cos(afad*bfad);
626 
627     \textcolor{comment}{// After this, we output the variables again and see that some additional derivatives have been
       declared. Furthermore,}
628     \textcolor{comment}{// \(\backslash\)a cfad is filled with the values and derivatives}
629      std::cout << \textcolor{stringliteral}{"afad="} << afad << std::endl;
630      std::cout << \textcolor{stringliteral}{"bfad="} << bfad << std::endl;
631      std::cout << \textcolor{stringliteral}{"cfad="} << cfad << std::endl;
632 
633     \textcolor{comment}{// Extract value and derivatives}
634      \textcolor{keywordtype}{double} c\_ad = cfad.val().val();       \textcolor{comment}{// r}
635      \textcolor{keywordtype}{double} dcda\_ad = cfad.dx(0).val();    \textcolor{comment}{// dr/da}
636      \textcolor{keywordtype}{double} dcdb\_ad = cfad.dx(1).val();    \textcolor{comment}{// dr/db}
637      \textcolor{keywordtype}{double} d2cda2\_ad = cfad.dx(0).dx(0);  \textcolor{comment}{// d^2r/da^2}
638      \textcolor{keywordtype}{double} d2cdadb\_ad = cfad.dx(0).dx(1); \textcolor{comment}{// d^2r/dadb}
639      \textcolor{keywordtype}{double} d2cdbda\_ad = cfad.dx(1).dx(0); \textcolor{comment}{// d^2r/dbda}
640      \textcolor{keywordtype}{double} d2cdb2\_ad = cfad.dx(1).dx(1);  \textcolor{comment}{// d^2/db^2}
641 
642     \textcolor{comment}{// Now we can print the actual double value of c and some of the derivatives:}
643      std::cout << \textcolor{stringliteral}{"c\_ad="} << c\_ad << std::endl;
644      std::cout << \textcolor{stringliteral}{"Derivatives at the point ("} << a << \textcolor{stringliteral}{","} << b << \textcolor{stringliteral}{")"} << std::endl;
645      std::cout << \textcolor{stringliteral}{"dc/da = "} << dcda\_ad << \textcolor{stringliteral}{", dc/db="} << dcdb\_ad << std::endl;
646      std::cout << \textcolor{stringliteral}{"d²c/da² = "} << d2cda2\_ad << \textcolor{stringliteral}{", d²c/db²="} << d2cdb2\_ad << std::endl;
647      std::cout << \textcolor{stringliteral}{"d²c/dadb = "} << d2cdadb\_ad << \textcolor{stringliteral}{", d²c/dbda="} << d2cdbda\_ad << std::endl;
648 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}\label{Sacado__example_8cc_a0b694459e5e15c1578d97e637faba8de}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+7@{sacado\+\_\+test\+\_\+7}}
\index{sacado\+\_\+test\+\_\+7@{sacado\+\_\+test\+\_\+7}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+7()}{sacado\_test\_7()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+7 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Referenced by main().


\begin{DoxyCode}
653 \{
654     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
655 
656     std::cout << \textcolor{stringliteral}{"Test 7:"} << std::endl;
657 
658     \textcolor{comment}{// Defining the inputs (material parameters, strain tensor)}
659      \textcolor{keywordtype}{double} lambda=1;
660      \textcolor{keywordtype}{double} mu=2;
661      SymmetricTensor<2,dim, double> eps;
662 
663      eps[0][0] = 1.;
664      eps[1][1] = 2.;
665      eps[2][2] = 3.;
666 
667      eps[0][1] = 4.;
668      eps[0][2] = 5.;
669      eps[1][2] = 6.;
670 
671     \textcolor{comment}{// Here we skip the one-field example and right away show the equations for a two-field problem}
672     \textcolor{comment}{// with \(\backslash\)a eps and \(\backslash\)a phi.}
673      \textcolor{keywordtype}{double} phi=0.3;
674 
675     \textcolor{comment}{// Setup of the map relating the indices (as before)}
676      std::map<unsigned int,std::pair<unsigned int,unsigned int>> std\_map\_indicies;
677 
678      std::pair<unsigned int, unsigned int> tmp\_pair;
679      tmp\_pair.first=0; tmp\_pair.second=0;
680      std\_map\_indicies[0] = tmp\_pair;
681 
682      tmp\_pair.first=0; tmp\_pair.second=1;
683      std\_map\_indicies[1] = tmp\_pair;
684 
685      tmp\_pair.first=0; tmp\_pair.second=2;
686      std\_map\_indicies[2] = tmp\_pair;
687 
688      tmp\_pair.first=1; tmp\_pair.second=1;
689      std\_map\_indicies[3] = tmp\_pair;
690 
691      tmp\_pair.first=1; tmp\_pair.second=2;
692      std\_map\_indicies[4] = tmp\_pair;
693 
694      tmp\_pair.first=2; tmp\_pair.second=2;
695      std\_map\_indicies[5] = tmp\_pair;
696 
697     \textcolor{comment}{// Number of independent variables (6 for the tensor and 1 for the scalar phi)}
698      \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nbr\_dofs = 6+1;
699 
700     \textcolor{comment}{// Declaring the special data types containing all derivatives}
701      \textcolor{keyword}{typedef} Sacado::Fad::DFad<double> \hyperlink{Sacado__Wrapper_8h_a7e0893207b87dad05c66a34baac8ed2e}{DFadType};
702      SymmetricTensor<2,dim, Sacado::Fad::DFad<DFadType> > eps\_fad, eps\_fad\_squared;
703      Sacado::Fad::DFad<DFadType> phi\_fad;
704 
705 
706     \textcolor{comment}{// Setting the dofs}
707      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0; x<6; ++x )
708      \{
709         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=std\_map\_indicies[x].first;
710         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=std\_map\_indicies[x].second;
711         (eps\_fad[i][j]).diff( x, nbr\_dofs); \textcolor{comment}{// set up the "inner" derivatives}
712         (eps\_fad[i][j]).val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, x, eps[i][j]); \textcolor{comment}{// set up the "outer"
       derivatives}
713      \}
714 
715      phi\_fad.diff( 6, nbr\_dofs );
716      phi\_fad.val() = \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double}(nbr\_dofs, 6, phi); \textcolor{comment}{// set up the "outer" derivatives}
717 
718      std::cout << \textcolor{stringliteral}{"eps\_fad="} << eps\_fad << std::endl;
719      std::cout << \textcolor{stringliteral}{"phi\_fad="} << phi\_fad << std::endl;
720 
721     \textcolor{comment}{// Compute eps² = eps\_ij * eps\_jk in index notation}
722      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
723         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k )
724             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
725                 \textcolor{keywordflow}{if} ( i>=k )
726                     eps\_fad\_squared[i][k] += eps\_fad[i][j] * eps\_fad[j][k];
727 
728     \textcolor{comment}{// Compute the strain energy density}
729      Sacado::Fad::DFad<DFadType> energy;
730      energy = lambda/2. * trace(eps\_fad)*trace(eps\_fad) + mu * trace(eps\_fad\_squared) + 25 * phi\_fad * 
      trace(eps\_fad);
731 
732     \textcolor{comment}{// Give some insight into the storage of the values and derivatives}
733      std::cout << \textcolor{stringliteral}{"energy="} << energy << std::endl;
734 
735     \textcolor{comment}{// Compute sigma as \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\} \(\backslash\)f]}
736      SymmetricTensor<2,dim> sigma\_Sac;
737      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0; x<6; ++x )
738      \{
739         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=std\_map\_indicies[x].first;
740         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=std\_map\_indicies[x].second;
741         \textcolor{keywordflow}{if} ( i!=j )
742             sigma\_Sac[i][j] = 0.5 * energy.dx(x).val();
743         \textcolor{keywordflow}{else}
744             sigma\_Sac[i][j] = energy.dx(x).val();
745      \}
746      std::cout << \textcolor{stringliteral}{"sigma\_Sacado="} << sigma\_Sac << std::endl;
747 
748      \textcolor{keywordtype}{double} d\_energy\_d\_phi = energy.dx(6).val();
749      std::cout << \textcolor{stringliteral}{"d\_energy\_d\_phi="} << d\_energy\_d\_phi << std::endl;
750 
751      \textcolor{keywordtype}{double} d2\_energy\_d\_phi\_2 = energy.dx(6).dx(6);
752      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_phi\_2="} << d2\_energy\_d\_phi\_2 << std::endl;
753 
754     \textcolor{comment}{// Analytical stress tensor:}
755      SymmetricTensor<2,dim> sigma;
756      sigma = lambda*trace(eps)*unit\_symmetric\_tensor<dim>() + 2. * mu * eps + 25 * phi * 
      unit\_symmetric\_tensor<dim>();
757      std::cout << \textcolor{stringliteral}{"analy. sigma="} << sigma << std::endl;
758 
759 
760     \textcolor{comment}{// Sacado-Tangent}
761      SymmetricTensor<4,dim> C\_Sac;
762      \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0;x<6;++x)
763         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} y=0;y<6;++y)
764         \{
765             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=std\_map\_indicies[y].first;
766             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=std\_map\_indicies[y].second;
767             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=std\_map\_indicies[x].first;
768             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=std\_map\_indicies[x].second;
769 
770             \textcolor{keywordtype}{double} deriv = energy.dx(x).dx(y); \textcolor{comment}{// Access the derivatives of the (i,j)-th component of \(\backslash\)a
       sigma}
771 
772             \textcolor{keywordflow}{if} ( k!=l && i!=j )
773                 C\_Sac[i][j][k][l] = 0.25* deriv;
774             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(k!=l)\textcolor{comment}{/*Compare to Voigt notation since only SymmetricTensor instead of Tensor*/}
775             \{
776                 C\_Sac[i][j][k][l] = 0.5*deriv;
777                 C\_Sac[i][j][l][k] = 0.5*deriv;
778             \}
779             \textcolor{keywordflow}{else}
780                 C\_Sac[i][j][k][l] = deriv;
781         \}
782 
783     \textcolor{comment}{// Analytical tangent}
784      SymmetricTensor<4,dim> C\_analy;
785      C\_analy = lambda * outer\_product(unit\_symmetric\_tensor<dim>(), unit\_symmetric\_tensor<dim>()) + 2. * mu
       * identity\_tensor<dim>();
786 
787     \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
788     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
789         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
790             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
791                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
792                     error\_Sacado\_vs\_analy += std::fabs(C\_Sac[i][j][k][l] - C\_analy[i][j][k][l]);
793 
794     std::cout << \textcolor{stringliteral}{"Numerical error="} << error\_Sacado\_vs\_analy << std::endl;
795 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}\label{Sacado__example_8cc_aa7108ff8393b98d66dfef50899d048d9}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+8@{sacado\+\_\+test\+\_\+8}}
\index{sacado\+\_\+test\+\_\+8@{sacado\+\_\+test\+\_\+8}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+8()}{sacado\_test\_8()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+8 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



References Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double2$<$ dim $>$\+::get\+\_\+curvature(), Sacado\+\_\+\+Wrapper\+::\+Do\+Fs\+\_\+summary$<$ dim $>$\+::get\+\_\+curvature(), Sacado\+\_\+\+Wrapper\+::\+S\+W\+\_\+double2$<$ dim $>$\+::get\+\_\+tangent(), and Sacado\+\_\+\+Wrapper\+::\+Do\+Fs\+\_\+summary$<$ dim $>$\+::init\+\_\+set\+\_\+dofs().



Referenced by main().


\begin{DoxyCode}
802 \{
803     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
804 
805     std::cout << \textcolor{stringliteral}{"Test 8:"} << std::endl;
806 
807     \textcolor{comment}{// Defining the inputs (material parameters, strain tensor)}
808      \textcolor{keywordtype}{double} lambda=1;
809      \textcolor{keywordtype}{double} mu=2;
810      SymmetricTensor<2,dim, double> eps;
811      \textcolor{keywordtype}{double} phi = 0.3;
812 
813      eps[0][0] = 1.;
814      eps[1][1] = 2.;
815      eps[2][2] = 3.;
816 
817      eps[0][1] = 4.;
818      eps[0][2] = 5.;
819      eps[1][2] = 6.;
820 
821     \textcolor{comment}{// Declaring the special data types containing all derivatives}
822      \textcolor{keyword}{typedef} Sacado::Fad::DFad<double> \hyperlink{Sacado__Wrapper_8h_a7e0893207b87dad05c66a34baac8ed2e}{DFadType};
823 
824     \textcolor{comment}{// Declare the variables \(\backslash\)a eps\_fad and \(\backslash\)a phi\_fad as the special Wrapper data types}
825      \hyperlink{classSacado__Wrapper_1_1SymTensor2}{Sacado\_Wrapper::SymTensor2<dim>} eps\_fad;
826      \hyperlink{classSacado__Wrapper_1_1SW__double2}{Sacado\_Wrapper::SW\_double2<dim>} phi\_fad;
827 
828     \textcolor{comment}{// Declare the summary data type relating all the dofs and initialising them too}
829      \hyperlink{classSacado__Wrapper_1_1DoFs__summary}{Sacado\_Wrapper::DoFs\_summary<dim>} DoFs\_summary;
830      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_ae273d0fa3197118a11d7005523e27d8a}{init\_set\_dofs}(eps\_fad, eps, phi\_fad, phi);
831 
832     \textcolor{comment}{// The variables are outputted to give some insight into the storage of the values (derivatives still
       trivial).}
833      std::cout << \textcolor{stringliteral}{"eps\_fad="} << eps\_fad << std::endl;
834      std::cout << \textcolor{stringliteral}{"phi\_fad="} << phi\_fad << std::endl;
835 
836     \textcolor{comment}{// Compute eps² = eps\_ij * eps\_jk in index notation}
837      SymmetricTensor<2,dim, Sacado::Fad::DFad<DFadType> > eps\_fad\_squared;
838      \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
839         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k )
840             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
841                 \textcolor{keywordflow}{if} ( i>=k )
842                     eps\_fad\_squared[i][k] += eps\_fad[i][j] * eps\_fad[j][k];
843 
844     \textcolor{comment}{// Compute the strain energy density}
845      Sacado::Fad::DFad<DFadType> energy;
846      energy = lambda/2. * trace(eps\_fad)*trace(eps\_fad) + mu * trace(eps\_fad\_squared) + 25 * phi\_fad * 
      trace(eps\_fad);
847 
848     \textcolor{comment}{// The energy is outputted (formatted by hand) to give some insight into the storage of the values and
       derivatives. \(\backslash\)n}
849     \textcolor{comment}{// energy=399 [ 17.5 32 40 21.5 48 25.5 150 ] \(\backslash\)n}
850     \textcolor{comment}{// [ 17.5 [ 5 0 0 1 0 1 25 ] 32 [ 0 8 0 0 0 0 0 ] 40 [ 0 0 8 0 0 0 0 ] \(\backslash\)n}
851     \textcolor{comment}{// 21.5 [ 1 0 0 5 0 1 25 ] 48 [ 0 0 0 0 8 0 0 ] 25.5 [ 1 0 0 1 0 5 25 ] \(\backslash\)n}
852     \textcolor{comment}{// 150 [ 25 0 0 25 0 25 0 ] ]}
853 
854      std::cout << \textcolor{stringliteral}{"energy="} << energy << std::endl;
855 
856     \textcolor{comment}{// Compute sigma as \(\backslash\)f[ \(\backslash\)boldsymbol\{\(\backslash\)sigma\} = \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\}
       \(\backslash\)f]}
857      SymmetricTensor<2,dim> sigma\_Sac;
858      eps\_fad.get\_tangent(sigma\_Sac, energy);
859      std::cout << \textcolor{stringliteral}{"sigma\_Sacado="} << sigma\_Sac << std::endl;
860 
861      \textcolor{keywordtype}{double} d\_energy\_d\_phi;
862      phi\_fad.\hyperlink{classSacado__Wrapper_1_1SW__double2_ad51ba1e79171d60861b28098dfef903d}{get\_tangent}(d\_energy\_d\_phi, energy);
863      std::cout << \textcolor{stringliteral}{"d\_energy\_d\_phi="} << d\_energy\_d\_phi << std::endl;
864 
865 
866     \textcolor{comment}{// Analytical stress tensor:}
867      SymmetricTensor<2,dim> sigma;
868      sigma = lambda*trace(eps)*unit\_symmetric\_tensor<dim>() + 2. * mu * eps + 25 * phi * 
      unit\_symmetric\_tensor<dim>();
869      std::cout << \textcolor{stringliteral}{"analy. sigma="} << sigma << std::endl;
870 
871 
872     \textcolor{comment}{// Sacado stress tangent (or eps curvature) as \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial
       \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}^2\} \(\backslash\)f]}
873      SymmetricTensor<4,dim> C\_Sac;
874      eps\_fad.get\_curvature(C\_Sac, energy);
875 
876     \textcolor{comment}{// Sacado phi curvature as \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)varphi^2\} \(\backslash\)f]}
877      \textcolor{keywordtype}{double} d2\_energy\_d\_phi\_2;
878      phi\_fad.\hyperlink{classSacado__Wrapper_1_1SW__double2_a7d3f3a21cd842645af9861bf50308825}{get\_curvature}(d2\_energy\_d\_phi\_2, energy);
879      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_phi\_2="} << d2\_energy\_d\_phi\_2 << std::endl;
880 
881     \textcolor{comment}{// Sacado derivatives \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\} \(\backslash\)partial \(\backslash\)varphi\}
       \(\backslash\)f]}
882      SymmetricTensor<2,dim> d2\_energy\_d\_eps\_d\_phi;
883      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_adf29bfda10814ecee9572a4751d34db0}{get\_curvature}(d2\_energy\_d\_eps\_d\_phi, energy, eps\_fad, phi\_fad);
884      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_eps\_d\_phi="} << d2\_energy\_d\_eps\_d\_phi << std::endl;
885 
886     \textcolor{comment}{// Sacado derivatives \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)varphi \(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\}
       \(\backslash\)f]}
887      SymmetricTensor<2,dim> d2\_energy\_d\_phi\_d\_eps;
888      DoFs\_summary.\hyperlink{classSacado__Wrapper_1_1DoFs__summary_adf29bfda10814ecee9572a4751d34db0}{get\_curvature}(d2\_energy\_d\_phi\_d\_eps, energy, phi\_fad, eps\_fad);
889      std::cout << \textcolor{stringliteral}{"d2\_energy\_d\_phi\_d\_eps="} << d2\_energy\_d\_phi\_d\_eps << std::endl;
890 
891     \textcolor{comment}{// When you consider the output: \(\backslash\)n}
892     \textcolor{comment}{// d2\_energy\_d\_eps\_d\_phi=25 0 0 0 25 0 0 0 25 \(\backslash\)n}
893     \textcolor{comment}{// d2\_energy\_d\_phi\_d\_eps=25 0 0 0 25 0 0 0 25 \(\backslash\)n}
894     \textcolor{comment}{// in detail you will notice that both second derivatives are identical. This compplies with the
       Schwarz integrability condition (Symmetry of second derivatives)}
895     \textcolor{comment}{// (ignoring all limitation and requirements), it holds}
896     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial^2 \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\} \(\backslash\)partial \(\backslash\)varphi\} = \(\backslash\)frac\{\(\backslash\)partial^2
       \(\backslash\)Psi\}\{\(\backslash\)partial \(\backslash\)varphi \(\backslash\)partial \(\backslash\)boldsymbol\{\(\backslash\)varepsilon\}\}  \(\backslash\)f]}
897 
898     \textcolor{comment}{// Analytical stress tangent}
899      SymmetricTensor<4,dim> C\_analy;
900      C\_analy = lambda * outer\_product(unit\_symmetric\_tensor<dim>(), unit\_symmetric\_tensor<dim>()) + 2. * mu
       * identity\_tensor<dim>();
901 
902     \textcolor{comment}{// Compute the error for the stress tangent}
903      \textcolor{keywordtype}{double} error\_Sacado\_vs\_analy=0;
904      \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
905         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j)
906             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=0; k<dim; ++k)
907                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=0; l<dim; ++l)
908                     error\_Sacado\_vs\_analy += std::fabs(C\_Sac[i][j][k][l] - C\_analy[i][j][k][l]);
909      std::cout << \textcolor{stringliteral}{"Numerical error="} << error\_Sacado\_vs\_analy << std::endl;
910 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_ae176f83fe1943e102fe325d4a14f097e}\label{Sacado__example_8cc_ae176f83fe1943e102fe325d4a14f097e}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+9@{sacado\+\_\+test\+\_\+9}}
\index{sacado\+\_\+test\+\_\+9@{sacado\+\_\+test\+\_\+9}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+9()}{sacado\_test\_9()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+9 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Referenced by main().


\begin{DoxyCode}
916 \{
917     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dim=3;
918 
919     std::cout << \textcolor{stringliteral}{"Test 9:"} << std::endl;
920 
921     \textcolor{keywordtype}{double} kappa\_param = 5;
922     \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} kappa (kappa\_param);
923     \textcolor{keywordtype}{double} mu = 2;
924 
925     SymmetricTensor<2,dim, fad\_double> sigma, eps;
926 
927     std::map<unsigned int,std::pair<unsigned int,unsigned int>> std\_map\_indicies;
928 
929         eps[0][0] = 1;
930         eps[1][1] = 2;
931         eps[2][2] = 3;
932 
933         eps[0][1] = 4;
934         eps[0][2] = 5;
935         eps[1][2] = 6;
936 
937 
938         eps[0][0].diff(0,6);
939         eps[0][1].diff(1,6);
940         eps[0][2].diff(2,6);
941         eps[1][1].diff(3,6);
942         eps[1][2].diff(4,6);
943         eps[2][2].diff(5,6);
944 
945         std::pair<unsigned int, unsigned int> tmp\_pair;
946         tmp\_pair.first=0; tmp\_pair.second=0;
947         std\_map\_indicies[0] = tmp\_pair;
948 
949         tmp\_pair.first=0; tmp\_pair.second=1;
950         std\_map\_indicies[1] = tmp\_pair;
951 
952         tmp\_pair.first=0; tmp\_pair.second=2;
953         std\_map\_indicies[2] = tmp\_pair;
954 
955         tmp\_pair.first=1; tmp\_pair.second=1;
956         std\_map\_indicies[3] = tmp\_pair;
957 
958         tmp\_pair.first=1; tmp\_pair.second=2;
959         std\_map\_indicies[4] = tmp\_pair;
960 
961         tmp\_pair.first=2; tmp\_pair.second=2;
962         std\_map\_indicies[5] = tmp\_pair;
963 
964     SymmetricTensor<2,dim, fad\_double> stdTensor\_I (( unit\_symmetric\_tensor<dim,fad\_double>()) );
965 
966     sigma = kappa * (trace(eps) *  stdTensor\_I);
967     SymmetricTensor<2,dim,fad\_double> tmp = deviator<dim,fad\_double>(symmetrize<dim,fad\_double>(eps)); tmp*
      =(mu*2);
968     sigma +=  tmp;
969 
970     std::cout << \textcolor{stringliteral}{"sigma="} << sigma << std::endl;
971 
972      \textcolor{comment}{// Retrieve the values stored in \(\backslash\)a sigma:}
973       SymmetricTensor<2,dim> sigma\_d;
974       \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
975             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
976                 sigma\_d[i][j] = sigma[i][j].val();
977 
978     SymmetricTensor<4,dim> C\_Sacado;
979 
980     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<dim; ++i)
981         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<dim; ++j )
982         \{
983             \textcolor{keywordtype}{double} *derivs = &sigma[i][j].fastAccessDx(0); \textcolor{comment}{// Access the derivatives of the (i,j)-th
       component of \(\backslash\)a sigma}
984 
985             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x=0;x<((dim==2)?3:6);++x)
986             \{
987                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k=std\_map\_indicies[x].first;
988                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l=std\_map\_indicies[x].second;
989 
990                 \textcolor{keywordflow}{if}(k!=l)\textcolor{comment}{/*Compare to Voigt notation since only SymmetricTensor instead of Tensor*/}
991                 \{
992                     C\_Sacado[i][j][k][l] = 0.5*derivs[x];
993                     C\_Sacado[i][j][l][k] = 0.5*derivs[x];
994                 \}
995                 \textcolor{keywordflow}{else}
996                     C\_Sacado[i][j][k][l] = derivs[x];
997             \}
998         \}
999 
1000     SymmetricTensor<2,dim> eps\_d;
1001     eps\_d[0][0] = 1;
1002     eps\_d[1][1] = 2;
1003     eps\_d[2][2] = 3;
1004 
1005     eps\_d[0][1] = 4;
1006     eps\_d[0][2] = 5;
1007     eps\_d[1][2] = 6;
1008 
1009     SymmetricTensor<2,dim> stress\_from\_tangent = C\_Sacado*eps\_d;
1010 
1011     std::cout << \textcolor{stringliteral}{"C\_Sacado*eps\_d="} << stress\_from\_tangent << std::endl;
1012     std::cout << \textcolor{stringliteral}{"sigma=         "} << sigma\_d << std::endl;
1013 
1014     \textcolor{comment}{// @todo Add the link to the ac.nz site}
1015 
1016     \textcolor{comment}{// As you can see we obtain the correct stress tensor only by using the factor 0.5 onto the
       off-diagonal elements of the symmetric tensor. \(\backslash\)n}
1017     \textcolor{comment}{// @note So, why do we need the factor 0.5 then? (based on [homepages.engineering.auckland.ac.nz
       ...])\(\backslash\)n}
1018     \textcolor{comment}{// When using symmetric tensor one has to be aware of the definition of the independent variables. In
       3d those are the}
1019     \textcolor{comment}{// following 6 components: \(\backslash\)n}
1020     \textcolor{comment}{// - \(\backslash\)f$ A\_\{11\} \(\backslash\)f$}
1021     \textcolor{comment}{// - \(\backslash\)f$ A\_\{22\} \(\backslash\)f$}
1022     \textcolor{comment}{// - \(\backslash\)f$ A\_\{33\} \(\backslash\)f$}
1023     \textcolor{comment}{// - \(\backslash\)f$ \(\backslash\)overline\{A\_\{12\}\} \(\backslash\)f$}
1024     \textcolor{comment}{// - \(\backslash\)f$ \(\backslash\)overline\{A\_\{13\}\} \(\backslash\)f$}
1025     \textcolor{comment}{// - \(\backslash\)f$ \(\backslash\)overline\{A\_\{23\}\} \(\backslash\)f$ \(\backslash\)n}
1026     \textcolor{comment}{// Here the overlined components denote the averaged values, such that}
1027     \textcolor{comment}{// - \(\backslash\)f$ \(\backslash\)overline\{A\_\{12\}\} = 0.5 \(\backslash\)cdot [ A\_\{12\} + A\_\{21\} ] = A\_\{12\} = A\_\{21\} \(\backslash\)f$}
1028     \textcolor{comment}{// - ... \(\backslash\)n}
1029     \textcolor{comment}{// This looks rather boring, because the averaged value of the two identical components (symmetry) is
       identical to the components.}
1030     \textcolor{comment}{// But (and that is a crucial BUT), this only holds for the values NOT the derivatives.}
1031     \textcolor{comment}{// The derivative of a function \(\backslash\)f$ \(\backslash\)Phi \(\backslash\)f$ with respect to a symmetric tensor \(\backslash\)a A is}
1032     \textcolor{comment}{// \(\backslash\)f[ \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Phi\}\{\(\backslash\)partial \(\backslash\)overline\{A\_\{12\}\}\} = \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Phi\}\{\(\backslash\)partial A\_\{12\}\} \(\backslash\)cdot
       \(\backslash\)frac\{\(\backslash\)partial A\_\{12\}\}\{\(\backslash\)partial \(\backslash\)overline\{A\_\{12\}\}\}}
1033     \textcolor{comment}{//                                                          + \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Phi\}\{\(\backslash\)partial A\_\{21\}\}
       \(\backslash\)cdot \(\backslash\)frac\{\(\backslash\)partial A\_\{21\}\}\{\(\backslash\)partial \(\backslash\)overline\{A\_\{21\}\}\}}
1034     \textcolor{comment}{//                                                          = \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Phi\}\{\(\backslash\)partial A\_\{12\}\} +
       \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Phi\}\{\(\backslash\)partial A\_\{21\}\}}
1035     \textcolor{comment}{//                                                          = 2 \(\backslash\)cdot \(\backslash\)frac\{\(\backslash\)partial \(\backslash\)Phi\}\{\(\backslash\)partial
       A\_\{12\}\} \(\backslash\)f]}
1036     \textcolor{comment}{// Note how the derivatives with respect to the actual tensor components (here 12 and 21) are
       identical. \(\backslash\)n}
1037     \textcolor{comment}{// However, our derivatives (computed via Sacado) were calculated with respect to the actually
       independent}
1038     \textcolor{comment}{// variables (overlined). Still, in the tensor with the derivatives we want the derivatives with
       respect to the normal components (not overlined). \(\backslash\)n}
1039     \textcolor{comment}{// Summary: \(\backslash\)n}
1040     \textcolor{comment}{// When you compute derivatives with respect to a symmetric tensor, you have to scale the off-diagonal
       elements by 0.5 to account for the fact that you actually work with}
1041     \textcolor{comment}{// the averaged values. \(\backslash\)n}
1042     \textcolor{comment}{// As a consequence, we use the factor 0.5 for all off-diagonal components of derivatives with respect
       to symmetric tensors. For second derivatives with respect to}
1043     \textcolor{comment}{// symmetric tensors the factors 0.5 and 0.25 come into play.}
1044 
1045     \textcolor{comment}{//}
1046 \}
\end{DoxyCode}
\mbox{\Hypertarget{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}\label{Sacado__example_8cc_a71b2675e62203edc430e7ffc8a365193}} 
\index{Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}!sacado\+\_\+test\+\_\+scalar@{sacado\+\_\+test\+\_\+scalar}}
\index{sacado\+\_\+test\+\_\+scalar@{sacado\+\_\+test\+\_\+scalar}!Sacado\+\_\+example.\+cc@{Sacado\+\_\+example.\+cc}}
\subsubsection{\texorpdfstring{sacado\+\_\+test\+\_\+scalar()}{sacado\_test\_scalar()}}
{\footnotesize\ttfamily void sacado\+\_\+test\+\_\+scalar (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Referenced by main().


\begin{DoxyCode}
39 \{
40     std::cout << \textcolor{stringliteral}{"Scalar Test:"} << std::endl;
41     \textcolor{comment}{// Define the variables used in the computation (inputs/independent variables: a, b; output/result: c;
       auxiliaries/passive variables: *) as the Sacado-data type}
42      \hyperlink{Sacado__example_8cc_a868b94676739e612d9c95940e70892a9}{fad\_double} a,b,c;
43     \textcolor{comment}{// Initialize the input variables a and b; This (a,b) = (1,2) will be the point where the derivatives
       are computed.}
44     \textcolor{comment}{// Compare: y=x² -> (dy/dx)(\(\backslash\)@x=1) = 2. We can only compute the derivative numerically at a certain
       point.}
45      a = 1;
46      b = 2;
47 
48     a.diff(0,2);  \textcolor{comment}{// Set a to be dof 0, in a 2-dof system.}
49     b.diff(1,2);  \textcolor{comment}{// Set b to be dof 1, in a 2-dof system.}
50     \textcolor{comment}{// Our equation here is very simply. But you can use nested equations and many standard mathematical
       operations, such as sqrt, pow, sin, ...}
51     c = 2*a + std::cos(a*b);
52     \textcolor{keywordtype}{double} *derivs = &c.fastAccessDx(0); \textcolor{comment}{// Access the derivatives of}
53     \textcolor{comment}{// Output the derivatives of c with respect to the two above defined degrees of freedom (dof)}
54     std::cout << \textcolor{stringliteral}{"Derivatives at the point ("} << a << \textcolor{stringliteral}{","} << b << \textcolor{stringliteral}{")"} << std::endl;
55     std::cout << \textcolor{stringliteral}{"dc/da = "} << derivs[0] << \textcolor{stringliteral}{", dc/db="} << derivs[1] << std::endl;
56 \}
\end{DoxyCode}
