<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Trilinos::Sacado example: Trilinos::Sacado example documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Trilinos::Sacado example
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Trilinos::Sacado example documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Example usage of Sacado for tensor calculus</p><dl class="section author"><dt>Author</dt><dd>jfriedlein</dd></dl>
<h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p>The way we see and use Sacado here is as follows: <br />
If you usually compute the following equation <br />
 </p><p class="formulaDsp">
\[ c = a + b \]
</p>
<p> for instance with data types double as <br />
 </p><p class="formulaDsp">
\[ 1.0 + 1.0 \rightarrow 2.0 \]
</p>
<p> your results is just a double number \( c \) that contains the value \( 2 \). <br />
 Using Sacado, on the other hand, the variable \( c_{fad} \) is now of, for example, data type </p><div class="fragment"><div class="line">Sacado::Fad::DFad&lt;double&gt; c_fad;</div></div><!-- fragment --><p> As a result, \( c_{fad} \) now contains not just the number \( 2 \), but also all the derivatives of \( c_{fad} \) with respect to the previously defined degrees of freedom (set via command *.diff(*)). <br />
The following figure tries to visualize this for first derivatives: </p><div class="image">
<img src="Sacado_data-type.png" alt="Sacado_data-type.png"/>
</div>
<p> and for second derivatives (requires different data type): </p><div class="image">
<img src="Sacado_data-type_1_2_derivatives.png" alt="Sacado_data-type_1_2_derivatives.png"/>
</div>
<p> Every variable that was declared as such a data type now contains besides the actual value \( c \), also its derivatives.</p>
<h2><a class="anchor" id="subsec_overview"></a>
Overview</h2>
<p>This overview shall give you first impression what to expect from each of the examples. The background/basics group gives you the promised look under the hood. Whereas the application group shows you how you can use the <a class="el" href="namespaceSacado__Wrapper.html">Sacado_Wrapper</a> to quickly compute tangents. </p><div class="image">
<img src="overview_of_examples.png" alt="overview_of_examples.png"/>
</div>
<p>If you right away want to use Sacado, then you might skip the first examples and jump to <a class="el" href="index.html#Ex3B">example 3B</a>. There we show how to use the "Sacado_Wrapper" that does everything from <a class="el" href="index.html#Ex2">example 2</a> and <a class="el" href="index.html#Ex3">example 3</a> in just a view lines of code. This does not mean that the here shown approach is the fastest or most efficient, it is just simple and easy to use.</p>
<p>Furthermore, if you, for instance, compute problems with two-fields (e.g. displacement and scalar damage) and you need tangents with respect to both a tensor (e.g. strain tensor) and a scalar (e.g. damage variable), you can use the <a class="el" href="namespaceSacado__Wrapper.html">Sacado_Wrapper</a> as shown in <a class="el" href="index.html#Ex4">example 4</a>.</p>
<h2><a class="anchor" id="subsec_more_basics"></a>
Some more basics</h2>
<p>One can access the double value of \( c_{fad} \) with the Sacado command *.val(): </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> c_value = c_fad.val();</div></div><!-- fragment --><p> The derivatives of \( c_{fad} \) can be accessed with the command *.dx(): </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> d_c_d_a = c_fad.dx(0);</div><div class="line"><span class="keywordtype">double</span> c_c_d_b = c_fad.dx(1);</div></div><!-- fragment --><p> The arguments of <em>dx</em>, namely 0 and 1 are the numbers corresponding to the dof that belong to <em>a</em> and <em>b</em>. More details on how to set this up and use it, are given in <a class="el" href="index.html#Ex1">example 1</a>.</p>
<h2><a class="anchor" id="subsec_resources"></a>
Some resources/links</h2>
<p>You can use Sacado to compute general derivatives of functions (with or without tensors) with respect to variables (double, Tensors, ...).</p><ul>
<li>Basics on Sacado, automatic differentation and coding examples (important remarks, e.g. on point of non-differentiability): <br />
 <a href="https://software.sandia.gov/SESS/past_seminars/111307_Phipps.pdf">https://software.sandia.gov/SESS/past_seminars/111307_Phipps.pdf</a></li>
<li>Basics and available autodiff libraries provided by deal.ii: <br />
 <a href="https://www.dealii.org/current/doxygen/deal.II/group__auto__symb__diff.html">https://www.dealii.org/current/doxygen/deal.II/group__auto__symb__diff.html</a></li>
<li>Template-based generic programming: <br />
 downloads.hindawi.com/journals/sp/2012/202071.pdf</li>
<li>Tutorial 33 by deal.ii: introduction to Sacado and implementation to assemble the residuum and compute its derivative <br />
 <a href="https://www.dealii.org/current/doxygen/deal.II/step_33.html">https://www.dealii.org/current/doxygen/deal.II/step_33.html</a></li>
</ul>
<p>The here shown examples shall solely show how Sacado can be applied and give some background and a look under the hood. The code is neither elegant nor efficient, but it works. A more user-friendly version is provided by means of the "Sacado_Wrapper". <br />
</p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Check if factor 0.5 is also necessary for d_sigma / d_phi</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This documentation and code only protocol my first steps with Sacado. They are not guaranteed to be correct neither are they verified. Any comments, criticism, corrections, feedback, improvements, ... are appreciated and very well welcomed.</dd></dl>
<h1><a class="anchor" id="code"></a>
The commented program</h1>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Author: jfriedlein, 2019</span></div><div class="line"><span class="comment"> *      dsoldner, 2019</span></div><div class="line"><span class="comment"> */</span></div></div><!-- fragment --> <h1><a class="anchor" id="includes"></a>
Include Files</h1>
<p>The data type SymmetricTensor and some related operations, such as trace, symmetrize, deviator, ... for tensor calculus </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/symmetric_tensor.h&gt;</span></div></div><!-- fragment --><p> C++ headers (some basics, standard stuff) </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div></div><!-- fragment --><p> Sacado (from Trilinos, data types, operations, ...) </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Sacado.hpp&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="Sacado__Wrapper_8h.html">Sacado_Wrapper.h</a>&quot;</span></div></div><!-- fragment --><p> Those headers are related to data types and autodiff, but don't seem to be needed </p><div class="fragment"><div class="line"><span class="comment">//#  include &lt;deal.II/base/numbers.h&gt;</span></div><div class="line"><span class="comment">//#  include &lt;deal.II/differentiation/ad/ad_number_traits.h&gt;</span></div><div class="line"><span class="comment">//#  include &lt;deal.II/differentiation/ad/sacado_number_types.h&gt;</span></div></div><!-- fragment --><p> According to the basics of deal.ii-programming (see dealii.org and <a href="https://www.dealii.org/current/doxygen/deal.II/step_1.html">https://www.dealii.org/current/doxygen/deal.II/step_1.html</a> for a start) </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p> Defining a data type for the Sacado variables (here we simply used the standard types from the deal.ii step-33 tutorial's introduction) </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="Sacado__example_8cc.html#a868b94676739e612d9c95940e70892a9">fad_double</a> = Sacado::Fad::DFad&lt;double&gt;;   <span class="comment">// this data type now represents a double, but also contains the derivative of this variable with respect to the defined dofs (set via command *.diff(*))</span></div></div><!-- fragment --> <h1><a class="anchor" id="Ex1"></a>
1. example: simple scalar equation</h1>
<ol type="1">
<li>example: simple scalar equation from deal.ii-tutorial step-33 (see the introduction there to get a first impression, <a href="https://www.dealii.org/current/doxygen/deal.II/step_33.html">https://www.dealii.org/current/doxygen/deal.II/step_33.html</a>) <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>clean up the documentation of the classes</dd></dl>
</li>
</ol>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="Sacado__example_8cc.html#a71b2675e62203edc430e7ffc8a365193">sacado_test_scalar</a> ()</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Scalar Test:&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p> Define the variables used in the computation (inputs/independent variables: a, b; output/result: c; auxiliaries/passive variables: *) as the Sacado-data type </p><div class="fragment"><div class="line"><a class="code" href="Sacado__example_8cc.html#a868b94676739e612d9c95940e70892a9">fad_double</a> a,b,<a class="code" href="CMakeCache_8txt.html#aac1d6a1710812201527c735f7c6afbaa">c</a>;</div></div><!-- fragment --><p> Initialize the input variables a and b; This (a,b) = (1,2) will be the point where the derivatives are computed. Compare: y=x² -&gt; (dy/dx)(@x=1) = 2. We can only compute the derivative numerically at a certain point. </p><div class="fragment"><div class="line"> a = 1;</div><div class="line"> b = 2;</div><div class="line"></div><div class="line">a.diff(0,2);  <span class="comment">// Set a to be dof 0, in a 2-dof system.</span></div><div class="line">b.diff(1,2);  <span class="comment">// Set b to be dof 1, in a 2-dof system.</span></div></div><!-- fragment --><p> Our equation here is very simply. But you can use nested equations and many standard mathematical operations, such as sqrt, pow, sin, ... </p><div class="fragment"><div class="line">c = 2*a + std::cos(a*b);</div><div class="line"><span class="keywordtype">double</span> *derivs = &amp;c.fastAccessDx(0); <span class="comment">// Access the derivatives of</span></div></div><!-- fragment --><p> Output the derivatives of c with respect to the two above defined degrees of freedom (dof) </p><div class="fragment"><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Derivatives at the point (&quot;</span> &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;dc/da = &quot;</span> &lt;&lt; derivs[0] &lt;&lt; <span class="stringliteral">&quot;, dc/db=&quot;</span> &lt;&lt; derivs[1] &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex2"></a>
2. example: Preparation for the use of Sacado with tensors</h1>
<p>Here we want to introduce tensors for the first time. Hence, we limit ourselves to a trivial equation relating the strain tensor <em>eps</em> with dim x dim components with the stress tensor <em>sigma</em>. Both here used tensors are symmetric, hence we use the SymmetricTensor class and have to keep some details in mind (see below factor 0.5 related to Voigt-Notation). Don't be scared by the enormous number of repetitive lines of code, everything shown in this example and the following will be handled by the <a class="el" href="namespaceSacado__Wrapper.html">Sacado_Wrapper</a> with roughly four lines of code. </p><div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 2. example: use of tensors</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="Sacado__example_8cc.html#a8ef4ff1e9526ca8451cdcd1678366d2c">sacado_test_2</a> ()</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Test 2:&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p> First we set the dimension <em>dim:</em> 2D-&gt;dim=2; 3D-&gt;dim=3 <br />
 This defines the "size" of the tensors and the number of dofs. <a class="el" href="index.html#Ex2">Example 2</a> only works in 3D, whereas the following Ex3 is set up dimension-independent. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 3;</div></div><!-- fragment --><p> Declare our input, auxiliary and output variables as SymmetricTensors consisting of fad_doubles (instead of the standard SymmetricTensor out of doubles) </p><div class="fragment"><div class="line">SymmetricTensor&lt;2,dim, fad_double&gt; sigma, eps;</div></div><!-- fragment --><p> Init the strain tensor (the point at which the derivative shall be computed) </p><div class="fragment"><div class="line">eps[0][0] = 1;</div><div class="line">eps[1][1] = 2;</div><div class="line">eps[2][2] = 3;</div><div class="line">eps[0][1] = 4;</div><div class="line">eps[0][2] = 5;</div><div class="line">eps[1][2] = 6;</div></div><!-- fragment --><p> Now we declare the dofs. The derivative to a tensor requires all components, therefore we set the components of the strain tensor here one by one as the dofs. Because our tensors are symmetric, we only need 6 components in 3D instead of 9 for a full second order tensor </p><div class="fragment"><div class="line">eps[0][0].diff(0,6);</div><div class="line">eps[1][1].diff(1,6);</div><div class="line">eps[2][2].diff(2,6);</div><div class="line">eps[0][1].diff(3,6);</div><div class="line">eps[0][2].diff(4,6);</div><div class="line">eps[1][2].diff(5,6);</div></div><!-- fragment --><p> The equation describing the stresses (here just a simple test case) </p><div class="fragment"><div class="line">sigma = eps;</div></div><!-- fragment --><p> Let's output the computed stress tensor. </p><div class="fragment"><div class="line">std::cout &lt;&lt; sigma &lt;&lt; std::endl;</div></div><!-- fragment --><p> The resulting values of <em>sigma</em> are fairly boring, due to our simple equation. It is the additional output generated by this, that is interesting here: <br />
output: <br />
1 [ 1 0 0 0 0 0 ] 4 [ 0 0 0 1 0 0 ] 5 [ 0 0 0 0 1 0 ] 4 [ 0 0 0 1 0 0 ] 2 [ 0 1 0 0 0 0 ] 6 [ 0 0 0 0 0 1 ] 5 [ 0 0 0 0 1 0 ] 6 [ 0 0 0 0 0 1 ] 3 [ 0 0 1 0 0 0 ] <br />
The numbers 1, 4, 5, 4, ... are the entries in the stress tensor <em>sigma</em>. In square brackets we see the derivatives of sigma with respect to all the dofs set previously given in the order we defined them above. Meaning: The first entry in the square brackets corresponds to the 0-th dof set by </p><div class="fragment"><div class="line">eps[0][0].diff(0,6); </div></div><!-- fragment --><p> referring to the component (0,0) in the strain tensor <em>eps</em>.</p>
<p>Computing the derivatives for certain components of the resulting tangent modulus: <br />
We now access these lists of derivatives (output above in square brackets) for one component of the stress tensor <em>sigma</em> at a time. </p><div class="fragment"><div class="line">{</div></div><!-- fragment --><p> Access the derivatives corresponding to the component (0,0) of the stress tensor <em>sigma</em> </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> *derivs = &amp;sigma[0][0].fastAccessDx(0);</div></div><!-- fragment --><p> The following output will show us the same derivatives that we already saw above, just formatted differently <br />
output: d_sigma[0][0]/d_eps = 1 , 0 , 0 , 0 , 0 , 0 , </p><div class="fragment"><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;d_sigma[0][0]/d_eps = &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;6; ++i)</div><div class="line">        std::cout &lt;&lt; derivs[i] &lt;&lt; <span class="stringliteral">&quot; , &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div><div class="line">{</div></div><!-- fragment --><p> Access the derivatives corresponding to the component (1,2) of the stress tensor <em>sigma</em> </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> *derivs = &amp;sigma[1][2].fastAccessDx(0);</div></div><!-- fragment --><p> output: d_sigma[1][2]/d_eps = 0 , 0 , 0 , 0 , 0 , 1 , </p><div class="fragment"><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;d_sigma[1][2]/d_eps = &quot;</span>;</div><div class="line">        <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;6; ++i)</div><div class="line">            std::cout &lt;&lt; derivs[i] &lt;&lt; <span class="stringliteral">&quot; , &quot;</span>;</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex3"></a>
3. example: Using a slightly more complicated stress equation</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="Sacado__example_8cc.html#ae45e1df0eec246dbb6f2c3d28a2a58e4">sacado_test_3</a> ()</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Test 3:&quot;</span> &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 3;</div></div><!-- fragment --><p> Here we also define some constant, for instance the bulk modulus <em>kappa</em> and the second Lamè parameter <em>mu</em>. We now also define one of our constants as fad_double. By doing this we can use the normal multiplication (see below). </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> kappa_param = 5;</div><div class="line"><a class="code" href="Sacado__example_8cc.html#a868b94676739e612d9c95940e70892a9">fad_double</a> kappa (kappa_param);</div></div><!-- fragment --><p> The second constant remains as a double just to show the difference. </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> mu = 2;</div><div class="line"></div><div class="line">SymmetricTensor&lt;2,dim, fad_double&gt; sigma, eps;</div></div><!-- fragment --><p> To simplify the access to the dofs we define a map that relate the components of our strain tensor to the dof-nbr </p><div class="fragment"><div class="line">std::map&lt;unsigned int,std::pair&lt;unsigned int,unsigned int&gt;&gt; std_map_indicies;</div></div><!-- fragment --><p> The point at which the derivative shall be computed: <br />
As mentioned previously, we will implement this example for 2D and 3D, hence we once have to set up a strain tensor and the derivatives for 3D with 6 independent components ... </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(dim==3)</div><div class="line">{</div><div class="line">    eps[0][0] = 1;</div><div class="line">    eps[1][1] = 2;</div><div class="line">    eps[2][2] = 3;</div><div class="line"></div><div class="line">    eps[0][1] = 4;</div><div class="line">    eps[0][2] = 5;</div><div class="line">    eps[1][2] = 6;</div><div class="line"></div><div class="line"></div><div class="line">    eps[0][0].diff(0,6);</div><div class="line">    eps[0][1].diff(1,6);</div><div class="line">    eps[0][2].diff(2,6);</div><div class="line">    eps[1][1].diff(3,6);</div><div class="line">    eps[1][2].diff(4,6);</div><div class="line">    eps[2][2].diff(5,6);</div></div><!-- fragment --><p> By using the map and the following pairs, we have to set up the relation between strain components and dofs only once and can use the map to access the entries of the list later, without possibly mixing up indices and creating errors. Please don't be confused, but the dofs in the Wrapper are set up in a different order that we showed earlier. Earlier: (0,0)-(1,1)-(2,2)-...; Now: (0,0)-(0,1)-(0,2)-... </p><div class="fragment"><div class="line">    std::pair&lt;unsigned int, unsigned int&gt; tmp_pair;</div><div class="line">    tmp_pair.first=0; tmp_pair.second=0;</div><div class="line">    std_map_indicies[0] = tmp_pair;</div><div class="line"></div><div class="line">    tmp_pair.first=0; tmp_pair.second=1;</div><div class="line">    std_map_indicies[1] = tmp_pair;</div><div class="line"></div><div class="line">    tmp_pair.first=0; tmp_pair.second=2;</div><div class="line">    std_map_indicies[2] = tmp_pair;</div><div class="line"></div><div class="line">    tmp_pair.first=1; tmp_pair.second=1;</div><div class="line">    std_map_indicies[3] = tmp_pair;</div><div class="line"></div><div class="line">    tmp_pair.first=1; tmp_pair.second=2;</div><div class="line">    std_map_indicies[4] = tmp_pair;</div><div class="line"></div><div class="line">    tmp_pair.first=2; tmp_pair.second=2;</div><div class="line">    std_map_indicies[5] = tmp_pair;</div><div class="line">}</div></div><!-- fragment --><p> ... and once for 2D with just 3 independent components. </p><div class="fragment"><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span>(dim==2)</div><div class="line">{</div><div class="line">    eps[0][0] = 1;</div><div class="line">    eps[1][1] = 2;</div><div class="line"></div><div class="line">    eps[0][1] = 4;</div><div class="line"></div><div class="line"></div><div class="line">    eps[0][0].diff(0,3);</div><div class="line">    eps[0][1].diff(1,3);</div><div class="line">    eps[1][1].diff(2,3);</div><div class="line"></div><div class="line">    std::pair&lt;unsigned int, unsigned int&gt; tmp_pair;</div><div class="line">    tmp_pair.first=0; tmp_pair.second=0;</div><div class="line">    std_map_indicies[0] = tmp_pair;</div><div class="line"></div><div class="line">    tmp_pair.first=0; tmp_pair.second=1;</div><div class="line">    std_map_indicies[1] = tmp_pair;</div><div class="line"></div><div class="line">    tmp_pair.first=1; tmp_pair.second=1;</div><div class="line">    std_map_indicies[2] = tmp_pair;        </div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;only dim==2 or dim==3 allowed&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p> Instead of calling the *.diff(*) on the components one-by-one we could also use the following for-loop, so we also use the map to set the dofs (as we will do in the Wrapper later). </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=0; x&lt;((dim==2)?3:6); ++x )</div><div class="line">{</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=std_map_indicies[x].first;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=std_map_indicies[x].second;</div><div class="line">    eps[i][j].diff(x,((dim==2)?3:6));</div><div class="line">}</div></div><!-- fragment --><p>For our slightly more complicated stress equation we need the unit and deviatoric tensors. We can simply define them by writing the values of the already existing deal.ii functions into newly defined SymmetricTensors build from fad_doubles. </p><div class="fragment"><div class="line">SymmetricTensor&lt;2,dim, fad_double&gt; stdTensor_I (( unit_symmetric_tensor&lt;dim,fad_double&gt;()) );</div><div class="line">SymmetricTensor&lt;4,dim, fad_double&gt; stdTensor_Idev ( (deviator_tensor&lt;dim,fad_double&gt;()) );</div></div><!-- fragment --><p> With everything set and defined, we can compute our stress <em>sigma</em> according to: </p><p class="formulaDsp">
\[ \sigma = \kappa \cdot trace(\varepsilon) \cdot \boldsymbol{I} + 2 \cdot \mu \cdot \varepsilon^{dev} \]
</p>
<p> Here you can see that we can directly multiply the constant and the tensors when kappa is also declared as fad_double </p><div class="fragment"><div class="line">sigma = kappa * (trace(eps) *  stdTensor_I);</div></div><!-- fragment --><p> We didn't do the same for mu to once again emphasize the difference between constants as double and as fad_double. <br />
The remaining code uses a normal double constant. </p><div class="fragment"><div class="line">SymmetricTensor&lt;2,dim,fad_double&gt; tmp = deviator&lt;dim,fad_double&gt;(symmetrize&lt;dim,fad_double&gt;(eps)); tmp*=(mu*2);</div><div class="line">sigma +=  tmp;</div></div><!-- fragment --><p> The fairly cumbersome computation is caused by the way the operators are set up for tensors out of fad_doubles.</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;sigma=&quot;</span> &lt;&lt; sigma &lt;&lt; std::endl;</div></div><!-- fragment --><p> Now we want to actually build our tangent modulus called <em>C_Sacado</em> that contains all the derivatives and relates the stress tensor with the strain tensor. <br />
The fourth-order tensor <em>C_Sacado</em> is our final goal, we don't have to compute anything that is related to Sacado with this tensor, so we can finally return to our standard SymmetricTensor out of doubles. The latter is necessary to use the tangent in the actual FE code. </p><div class="fragment"><div class="line">SymmetricTensor&lt;4,dim&gt; C_Sacado;</div></div><!-- fragment --><p> As in <a class="el" href="index.html#Ex2">example 2</a> we access the components of the stress tensor one by one. In order to capture all of them we loop over the components i and j of the stress tensor. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; ++j )</div><div class="line">    {</div><div class="line">        <span class="keywordtype">double</span> *derivs = &amp;sigma[i][j].fastAccessDx(0); <span class="comment">// Access the derivatives of the (i,j)-th component of \a sigma</span></div></div><!-- fragment --><p> To visually ensure that every stress component has in fact all 6 derivatives for 3D or 3 for 2D, we output the size: </p><div class="fragment"><div class="line">std::cout&lt;&lt;<span class="stringliteral">&quot;size: &quot;</span>&lt;&lt;sigma[i][j].size()&lt;&lt;std::endl;</div></div><!-- fragment --><p> We loop over all the dofs. To be able to use this independent of the chosen dimension <em>dim</em>, we use a ternary operator to decide whether we have to loop over 6 derivatives or just 3. </p><div class="fragment"><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=0;x&lt;((dim==2)?3:6);++x)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=std_map_indicies[x].first;</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=std_map_indicies[x].second;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span>(k!=l)<span class="comment">/*Compare to Voigt notation since only SymmetricTensor instead of Tensor*/</span></div><div class="line">        {</div><div class="line">            C_Sacado[i][j][k][l] = 0.5*derivs[x];</div><div class="line">            C_Sacado[i][j][l][k] = 0.5*derivs[x];</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">            C_Sacado[i][j][k][l] = derivs[x];</div><div class="line">    }            </div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> After resembling the fourth-order tensor, we now have got our tangent saved in <em>C_Sacado</em> ready to be used</p>
<p>To ensure that Sacado works properly, we can compute the analytical tangent for comparison </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> kappa_d = 5;</div><div class="line"><span class="keywordtype">double</span> mu_d = 2;</div></div><!-- fragment --><p> Our stress equation in this example is still simple enough to derive the tangent analytically by hand: </p><p class="formulaDsp">
\[ \overset{4}{C_{analy}} = \kappa \cdot \boldsymbol{I} \otimes \boldsymbol{I} + 2 \cdot \mu \cdot \overset{4}{I^{dev}} \]
</p>
 <div class="fragment"><div class="line">SymmetricTensor&lt;4,dim&gt; C_analy = kappa_d * outer_product(unit_symmetric_tensor&lt;dim&gt;(), unit_symmetric_tensor&lt;dim&gt;()) + 2* mu_d * deviator_tensor&lt;dim&gt;();</div></div><!-- fragment --><p> We again define our strain tensor <em>eps_d</em> (*_d for standard double in contrast to fad_double) </p><div class="fragment"><div class="line">SymmetricTensor&lt;2,dim&gt; eps_d;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span>(dim==3)</div><div class="line">{</div><div class="line">    eps_d[0][0] = 1;</div><div class="line">    eps_d[1][1] = 2;</div><div class="line">    eps_d[2][2] = 3;</div><div class="line"></div><div class="line">    eps_d[0][1] = 4;</div><div class="line">    eps_d[0][2] = 5;</div><div class="line">    eps_d[2][1] = 6;</div><div class="line"></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span>(dim==2)</div><div class="line">{</div><div class="line">    eps_d[0][0] = 1;</div><div class="line">    eps_d[1][1] = 2;</div><div class="line"></div><div class="line">    eps_d[1][0] = 4;</div><div class="line"></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;only dim==2 or dim==3 allowed&quot;</span>);</div><div class="line">}</div></div><!-- fragment --> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>use boldsymbol for tensors</dd></dl>
<p>To output the stress tensor we first have to compute it. We do this here via </p><p class="formulaDsp">
\[ \sigma = \overset{4}{C_{analy}} : \varepsilon \]
</p>
<p> The output exactly matched the result obtained with Sacado. </p><dl class="section note"><dt>Note</dt><dd>Checking the Sacado stress tensor against an analytically computed or otherwise determined stress tensor is absolutely no way to check whether the tangent computed via Sacado is correct. When we compute the stress tensor with Sacado and for example mix up a + and - sign, this might not matter at all if the number that is added or subtracted is small. However, for the tangent this nasty sign can be very critical. Just keep in mind: the tangent has 81 components and the stress tensor just 9, so how does one want to verify 81 variables by comparing 9?</dd></dl>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;sigma_analy: &quot;</span> &lt;&lt; (C_analy*eps_d) &lt;&lt; std::endl;</div></div><!-- fragment --><p> That's the reason we compare all the entries in the Sacado and the analytical tensor one by one </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; ++j)</div><div class="line">        <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dim; ++k)</div><div class="line">            <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l&lt;dim; ++l)</div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;C_analy[&quot;</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;][&quot;</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">&quot;][&quot;</span>&lt;&lt;k&lt;&lt;<span class="stringliteral">&quot;][&quot;</span>&lt;&lt;l&lt;&lt;<span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; C_analy[i][j][k][l] &lt;&lt; <span class="stringliteral">&quot; vs C_Sacado: &quot;</span> &lt;&lt; C_Sacado[i][j][k][l] &lt;&lt; std::endl;</div></div><!-- fragment --><p> To simplify the comparison we compute a scalar error as the sum of the absolute differences of each component </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> error_Sacado_vs_analy=0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; ++j)</div><div class="line">        <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dim; ++k)</div><div class="line">            <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l&lt;dim; ++l)</div><div class="line">                error_Sacado_vs_analy += std::fabs(C_Sacado[i][j][k][l] - C_analy[i][j][k][l]);</div></div><!-- fragment --><p> As desired: The numerical error is zero (0 in double precision) and the tensor components are equal </p><div class="fragment"><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;numerical error: &quot;</span> &lt;&lt; error_Sacado_vs_analy &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex3B"></a>
3B. Example: Using the wrapper for Ex3</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="Sacado__example_8cc.html#ae63cc8526935cb0512668e83cfc7b929">sacado_test_3B</a> ()</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Test 3B:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim=3;</div></div><!-- fragment --><p> The following declarations are usually input arguments. So you receive the strain tensor and the constants out of doubles. </p><div class="fragment"><div class="line">SymmetricTensor&lt;2,dim&gt; eps_d;</div><div class="line">eps_d[0][0] = 1;</div><div class="line">eps_d[1][1] = 2;</div><div class="line">eps_d[2][2] = 3;</div><div class="line"></div><div class="line">eps_d[0][1] = 4;</div><div class="line">eps_d[0][2] = 5;</div><div class="line">eps_d[1][2] = 6;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> kappa = 5;</div><div class="line"><span class="keywordtype">double</span> mu = 2;</div></div><!-- fragment --><p> Now we start working with Sacado: <br />
When we use the index notation to compute e.g. our stress we do not need to declare our constants (here kappa, mu) as fad_double.</p>
<p>We declare our strain tensor as the special data type <a class="el" href="classSacado__Wrapper_1_1SymTensor.html">Sacado_Wrapper::SymTensor</a> from the file "Sacado_Wrapper.h" where this data type was derived from the SymmetricTensor&lt;2,dim,fad_double&gt;. </p><div class="fragment"><div class="line"><a class="code" href="classSacado__Wrapper_1_1SymTensor.html">Sacado_Wrapper::SymTensor&lt;dim&gt;</a> eps;</div></div><!-- fragment --><p> Next we initialize our Sacado strain tensor with the values of the inputed double strain tensor: </p><div class="fragment"><div class="line">eps.<a class="code" href="classSacado__Wrapper_1_1SymTensor.html#acbad579d5ead9e96ff46aa15d9b5aef4">init</a>(eps_d);</div></div><!-- fragment --><p> We define all the entries in the symmetric tensor <em>eps</em> as the dofs. So we can later derive any variable with respect to the strain tensor <em>eps</em>. </p><div class="fragment"><div class="line">eps.<a class="code" href="classSacado__Wrapper_1_1SymTensor.html#aa9e0fcc9d4e0a4120bedb8ef9b8d7ecb">set_dofs</a>();</div></div><!-- fragment --><p> Now we declare our output and auxiliary variables as Sacado-Tensors. </p><div class="fragment"><div class="line">SymmetricTensor&lt;2,dim,fad_double&gt; sigma;</div><div class="line"></div><div class="line">SymmetricTensor&lt;2,dim, fad_double&gt; stdTensor_I (( unit_symmetric_tensor&lt;dim,fad_double&gt;()) );</div></div><!-- fragment --><p> Our stress equation is now computed in index notation to simplify the use of the constants and especially the use of the <em>deviator</em>. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; ++j )</div><div class="line">      sigma[i][j] = kappa * trace(eps) *  stdTensor_I[i][j] + 2. * mu * deviator(eps)[i][j];</div></div><!-- fragment --><p> Finally we declare our desired tangent as the fourth order tensor <em>C_Sacado</em> and compute the tangent via the command <em>get_tangent</em>. </p><div class="fragment"><div class="line">SymmetricTensor&lt;4,dim&gt; C_Sacado;</div><div class="line">eps.<a class="code" href="classSacado__Wrapper_1_1SymTensor.html#ab97427c3b5cab279e58607cf431ab262">get_tangent</a>(C_Sacado, sigma);</div></div><!-- fragment --><p> We could again compare the herein computed tangent with the analytical tangent from Ex2, but as before the results are fairly boring, because Sacado hits the analytical tangent exactly &mdash; no surprise for such simple equations.</p>
<p>And that's it. By using the Sacado_wrapper we can achieve everything from Ex2 (besides the equations) with just four lines of code namely:</p><ul>
<li>eps.init(eps_d); // To initialize the Sacado strain tensor</li>
<li>eps.set_dofs(); // To declare the components of eps as the dofs</li>
<li>eps.get_tangent(*); // To get the tangent <div class="fragment"><div class="line">}</div></div><!-- fragment --> </li>
</ul>
<h1><a class="anchor" id="Ex4"></a>
4. Example: Computing derivatives with respect to a tensor and a scalar</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="Sacado__example_8cc.html#a2f4def4563e31d720e07bc7d6363ebe2">sacado_test_4</a> ()</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Test 4:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim=3;</div></div><!-- fragment --><p> The following declarations are usually input arguments. So you receive the strain tensor  eps_d, the damage variable <em>phi</em> and the constants <em>kappa</em> and <em>mu</em> out of doubles. </p><div class="fragment"><div class="line">SymmetricTensor&lt;2,dim&gt; eps_d;</div><div class="line">eps_d[0][0] = 1;</div><div class="line">eps_d[1][1] = 2;</div><div class="line">eps_d[2][2] = 3;</div><div class="line"></div><div class="line">eps_d[0][1] = 4;</div><div class="line">eps_d[0][2] = 5;</div><div class="line">eps_d[1][2] = 6;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> phi_d = 0.3;</div></div><!-- fragment --><p> We don't need these constants in the current example. double kappa = 5; double mu = 2;</p>
<p>We set up our strain tensor as in Ex3B. </p><div class="fragment"><div class="line"><a class="code" href="classSacado__Wrapper_1_1SymTensor.html">Sacado_Wrapper::SymTensor&lt;dim&gt;</a> eps;</div><div class="line"><a class="code" href="classSacado__Wrapper_1_1SW__double.html">Sacado_Wrapper::SW_double&lt;dim&gt;</a> phi;</div></div><!-- fragment --><p> Initialize the strain tensor and the damage variable </p><div class="fragment"><div class="line">eps.<a class="code" href="classSacado__Wrapper_1_1SymTensor.html#acbad579d5ead9e96ff46aa15d9b5aef4">init</a>(eps_d);</div><div class="line">phi.<a class="code" href="classSacado__Wrapper_1_1SW__double.html#adca799dd92dadebda9aebc91c797682a">init</a>(phi_d);</div></div><!-- fragment --><p> Set the dofs, where the argument sets the total nbr of dofs (3 or 6 for the sym. tensor and 1 for the double) </p><div class="fragment"><div class="line"><span class="comment">//    eps.set_dofs(eps.n_independent_components+1/*an additional dof for phi*/);</span></div></div><!-- fragment --><p>In order to also compute derivatives with respect to the scalar <em>phi</em>, we add this scalar to our list of derivatives. Because we have already defined 3 or 6 dofs our additional dof will be placed at the end of this list. We set this up with the member variable start_index ... </p><div class="fragment"><div class="line"><span class="comment">//    phi.start_index=eps.n_independent_components;</span></div></div><!-- fragment --><p> and again using the input argument representing the total number of dofs </p><div class="fragment"><div class="line"><span class="comment">//    phi.set_dofs(eps.n_independent_components+1);</span></div></div><!-- fragment --><p> All of the above 3 lines of code are automatically done by the DoFs_summary class. So, to set our dofs we just create an instance and call set_dofs with our variables containing the desired dofs. </p><div class="fragment"><div class="line"><a class="code" href="classSacado__Wrapper_1_1DoFs__summary.html">Sacado_Wrapper::DoFs_summary&lt;dim&gt;</a> DoFs_summary;</div><div class="line">DoFs_summary.<a class="code" href="classSacado__Wrapper_1_1DoFs__summary.html#a556293f6e683cb30151d9faadc2cc90d">set_dofs</a>(eps, phi);</div></div><!-- fragment --><p> Compute the stress tensor and damage variable <em>d</em> (here we just use some arbitrary equations for testing): <br />
Let us first declare our output (and auxiliary) variables as Sacado data types. </p><div class="fragment"><div class="line">SymmetricTensor&lt;2,dim,fad_double&gt; sigma;</div><div class="line"><a class="code" href="Sacado__example_8cc.html#a868b94676739e612d9c95940e70892a9">fad_double</a> d;</div></div><!-- fragment --> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>It would be nice to use the data types from the <a class="el" href="namespaceSacado__Wrapper.html">Sacado_Wrapper</a> for all the Sacado variables. But somehow the operators (multiply*, ...) seem to cause conflicts again.</dd></dl>
<p>The actual computation in the following scope uses the exact same equation as your normal computation e. g. via the data type double. Hence, you could either directly compute your stress, etc. via the Sacado variables or you define template functions that contain your equations and are either called templated with double or fad_double. When using the first option, please consider the computation time that is generally higher for a computation with fad_double than with normal doubles (own experience in a special case: slower by factor 30). The second option with templates does not suffer these issues. </p><div class="fragment"><div class="line">{</div><div class="line">d = phi*phi + 25 + trace(eps) + eps.norm();</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d=&quot;</span> &lt;&lt; d &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; ++j )</div><div class="line">      sigma[i][j] = phi * d * eps[i][j];</div></div><!-- fragment --><p> ToDo: strangely when phi is a fad_double then the multiplication phi * eps works directly without having to use the index notation </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;sigma=&quot;</span> &lt;&lt; sigma &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> Get the tangents d_sigma / d_eps: SymmetricTensor with respect to SymmetricTensor </p><div class="fragment"><div class="line">SymmetricTensor&lt;4,dim&gt; C_Sacado;</div><div class="line">eps.<a class="code" href="classSacado__Wrapper_1_1SymTensor.html#ab97427c3b5cab279e58607cf431ab262">get_tangent</a>(C_Sacado, sigma);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;C_Sacado=&quot;</span> &lt;&lt; C_Sacado &lt;&lt; std::endl;</div></div><!-- fragment --><p> Compute the analytical tangent: </p><div class="fragment"><div class="line">SymmetricTensor&lt;4,dim&gt; C_analy;</div><div class="line">C_analy = ( std::pow(phi_d, 3) + 25*phi_d + phi_d*trace(eps_d) + phi_d*eps_d.norm() ) * identity_tensor&lt;dim&gt;()</div><div class="line">          + phi_d * outer_product( eps_d, unit_symmetric_tensor&lt;dim&gt;())</div><div class="line">          + phi_d * outer_product( eps_d, eps_d ) * 1./eps_d.norm();</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Be aware of the difference between <p class="formulaDsp">
\[ eps_d \otimes \boldsymbol{1} \text{ and } \boldsymbol{1} \otimes eps_d \]
</p>
 <div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;C_analy =&quot;</span> &lt;&lt; C_analy &lt;&lt; std::endl;</div></div><!-- fragment --> To simplify the comparison we compute a scalar error as the sum of the absolute differences of each component <div class="fragment"><div class="line"><span class="keywordtype">double</span> error_Sacado_vs_analy=0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; ++j)</div><div class="line">         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dim; ++k)</div><div class="line">             <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l&lt;dim; ++l)</div><div class="line">                 error_Sacado_vs_analy += std::fabs(C_Sacado[i][j][k][l] - C_analy[i][j][k][l]);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;numerical error: &quot;</span> &lt;&lt; error_Sacado_vs_analy &lt;&lt; std::endl &lt;&lt; std::endl;</div></div><!-- fragment --> d_d / d_eps: double with respect to SymmetricTensor <div class="fragment"><div class="line">SymmetricTensor&lt;2,dim&gt; d_d_d_eps;</div><div class="line">eps.<a class="code" href="classSacado__Wrapper_1_1SymTensor.html#ab97427c3b5cab279e58607cf431ab262">get_tangent</a>(d_d_d_eps, d);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d_d_d_eps      =&quot;</span> &lt;&lt; d_d_d_eps &lt;&lt; std::endl;</div><div class="line">SymmetricTensor&lt;2,dim&gt; d_d_d_eps_analy;</div><div class="line">d_d_d_eps_analy = unit_symmetric_tensor&lt;dim&gt;() + eps_d / eps_d.norm();</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d_d_d_eps_analy=&quot;</span> &lt;&lt; d_d_d_eps_analy &lt;&lt; std::endl &lt;&lt; std::endl;</div></div><!-- fragment --> d_sigma / d_phi: SymmetricTensor with respect to double <div class="fragment"><div class="line">SymmetricTensor&lt;2,dim&gt; d_sigma_d_phi;</div><div class="line">phi.<a class="code" href="classSacado__Wrapper_1_1SW__double.html#a2e6eca4457eb22b06172bb5749038f1e">get_tangent</a>(d_sigma_d_phi, sigma);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d_sigma_d_phi      =&quot;</span> &lt;&lt; d_sigma_d_phi &lt;&lt; std::endl;</div><div class="line">SymmetricTensor&lt;2,dim&gt; d_sigma_d_phi_analy;</div><div class="line">d_sigma_d_phi_analy = ( phi_d*phi_d + 25 + trace(eps_d) + eps_d.norm() + 2 * phi_d*phi_d ) * eps_d;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d_sigma_d_phi_analy=&quot;</span> &lt;&lt; d_sigma_d_phi_analy &lt;&lt; std::endl &lt;&lt; std::endl;</div></div><!-- fragment --> Retrieve the values stored in <em>sigma:</em> <div class="fragment"><div class="line">SymmetricTensor&lt;2,dim&gt; sigma_d;</div><div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">      <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; ++j )</div><div class="line">          sigma_d[i][j] = sigma[i][j].val();</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;sigma_d = &quot;</span> &lt;&lt; sigma_d &lt;&lt; std::endl;</div></div><!-- fragment --> d_d / d_phi: double with respect to double <div class="fragment"><div class="line"><span class="keywordtype">double</span> d_d_d_phi;</div><div class="line">phi.<a class="code" href="classSacado__Wrapper_1_1SW__double.html#a2e6eca4457eb22b06172bb5749038f1e">get_tangent</a>(d_d_d_phi, d);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d_d_d_phi=&quot;</span> &lt;&lt; d_d_d_phi &lt;&lt; std::endl;</div></div><!-- fragment --> Retrieve the value stored in d <div class="fragment"><div class="line"><span class="keywordtype">double</span> d_double = d.val();</div></div><!-- fragment --> Taylor-series for point x </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Maybe add some more text on the linearization </dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> x = phi_d + 0.05;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d_lin = d_d_d_phi * (phi_d - x) + d@(phi_d) = &quot;</span> &lt;&lt; d_d_d_phi * (x-phi_d) + d_double &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d@x = &quot;</span> &lt;&lt; x*x + 25 + trace(eps_d) + eps_d.norm() &lt;&lt; std::endl;</div></div><!-- fragment --><p> And that's it. By using the Sacado_wrapper we can compute derivatives with respect to a tensor and a scalar at the same time (besides the equations) in essence with just the following lines of code namely:</p><ul>
<li>eps.init(eps_d); phi.init(phi_d); // To initialize the Sacado strain tensor and scalar damage variable</li>
<li>DoFs_summary.set_dofs(eps, phi); // To declare the components of eps and phi as the dofs</li>
<li>eps.get_tangent(*); // To get tangents with respect to eps</li>
<li>phi.get_tangent(*); // To get tangents with respect to phi <div class="fragment"><div class="line">}</div></div><!-- fragment --> </li>
</ul>
<h1><a class="anchor" id="Ex5"></a>
5. Example: Using a vector-valued equation</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="Sacado__example_8cc.html#a327dbbb4ea7fc9840c46d149843a44c2">sacado_test_5</a> ()</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim=3;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Test 5:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    Tensor&lt;1,dim,fad_double&gt; <a class="code" href="CMakeCache_8txt.html#aac1d6a1710812201527c735f7c6afbaa">c</a>;</div><div class="line">    <a class="code" href="Sacado__example_8cc.html#a868b94676739e612d9c95940e70892a9">fad_double</a> a,b;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs=2;</div><div class="line">    a = 1; b = 2;   <span class="comment">// at the point (a,b) = (1,2)</span></div><div class="line">    a.diff(0,2);  <span class="comment">// Set a to be dof 0, in a 2-dof system.</span></div><div class="line">    b.diff(1,2);  <span class="comment">// Set b to be dof 1, in a 2-dof system.</span></div></div><!-- fragment --><p> c is now a vector with three components </p><div class="fragment"><div class="line">c[0] = 2*a+3*b;</div><div class="line">c[1] = 4*a+5*b;</div><div class="line">c[2] = 6*a+7*b;</div></div><!-- fragment --><p> Access to the derivatives works as before. </p><div class="fragment"><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;dim;++i)</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="Sacado__example_8cc.html#a868b94676739e612d9c95940e70892a9">fad_double</a> &amp;derivs = c[i]; <span class="comment">// Access derivatives</span></div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0;j&lt;n_dofs;++j)</div><div class="line">        {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Derivatives at the point (&quot;</span> &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class="stringliteral">&quot;) for &quot;</span></div><div class="line">            &lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;th component wrt &quot;</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">&quot;th direction &quot;</span>&lt;&lt; std::endl;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;dc_i/dxj = &quot;</span> &lt;&lt; derivs.fastAccessDx(j) &lt;&lt; std::endl;            </div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex6"></a>
6. Example: First and second derivatives - Scalar equation</h1>
<p>The here shown example was copied from <a href="https://github.com/trilinos/Trilinos/blob/master/packages/sacado/example/dfad_dfad_example.cpp">https://github.com/trilinos/Trilinos/blob/master/packages/sacado/example/dfad_dfad_example.cpp</a> and modified to get a first impression on how we can work with first and second derivatives </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="Sacado__example_8cc.html#a27450ab52a9d4250e3f5a5f2a3f8f317">sacado_test_6</a> ()</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Test 6:&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p> Define the variables used in the computation (inputs: a, b; output: c; auxiliaries: *) as doubles </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> a=1;</div><div class="line"><span class="keywordtype">double</span> b=2;</div></div><!-- fragment --><p> Number of independent variables (scalar a and b) </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> num_dofs = 2;</div></div><!-- fragment --><p> Define another data type containing even more Sacado data types </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>try to merge the fad_double data type with this templated data type </dd></dl>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> Sacado::Fad::DFad&lt;double&gt; <a class="code" href="Sacado__Wrapper_8h.html#a7e0893207b87dad05c66a34baac8ed2e">DFadType</a>;</div><div class="line">Sacado::Fad::DFad&lt;DFadType&gt; afad(num_dofs, 0, a);</div><div class="line">Sacado::Fad::DFad&lt;DFadType&gt; bfad(num_dofs, 1, b);</div><div class="line">Sacado::Fad::DFad&lt;DFadType&gt; cfad;</div></div><!-- fragment --><p> Output the variables: We se that the values of <em>a</em> and <em>b</em> are set but the derivatives have not yet been fully declared </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;afad=&quot;</span> &lt;&lt; afad &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;bfad=&quot;</span> &lt;&lt; bfad &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;cfad=&quot;</span> &lt;&lt; cfad &lt;&lt; std::endl;</div></div><!-- fragment --><p> Now we set the "inner" derivatives. </p><div class="fragment"><div class="line">afad.val() = <a class="code" href="Sacado__example_8cc.html#a868b94676739e612d9c95940e70892a9">fad_double</a>(num_dofs, 0, a); <span class="comment">// set afad.val() as the first dof and init it with the double a</span></div><div class="line">bfad.val() = <a class="code" href="Sacado__example_8cc.html#a868b94676739e612d9c95940e70892a9">fad_double</a>(num_dofs, 1, b);</div></div><!-- fragment --><p> Compute function and derivative with AD </p><div class="fragment"><div class="line">cfad = 2*afad + std::cos(afad*bfad);</div></div><!-- fragment --><p> After this, we output the variables again and see that some additional derivatives have been declared. Furthermore, <em>cfad</em> is filled with the values and derivatives </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;afad=&quot;</span> &lt;&lt; afad &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;bfad=&quot;</span> &lt;&lt; bfad &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;cfad=&quot;</span> &lt;&lt; cfad &lt;&lt; std::endl;</div></div><!-- fragment --><p> Extract value and derivatives </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> c_ad = cfad.val().val();       <span class="comment">// r</span></div><div class="line"><span class="keywordtype">double</span> dcda_ad = cfad.dx(0).val();    <span class="comment">// dr/da</span></div><div class="line"><span class="keywordtype">double</span> dcdb_ad = cfad.dx(1).val();    <span class="comment">// dr/db</span></div><div class="line"><span class="keywordtype">double</span> d2cda2_ad = cfad.dx(0).dx(0);  <span class="comment">// d^2r/da^2</span></div><div class="line"><span class="keywordtype">double</span> d2cdadb_ad = cfad.dx(0).dx(1); <span class="comment">// d^2r/dadb</span></div><div class="line"><span class="keywordtype">double</span> d2cdbda_ad = cfad.dx(1).dx(0); <span class="comment">// d^2r/dbda</span></div><div class="line"><span class="keywordtype">double</span> d2cdb2_ad = cfad.dx(1).dx(1);  <span class="comment">// d^2/db^2</span></div></div><!-- fragment --><p> Now we can print the actual double value of c and some of the derivatives: </p><div class="fragment"><div class="line">     std::cout &lt;&lt; <span class="stringliteral">&quot;c_ad=&quot;</span> &lt;&lt; c_ad &lt;&lt; std::endl;</div><div class="line">     std::cout &lt;&lt; <span class="stringliteral">&quot;Derivatives at the point (&quot;</span> &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line">     std::cout &lt;&lt; <span class="stringliteral">&quot;dc/da = &quot;</span> &lt;&lt; dcda_ad &lt;&lt; <span class="stringliteral">&quot;, dc/db=&quot;</span> &lt;&lt; dcdb_ad &lt;&lt; std::endl;</div><div class="line">     std::cout &lt;&lt; <span class="stringliteral">&quot;d²c/da² = &quot;</span> &lt;&lt; d2cda2_ad &lt;&lt; <span class="stringliteral">&quot;, d²c/db²=&quot;</span> &lt;&lt; d2cdb2_ad &lt;&lt; std::endl;</div><div class="line">     std::cout &lt;&lt; <span class="stringliteral">&quot;d²c/dadb = &quot;</span> &lt;&lt; d2cdadb_ad &lt;&lt; <span class="stringliteral">&quot;, d²c/dbda=&quot;</span> &lt;&lt; d2cdbda_ad &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex7"></a>
7. Example: First and second derivatives - Using tensors (The full story)</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="Sacado__example_8cc.html#a0b694459e5e15c1578d97e637faba8de">sacado_test_7</a> ()</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim=3;</div><div class="line"> </div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Test 7:&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p> Defining the inputs (material parameters, strain tensor) </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> lambda=1;</div><div class="line"><span class="keywordtype">double</span> mu=2;</div><div class="line">SymmetricTensor&lt;2,dim, double&gt; eps;</div><div class="line"></div><div class="line">eps[0][0] = 1.;</div><div class="line">eps[1][1] = 2.;</div><div class="line">eps[2][2] = 3.;</div><div class="line"></div><div class="line">eps[0][1] = 4.;</div><div class="line">eps[0][2] = 5.;</div><div class="line">eps[1][2] = 6.;</div></div><!-- fragment --><p> Here we skip the one-field example and right away show the equations for a two-field problem with <em>eps</em> and <em>phi</em>. </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> phi=0.3;</div></div><!-- fragment --><p> Setup of the map relating the indices (as before) </p><div class="fragment"><div class="line">std::map&lt;unsigned int,std::pair&lt;unsigned int,unsigned int&gt;&gt; std_map_indicies;</div><div class="line"></div><div class="line">std::pair&lt;unsigned int, unsigned int&gt; tmp_pair;</div><div class="line">tmp_pair.first=0; tmp_pair.second=0;</div><div class="line">std_map_indicies[0] = tmp_pair;</div><div class="line"></div><div class="line">tmp_pair.first=0; tmp_pair.second=1;</div><div class="line">std_map_indicies[1] = tmp_pair;</div><div class="line"></div><div class="line">tmp_pair.first=0; tmp_pair.second=2;</div><div class="line">std_map_indicies[2] = tmp_pair;</div><div class="line"></div><div class="line">tmp_pair.first=1; tmp_pair.second=1;</div><div class="line">std_map_indicies[3] = tmp_pair;</div><div class="line"></div><div class="line">tmp_pair.first=1; tmp_pair.second=2;</div><div class="line">std_map_indicies[4] = tmp_pair;</div><div class="line"></div><div class="line">tmp_pair.first=2; tmp_pair.second=2;</div><div class="line">std_map_indicies[5] = tmp_pair;</div></div><!-- fragment --><p> Number of independent variables (6 for the tensor and 1 for the scalar phi) </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbr_dofs = 6+1;</div></div><!-- fragment --><p> Declaring the special data types containing all derivatives </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> Sacado::Fad::DFad&lt;double&gt; <a class="code" href="Sacado__Wrapper_8h.html#a7e0893207b87dad05c66a34baac8ed2e">DFadType</a>;</div><div class="line">SymmetricTensor&lt;2,dim, Sacado::Fad::DFad&lt;DFadType&gt; &gt; eps_fad, eps_fad_squared;</div><div class="line">Sacado::Fad::DFad&lt;DFadType&gt; phi_fad;</div></div><!-- fragment --><p> Setting the dofs </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=0; x&lt;6; ++x )</div><div class="line">{</div><div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=std_map_indicies[x].first;</div><div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=std_map_indicies[x].second;</div><div class="line">   (eps_fad[i][j]).diff( x, nbr_dofs); <span class="comment">// set up the &quot;inner&quot; derivatives</span></div><div class="line">   (eps_fad[i][j]).val() = <a class="code" href="Sacado__example_8cc.html#a868b94676739e612d9c95940e70892a9">fad_double</a>(nbr_dofs, x, eps[i][j]); <span class="comment">// set up the &quot;outer&quot; derivatives</span></div><div class="line">}</div><div class="line"></div><div class="line">phi_fad.diff( 6, nbr_dofs );</div><div class="line">phi_fad.val() = <a class="code" href="Sacado__example_8cc.html#a868b94676739e612d9c95940e70892a9">fad_double</a>(nbr_dofs, 6, phi); <span class="comment">// set up the &quot;outer&quot; derivatives</span></div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;eps_fad=&quot;</span> &lt;&lt; eps_fad &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;phi_fad=&quot;</span> &lt;&lt; phi_fad &lt;&lt; std::endl;</div></div><!-- fragment --><p> Compute eps² = eps_ij * eps_jk in index notation </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">   <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dim; ++k )</div><div class="line">       <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; ++j )</div><div class="line">           <span class="keywordflow">if</span> ( i&gt;=k )</div><div class="line">               eps_fad_squared[i][k] += eps_fad[i][j] * eps_fad[j][k];</div></div><!-- fragment --><p> Compute the strain energy density </p><div class="fragment"><div class="line">Sacado::Fad::DFad&lt;DFadType&gt; energy;</div><div class="line">energy = lambda/2. * trace(eps_fad)*trace(eps_fad) + mu * trace(eps_fad_squared) + 25 * phi_fad * trace(eps_fad);</div></div><!-- fragment --><p> Give some insight into the storage of the values and derivatives </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;energy=&quot;</span> &lt;&lt; energy &lt;&lt; std::endl;</div></div><!-- fragment --><p> Compute sigma as </p><p class="formulaDsp">
\[ \frac{\partial \Psi}{\partial \boldsymbol{\varepsilon}} \]
</p>
 <div class="fragment"><div class="line">SymmetricTensor&lt;2,dim&gt; sigma_Sac;</div><div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=0; x&lt;6; ++x )</div><div class="line">{</div><div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=std_map_indicies[x].first;</div><div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=std_map_indicies[x].second;</div><div class="line">   <span class="keywordflow">if</span> ( i!=j )</div><div class="line">       sigma_Sac[i][j] = 0.5 * energy.dx(x).val();</div><div class="line">   <span class="keywordflow">else</span></div><div class="line">       sigma_Sac[i][j] = energy.dx(x).val();</div><div class="line">}</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;sigma_Sacado=&quot;</span> &lt;&lt; sigma_Sac &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> d_energy_d_phi = energy.dx(6).val();</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d_energy_d_phi=&quot;</span> &lt;&lt; d_energy_d_phi &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> d2_energy_d_phi_2 = energy.dx(6).dx(6);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d2_energy_d_phi_2=&quot;</span> &lt;&lt; d2_energy_d_phi_2 &lt;&lt; std::endl;</div></div><!-- fragment --><p> Analytical stress tensor: </p><div class="fragment"><div class="line">SymmetricTensor&lt;2,dim&gt; sigma;</div><div class="line">sigma = lambda*trace(eps)*unit_symmetric_tensor&lt;dim&gt;() + 2. * mu * eps + 25 * phi * unit_symmetric_tensor&lt;dim&gt;();</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;analy. sigma=&quot;</span> &lt;&lt; sigma &lt;&lt; std::endl;</div></div><!-- fragment --><p> Sacado-Tangent </p><div class="fragment"><div class="line">SymmetricTensor&lt;4,dim&gt; C_Sac;</div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=0;x&lt;6;++x)</div><div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y=0;y&lt;6;++y)</div><div class="line">   {</div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=std_map_indicies[y].first;</div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=std_map_indicies[y].second;</div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=std_map_indicies[x].first;</div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=std_map_indicies[x].second;</div><div class="line"></div><div class="line">       <span class="keywordtype">double</span> deriv = energy.dx(x).dx(y); <span class="comment">// Access the derivatives of the (i,j)-th component of \a sigma</span></div><div class="line"></div><div class="line">       <span class="keywordflow">if</span> ( k!=l &amp;&amp; i!=j )</div><div class="line">           C_Sac[i][j][k][l] = 0.25* deriv;</div><div class="line">       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(k!=l)<span class="comment">/*Compare to Voigt notation since only SymmetricTensor instead of Tensor*/</span></div><div class="line">       {</div><div class="line">           C_Sac[i][j][k][l] = 0.5*deriv;</div><div class="line">           C_Sac[i][j][l][k] = 0.5*deriv;</div><div class="line">       }</div><div class="line">       <span class="keywordflow">else</span></div><div class="line">           C_Sac[i][j][k][l] = deriv;</div><div class="line">   }</div></div><!-- fragment --><p> Analytical tangent </p><div class="fragment"><div class="line">     SymmetricTensor&lt;4,dim&gt; C_analy;</div><div class="line">     C_analy = lambda * outer_product(unit_symmetric_tensor&lt;dim&gt;(), unit_symmetric_tensor&lt;dim&gt;()) + 2. * mu * identity_tensor&lt;dim&gt;();</div><div class="line"> </div><div class="line">    <span class="keywordtype">double</span> error_Sacado_vs_analy=0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">        <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; ++j)</div><div class="line">            <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dim; ++k)</div><div class="line">                <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l&lt;dim; ++l)</div><div class="line">                    error_Sacado_vs_analy += std::fabs(C_Sac[i][j][k][l] - C_analy[i][j][k][l]);</div><div class="line"> </div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Numerical error=&quot;</span> &lt;&lt; error_Sacado_vs_analy &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex8"></a>
8. Example: First and second derivatives - Using the Wrapper</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="Sacado__example_8cc.html#aa7108ff8393b98d66dfef50899d048d9">sacado_test_8</a> ()</div><div class="line"> </div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim=3;</div><div class="line"> </div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Test 8:&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p> Defining the inputs (material parameters, strain tensor) </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> lambda=1;</div><div class="line"><span class="keywordtype">double</span> mu=2;</div><div class="line">SymmetricTensor&lt;2,dim, double&gt; eps;</div><div class="line"><span class="keywordtype">double</span> phi = 0.3;</div><div class="line"></div><div class="line">eps[0][0] = 1.;</div><div class="line">eps[1][1] = 2.;</div><div class="line">eps[2][2] = 3.;</div><div class="line"></div><div class="line">eps[0][1] = 4.;</div><div class="line">eps[0][2] = 5.;</div><div class="line">eps[1][2] = 6.;</div></div><!-- fragment --><p> Declaring the special data types containing all derivatives </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> Sacado::Fad::DFad&lt;double&gt; <a class="code" href="Sacado__Wrapper_8h.html#a7e0893207b87dad05c66a34baac8ed2e">DFadType</a>;</div></div><!-- fragment --><p> Declare the variables <em>eps_fad</em> and <em>phi_fad</em> as the special Wrapper data types </p><div class="fragment"><div class="line"><a class="code" href="classSacado__Wrapper_1_1SymTensor2.html">Sacado_Wrapper::SymTensor2&lt;dim&gt;</a> eps_fad;</div><div class="line"><a class="code" href="classSacado__Wrapper_1_1SW__double2.html">Sacado_Wrapper::SW_double2&lt;dim&gt;</a> phi_fad;</div></div><!-- fragment --><p> Declare the summary data type relating all the dofs and initialising them too </p><div class="fragment"><div class="line"><a class="code" href="classSacado__Wrapper_1_1DoFs__summary.html">Sacado_Wrapper::DoFs_summary&lt;dim&gt;</a> DoFs_summary;</div><div class="line">DoFs_summary.<a class="code" href="classSacado__Wrapper_1_1DoFs__summary.html#ae273d0fa3197118a11d7005523e27d8a">init_set_dofs</a>(eps_fad, eps, phi_fad, phi);</div></div><!-- fragment --><p> The variables are outputted to give some insight into the storage of the values (derivatives still trivial). </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;eps_fad=&quot;</span> &lt;&lt; eps_fad &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;phi_fad=&quot;</span> &lt;&lt; phi_fad &lt;&lt; std::endl;</div></div><!-- fragment --><p> Compute eps² = eps_ij * eps_jk in index notation </p><div class="fragment"><div class="line">SymmetricTensor&lt;2,dim, Sacado::Fad::DFad&lt;DFadType&gt; &gt; eps_fad_squared;</div><div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">   <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dim; ++k )</div><div class="line">       <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; ++j )</div><div class="line">           <span class="keywordflow">if</span> ( i&gt;=k )</div><div class="line">               eps_fad_squared[i][k] += eps_fad[i][j] * eps_fad[j][k];</div></div><!-- fragment --><p> Compute the strain energy density </p><div class="fragment"><div class="line">Sacado::Fad::DFad&lt;DFadType&gt; energy;</div><div class="line">energy = lambda/2. * trace(eps_fad)*trace(eps_fad) + mu * trace(eps_fad_squared) + 25 * phi_fad * trace(eps_fad);</div></div><!-- fragment --><p> The energy is outputted (formatted by hand) to give some insight into the storage of the values and derivatives. <br />
energy=399 [ 17.5 32 40 21.5 48 25.5 150 ] <br />
[ 17.5 [ 5 0 0 1 0 1 25 ] 32 [ 0 8 0 0 0 0 0 ] 40 [ 0 0 8 0 0 0 0 ] <br />
21.5 [ 1 0 0 5 0 1 25 ] 48 [ 0 0 0 0 8 0 0 ] 25.5 [ 1 0 0 1 0 5 25 ] <br />
150 [ 25 0 0 25 0 25 0 ] ]</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;energy=&quot;</span> &lt;&lt; energy &lt;&lt; std::endl;</div></div><!-- fragment --><p> Compute sigma as </p><p class="formulaDsp">
\[ \boldsymbol{\sigma} = \frac{\partial \Psi}{\partial \boldsymbol{\varepsilon}} \]
</p>
 <div class="fragment"><div class="line">SymmetricTensor&lt;2,dim&gt; sigma_Sac;</div><div class="line">eps_fad.get_tangent(sigma_Sac, energy);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;sigma_Sacado=&quot;</span> &lt;&lt; sigma_Sac &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> d_energy_d_phi;</div><div class="line">phi_fad.<a class="code" href="classSacado__Wrapper_1_1SW__double2.html#ad51ba1e79171d60861b28098dfef903d">get_tangent</a>(d_energy_d_phi, energy);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d_energy_d_phi=&quot;</span> &lt;&lt; d_energy_d_phi &lt;&lt; std::endl;</div></div><!-- fragment --><p> Analytical stress tensor: </p><div class="fragment"><div class="line">SymmetricTensor&lt;2,dim&gt; sigma;</div><div class="line">sigma = lambda*trace(eps)*unit_symmetric_tensor&lt;dim&gt;() + 2. * mu * eps + 25 * phi * unit_symmetric_tensor&lt;dim&gt;();</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;analy. sigma=&quot;</span> &lt;&lt; sigma &lt;&lt; std::endl;</div></div><!-- fragment --><p> Sacado stress tangent (or eps curvature) as </p><p class="formulaDsp">
\[ \frac{\partial^2 \Psi}{\partial \boldsymbol{\varepsilon}^2} \]
</p>
 <div class="fragment"><div class="line">SymmetricTensor&lt;4,dim&gt; C_Sac;</div><div class="line">eps_fad.get_curvature(C_Sac, energy);</div></div><!-- fragment --><p> Sacado phi curvature as </p><p class="formulaDsp">
\[ \frac{\partial^2 \Psi}{\partial \varphi^2} \]
</p>
 <div class="fragment"><div class="line"><span class="keywordtype">double</span> d2_energy_d_phi_2;</div><div class="line">phi_fad.<a class="code" href="classSacado__Wrapper_1_1SW__double2.html#a7d3f3a21cd842645af9861bf50308825">get_curvature</a>(d2_energy_d_phi_2, energy);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d2_energy_d_phi_2=&quot;</span> &lt;&lt; d2_energy_d_phi_2 &lt;&lt; std::endl;</div></div><!-- fragment --><p> Sacado derivatives </p><p class="formulaDsp">
\[ \frac{\partial^2 \Psi}{\partial \boldsymbol{\varepsilon} \partial \varphi} \]
</p>
 <div class="fragment"><div class="line">SymmetricTensor&lt;2,dim&gt; d2_energy_d_eps_d_phi;</div><div class="line">DoFs_summary.<a class="code" href="classSacado__Wrapper_1_1DoFs__summary.html#adf29bfda10814ecee9572a4751d34db0">get_curvature</a>(d2_energy_d_eps_d_phi, energy, eps_fad, phi_fad);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d2_energy_d_eps_d_phi=&quot;</span> &lt;&lt; d2_energy_d_eps_d_phi &lt;&lt; std::endl;</div></div><!-- fragment --><p> Sacado derivatives </p><p class="formulaDsp">
\[ \frac{\partial^2 \Psi}{\partial \varphi \partial \boldsymbol{\varepsilon}} \]
</p>
 <div class="fragment"><div class="line">SymmetricTensor&lt;2,dim&gt; d2_energy_d_phi_d_eps;</div><div class="line">DoFs_summary.<a class="code" href="classSacado__Wrapper_1_1DoFs__summary.html#adf29bfda10814ecee9572a4751d34db0">get_curvature</a>(d2_energy_d_phi_d_eps, energy, phi_fad, eps_fad);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d2_energy_d_phi_d_eps=&quot;</span> &lt;&lt; d2_energy_d_phi_d_eps &lt;&lt; std::endl;</div></div><!-- fragment --><p> When you consider the output: <br />
d2_energy_d_eps_d_phi=25 0 0 0 25 0 0 0 25 <br />
d2_energy_d_phi_d_eps=25 0 0 0 25 0 0 0 25 <br />
in detail you will notice that both second derivatives are identical. This compplies with the Schwarz integrability condition (Symmetry of second derivatives) (ignoring all limitation and requirements), it holds </p><p class="formulaDsp">
\[ \frac{\partial^2 \Psi}{\partial \boldsymbol{\varepsilon} \partial \varphi} = \frac{\partial^2 \Psi}{\partial \varphi \partial \boldsymbol{\varepsilon}} \]
</p>
<p>Analytical stress tangent </p><div class="fragment"><div class="line">SymmetricTensor&lt;4,dim&gt; C_analy;</div><div class="line">C_analy = lambda * outer_product(unit_symmetric_tensor&lt;dim&gt;(), unit_symmetric_tensor&lt;dim&gt;()) + 2. * mu * identity_tensor&lt;dim&gt;();</div></div><!-- fragment --><p> Compute the error for the stress tangent </p><div class="fragment"><div class="line">     <span class="keywordtype">double</span> error_Sacado_vs_analy=0;</div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">        <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; ++j)</div><div class="line">            <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dim; ++k)</div><div class="line">                <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l&lt;dim; ++l)</div><div class="line">                    error_Sacado_vs_analy += std::fabs(C_Sac[i][j][k][l] - C_analy[i][j][k][l]);</div><div class="line">     std::cout &lt;&lt; <span class="stringliteral">&quot;Numerical error=&quot;</span> &lt;&lt; error_Sacado_vs_analy &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex9"></a>
9. Example: Why we sometimes need the factor of 0.5 in the derivatives and sometimes we don't</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="Sacado__example_8cc.html#ae176f83fe1943e102fe325d4a14f097e">sacado_test_9</a> ()</div><div class="line"> </div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim=3;</div><div class="line"> </div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Test 9:&quot;</span> &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    <span class="keywordtype">double</span> kappa_param = 5;</div><div class="line">    <a class="code" href="Sacado__example_8cc.html#a868b94676739e612d9c95940e70892a9">fad_double</a> kappa (kappa_param);</div><div class="line">    <span class="keywordtype">double</span> mu = 2;</div><div class="line"> </div><div class="line">    SymmetricTensor&lt;2,dim, fad_double&gt; sigma, eps;</div><div class="line"> </div><div class="line">    std::map&lt;unsigned int,std::pair&lt;unsigned int,unsigned int&gt;&gt; std_map_indicies;</div><div class="line"> </div><div class="line">        eps[0][0] = 1;</div><div class="line">        eps[1][1] = 2;</div><div class="line">        eps[2][2] = 3;</div><div class="line"> </div><div class="line">        eps[0][1] = 4;</div><div class="line">        eps[0][2] = 5;</div><div class="line">        eps[1][2] = 6;</div><div class="line"> </div><div class="line"> </div><div class="line">        eps[0][0].diff(0,6);</div><div class="line">        eps[0][1].diff(1,6);</div><div class="line">        eps[0][2].diff(2,6);</div><div class="line">        eps[1][1].diff(3,6);</div><div class="line">        eps[1][2].diff(4,6);</div><div class="line">        eps[2][2].diff(5,6);</div><div class="line"> </div><div class="line">        std::pair&lt;unsigned int, unsigned int&gt; tmp_pair;</div><div class="line">        tmp_pair.first=0; tmp_pair.second=0;</div><div class="line">        std_map_indicies[0] = tmp_pair;</div><div class="line"> </div><div class="line">        tmp_pair.first=0; tmp_pair.second=1;</div><div class="line">        std_map_indicies[1] = tmp_pair;</div><div class="line"> </div><div class="line">        tmp_pair.first=0; tmp_pair.second=2;</div><div class="line">        std_map_indicies[2] = tmp_pair;</div><div class="line"> </div><div class="line">        tmp_pair.first=1; tmp_pair.second=1;</div><div class="line">        std_map_indicies[3] = tmp_pair;</div><div class="line"> </div><div class="line">        tmp_pair.first=1; tmp_pair.second=2;</div><div class="line">        std_map_indicies[4] = tmp_pair;</div><div class="line"> </div><div class="line">        tmp_pair.first=2; tmp_pair.second=2;</div><div class="line">        std_map_indicies[5] = tmp_pair;</div><div class="line"> </div><div class="line">    SymmetricTensor&lt;2,dim, fad_double&gt; stdTensor_I (( unit_symmetric_tensor&lt;dim,fad_double&gt;()) );</div><div class="line"> </div><div class="line">    sigma = kappa * (trace(eps) *  stdTensor_I);</div><div class="line">    SymmetricTensor&lt;2,dim,fad_double&gt; tmp = deviator&lt;dim,fad_double&gt;(symmetrize&lt;dim,fad_double&gt;(eps)); tmp*=(mu*2);</div><div class="line">    sigma +=  tmp;</div><div class="line"> </div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;sigma=&quot;</span> &lt;&lt; sigma &lt;&lt; std::endl;</div></div><!-- fragment --><p> Retrieve the values stored in <em>sigma:</em> </p><div class="fragment"><div class="line">  SymmetricTensor&lt;2,dim&gt; sigma_d;</div><div class="line">  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">        <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; ++j )</div><div class="line">            sigma_d[i][j] = sigma[i][j].val();</div><div class="line"></div><div class="line">SymmetricTensor&lt;4,dim&gt; C_Sacado;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; ++j )</div><div class="line">    {</div><div class="line">        <span class="keywordtype">double</span> *derivs = &amp;sigma[i][j].fastAccessDx(0); <span class="comment">// Access the derivatives of the (i,j)-th component of \a sigma</span></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=0;x&lt;((dim==2)?3:6);++x)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=std_map_indicies[x].first;</div><div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=std_map_indicies[x].second;</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span>(k!=l)<span class="comment">/*Compare to Voigt notation since only SymmetricTensor instead of Tensor*/</span></div><div class="line">            {</div><div class="line">                C_Sacado[i][j][k][l] = 0.5*derivs[x];</div><div class="line">                C_Sacado[i][j][l][k] = 0.5*derivs[x];</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">                C_Sacado[i][j][k][l] = derivs[x];</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">SymmetricTensor&lt;2,dim&gt; eps_d;</div><div class="line">eps_d[0][0] = 1;</div><div class="line">eps_d[1][1] = 2;</div><div class="line">eps_d[2][2] = 3;</div><div class="line"></div><div class="line">eps_d[0][1] = 4;</div><div class="line">eps_d[0][2] = 5;</div><div class="line">eps_d[1][2] = 6;</div><div class="line"></div><div class="line">SymmetricTensor&lt;2,dim&gt; stress_from_tangent = C_Sacado*eps_d;</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;C_Sacado*eps_d=&quot;</span> &lt;&lt; stress_from_tangent &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;sigma=         &quot;</span> &lt;&lt; sigma_d &lt;&lt; std::endl;</div></div><!-- fragment --> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Add the link to the ac.nz site</dd></dl>
<p>As you can see we obtain the correct stress tensor only by using the factor 0.5 onto the off-diagonal elements of the symmetric tensor. <br />
</p><dl class="section note"><dt>Note</dt><dd>So, why do we need the factor 0.5 then? (based on [homepages.engineering.auckland.ac.nz ...])<br />
When using symmetric tensor one has to be aware of the definition of the independent variables. In 3d those are the following 6 components: <br />
<ul>
<li>\( A_{11} \)</li>
<li>\( A_{22} \)</li>
<li>\( A_{33} \)</li>
<li>\( \overline{A_{12}} \)</li>
<li>\( \overline{A_{13}} \)</li>
<li>\( \overline{A_{23}} \) <br />
Here the overlined components denote the averaged values, such that</li>
<li>\( \overline{A_{12}} = 0.5 \cdot [ A_{12} + A_{21} ] = A_{12} = A_{21} \)</li>
<li>... <br />
This looks rather boring, because the averaged value of the two identical components (symmetry) is identical to the components. But (and that is a crucial BUT), this only holds for the values NOT the derivatives. The derivative of a function \( \Phi \) with respect to a symmetric tensor <em>A</em> is <p class="formulaDsp">
\[ \frac{\partial \Phi}{\partial \overline{A_{12}}} = \frac{\partial \Phi}{\partial A_{12}} \cdot \frac{\partial A_{12}}{\partial \overline{A_{12}}} + \frac{\partial \Phi}{\partial A_{21}} \cdot \frac{\partial A_{21}}{\partial \overline{A_{21}}} = \frac{\partial \Phi}{\partial A_{12}} + \frac{\partial \Phi}{\partial A_{21}} = 2 \cdot \frac{\partial \Phi}{\partial A_{12}} \]
</p>
 Note how the derivatives with respect to the actual tensor components (here 12 and 21) are identical. <br />
However, our derivatives (computed via Sacado) were calculated with respect to the actually independent variables (overlined). Still, in the tensor with the derivatives we want the derivatives with respect to the normal components (not overlined). <br />
Summary: <br />
When you compute derivatives with respect to a symmetric tensor, you have to scale the off-diagonal elements by 0.5 to account for the fact that you actually work with the averaged values. <br />
As a consequence, we use the factor 0.5 for all off-diagonal components of derivatives with respect to symmetric tensors. For second derivatives with respect to symmetric tensors the factors 0.5 and 0.25 come into play.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">}</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * The main function just calls all the examples and puts some space between the outputs.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="Sacado__example_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> ()</div><div class="line">{</div><div class="line">    <a class="code" href="Sacado__example_8cc.html#a71b2675e62203edc430e7ffc8a365193">sacado_test_scalar</a> ();</div><div class="line"> </div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    <a class="code" href="Sacado__example_8cc.html#a8ef4ff1e9526ca8451cdcd1678366d2c">sacado_test_2</a> ();</div><div class="line"> </div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    <a class="code" href="Sacado__example_8cc.html#ae45e1df0eec246dbb6f2c3d28a2a58e4">sacado_test_3</a> ();</div><div class="line"> </div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    <a class="code" href="Sacado__example_8cc.html#ae63cc8526935cb0512668e83cfc7b929">sacado_test_3B</a> ();</div><div class="line"> </div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    <a class="code" href="Sacado__example_8cc.html#a2f4def4563e31d720e07bc7d6363ebe2">sacado_test_4</a>();</div><div class="line"> </div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    <a class="code" href="Sacado__example_8cc.html#a327dbbb4ea7fc9840c46d149843a44c2">sacado_test_5</a>();</div><div class="line"> </div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    <a class="code" href="Sacado__example_8cc.html#a27450ab52a9d4250e3f5a5f2a3f8f317">sacado_test_6</a>();</div><div class="line"> </div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    <a class="code" href="Sacado__example_8cc.html#a0b694459e5e15c1578d97e637faba8de">sacado_test_7</a>();</div><div class="line"> </div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    <a class="code" href="Sacado__example_8cc.html#aa7108ff8393b98d66dfef50899d048d9">sacado_test_8</a>();</div><div class="line"> </div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    <a class="code" href="Sacado__example_8cc.html#ae176f83fe1943e102fe325d4a14f097e">sacado_test_9</a>();</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="END"></a>
The End</h1>
<p>Hosted via GitHub according to <a href="https://goseeky.wordpress.com/2017/07/22/documentation-101-doxygen-with-github-pages/">https://goseeky.wordpress.com/2017/07/22/documentation-101-doxygen-with-github-pages/</a> <br />
Design of the documentation inspired by the deal.ii tutorial programs. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
